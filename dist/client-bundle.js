/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./client.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./client.ts":
/*!*******************!*\
  !*** ./client.ts ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) 2018 The xterm.js authors. All rights reserved.
 * @license MIT
 *
 * This file is the entry point for browserify.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/// <reference path="./node_modules/xterm/typings/xterm.d.ts"/>
var Terminal_1 = __webpack_require__(/*! ./node_modules/xterm/lib/public/Terminal */ "./node_modules/xterm/lib/public/Terminal.js");
var attach = __webpack_require__(/*! ./node_modules/xterm/lib/addons/attach/attach */ "./node_modules/xterm/lib/addons/attach/attach.js");
var fit = __webpack_require__(/*! ./node_modules/xterm/lib/addons/fit/fit */ "./node_modules/xterm/lib/addons/fit/fit.js");
var fullscreen = __webpack_require__(/*! ./node_modules/xterm/lib/addons/fullscreen/fullscreen */ "./node_modules/xterm/lib/addons/fullscreen/fullscreen.js");
var search = __webpack_require__(/*! ./node_modules/xterm/lib/addons/search/search */ "./node_modules/xterm/lib/addons/search/search.js");
var webLinks = __webpack_require__(/*! ./node_modules/xterm/lib/addons/webLinks/webLinks */ "./node_modules/xterm/lib/addons/webLinks/webLinks.js");
var winptyCompat = __webpack_require__(/*! ./node_modules/xterm/lib/addons/winptyCompat/winptyCompat */ "./node_modules/xterm/lib/addons/winptyCompat/winptyCompat.js");
var socketIo = __webpack_require__(/*! socket.io-client */ "./node_modules/socket.io-client/lib/index.js");
Terminal_1.Terminal.applyAddon(attach);
Terminal_1.Terminal.applyAddon(fit);
Terminal_1.Terminal.applyAddon(fullscreen);
Terminal_1.Terminal.applyAddon(search);
Terminal_1.Terminal.applyAddon(webLinks);
Terminal_1.Terminal.applyAddon(winptyCompat);
var term;
var protocol;
var socketURL;
var socket;
var pid;
var terminalContainer = document.getElementById('terminal-container');
createTerminal();
function createTerminal() {
    // Clean terminal
    while (terminalContainer.children.length) {
        terminalContainer.removeChild(terminalContainer.children[0]);
    }
    term = new Terminal_1.Terminal({});
    term.on('resize', function (size) {
        if (!pid) {
            return;
        }
        var cols = size.cols;
        var rows = size.rows;
        var url = '/console/terminals/' + pid + '/size?cols=' + cols + '&rows=' + rows;
        fetch(url, { method: 'POST' });
    });
    socketURL = location.protocol + "//" + location.hostname + ((location.port) ? (':' + location.port) : '') + '/console/terminals/';
    term.open(terminalContainer);
    term.winptyCompatInit();
    term.webLinksInit();
    term.fit();
    term.focus();
    // fit is called within a setTimeout, cols and rows need this.
    setTimeout(function () {
        initOptions(term);
        // Set terminal size again to set the specific dimensions on the demo
        updateTerminalSize();
        fetch('/console/terminals?cols=' + term.cols + '&rows=' + term.rows, { method: 'POST' }).then(function (res) {
            res.text().then(function (processId) {
                pid = processId;
                socketURL += processId;
                socket = socketIo(socketURL);
                runRealTerminal();
                socket.on("reconnect_error", runFakeTerminal);
                socket.on("connect_error", runFakeTerminal);
            });
        });
    }, 0);
}
function runRealTerminal() {
    term.attach(socket);
    term._initialized = true;
}
function runFakeTerminal() {
    if (term._initialized) {
        return;
    }
    term._initialized = true;
    term.prompt = function () {
        term.write('\r\n$ ');
    };
    term.writeln('Welcome to xterm.js');
    term.writeln('This is a local terminal emulation, without a real terminal in the back-end.');
    term.writeln('Type some keys and commands to play around.');
    term.writeln('');
    term.prompt();
    term._core.register(term.addDisposableListener('key', function (key, ev) {
        var printable = !ev.altKey && !ev.altGraphKey && !ev.ctrlKey && !ev.metaKey;
        if (ev.keyCode === 13) {
            term.prompt();
        }
        else if (ev.keyCode === 8) {
            // Do not delete the prompt
            if (term.x > 2) {
                term.write('\b \b');
            }
        }
        else if (printable) {
            term.write(key);
        }
    }));
    term._core.register(term.addDisposableListener('paste', function (data, ev) {
        term.write(data);
    }));
}
function initOptions(term) {
    var blacklistedOptions = [
        // Internal only options
        'cancelEvents',
        'convertEol',
        'debug',
        'handler',
        'screenKeys',
        'termName',
        'useFlowControl',
        // Complex option
        'theme'
    ];
    var stringOptions = {
        bellSound: null,
        bellStyle: ['none', 'sound'],
        cursorStyle: ['block', 'underline', 'bar'],
        experimentalCharAtlas: ['none', 'static', 'dynamic'],
        fontFamily: null,
        fontWeight: ['normal', 'bold', '100', '200', '300', '400', '500', '600', '700', '800', '900'],
        fontWeightBold: ['normal', 'bold', '100', '200', '300', '400', '500', '600', '700', '800', '900'],
        rendererType: ['dom', 'canvas'],
    };
    var options = Object.keys(term._core.options);
    var booleanOptions = [];
    var numberOptions = [];
    options.filter(function (o) { return blacklistedOptions.indexOf(o) === -1; }).forEach(function (o) {
        switch (typeof term.getOption(o)) {
            case 'boolean':
                booleanOptions.push(o);
                break;
            case 'number':
                numberOptions.push(o);
                break;
            default:
                if (Object.keys(stringOptions).indexOf(o) === -1) {
                    console.warn("Unrecognized option: \"" + o + "\"");
                }
        }
    });
}
window.addEventListener("resize", updateTerminalSize, false);
function updateTerminalSize() {
    term.fit();
}


/***/ }),

/***/ "./node_modules/after/index.js":
/*!*************************************!*\
  !*** ./node_modules/after/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}


/***/ }),

/***/ "./node_modules/arraybuffer.slice/index.js":
/*!*************************************************!*\
  !*** ./node_modules/arraybuffer.slice/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};


/***/ }),

/***/ "./node_modules/backo2/index.js":
/*!**************************************!*\
  !*** ./node_modules/backo2/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};



/***/ }),

/***/ "./node_modules/base64-arraybuffer/lib/base64-arraybuffer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/base64-arraybuffer/lib/base64-arraybuffer.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(){
  "use strict";

  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

  // Use a lookup table to find the index.
  var lookup = new Uint8Array(256);
  for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
  }

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = lookup[base64.charCodeAt(i)];
      encoded2 = lookup[base64.charCodeAt(i+1)];
      encoded3 = lookup[base64.charCodeAt(i+2)];
      encoded4 = lookup[base64.charCodeAt(i+3)];

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})();


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/blob/index.js":
/*!************************************!*\
  !*** ./node_modules/blob/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :
  typeof WebKitBlobBuilder !== 'undefined' ? WebKitBlobBuilder :
  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :
  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : 
  false;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var a = new Blob(['hi']);
    return a.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if Blob constructor supports ArrayBufferViews
 * Fails in Safari 6, so we need to map to ArrayBuffers there.
 */

var blobSupportsArrayBufferView = blobSupported && (function() {
  try {
    var b = new Blob([new Uint8Array([1,2])]);
    return b.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

/**
 * Helper function that maps ArrayBufferViews to ArrayBuffers
 * Used by BlobBuilder constructor and old browsers that didn't
 * support it in the Blob constructor.
 */

function mapArrayBufferViews(ary) {
  return ary.map(function(chunk) {
    if (chunk.buffer instanceof ArrayBuffer) {
      var buf = chunk.buffer;

      // if this is a subarray, make a copy so we only
      // include the subarray region from the underlying buffer
      if (chunk.byteLength !== buf.byteLength) {
        var copy = new Uint8Array(chunk.byteLength);
        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
        buf = copy.buffer;
      }

      return buf;
    }

    return chunk;
  });
}

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  mapArrayBufferViews(ary).forEach(function(part) {
    bb.append(part);
  });

  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

function BlobConstructor(ary, options) {
  return new Blob(mapArrayBufferViews(ary), options || {});
};

if (typeof Blob !== 'undefined') {
  BlobBuilderConstructor.prototype = Blob.prototype;
  BlobConstructor.prototype = Blob.prototype;
}

module.exports = (function() {
  if (blobSupported) {
    return blobSupportsArrayBufferView ? Blob : BlobConstructor;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/component-bind/index.js":
/*!**********************************************!*\
  !*** ./node_modules/component-bind/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};


/***/ }),

/***/ "./node_modules/component-emitter/index.js":
/*!*************************************************!*\
  !*** ./node_modules/component-emitter/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Expose `Emitter`.
 */

if (true) {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};


/***/ }),

/***/ "./node_modules/component-inherit/index.js":
/*!*************************************************!*\
  !*** ./node_modules/component-inherit/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};

/***/ }),

/***/ "./node_modules/engine.io-client/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/engine.io-client/lib/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


module.exports = __webpack_require__(/*! ./socket */ "./node_modules/engine.io-client/lib/socket.js");

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/lib/browser.js");


/***/ }),

/***/ "./node_modules/engine.io-client/lib/socket.js":
/*!*****************************************************!*\
  !*** ./node_modules/engine.io-client/lib/socket.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Module dependencies.
 */

var transports = __webpack_require__(/*! ./transports/index */ "./node_modules/engine.io-client/lib/transports/index.js");
var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/component-emitter/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/engine.io-client/node_modules/debug/src/browser.js")('engine.io-client:socket');
var index = __webpack_require__(/*! indexof */ "./node_modules/indexof/index.js");
var parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/lib/browser.js");
var parseuri = __webpack_require__(/*! parseuri */ "./node_modules/parseuri/index.js");
var parseqs = __webpack_require__(/*! parseqs */ "./node_modules/parseqs/index.js");

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket (uri, opts) {
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' === typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.hostname = uri.host;
    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  } else if (opts.host) {
    opts.hostname = parseuri(opts.host).host;
  }

  this.secure = null != opts.secure ? opts.secure
    : (global.location && 'https:' === location.protocol);

  if (opts.hostname && !opts.port) {
    // if no port is specified manually, use the protocol default
    opts.port = this.secure ? '443' : '80';
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (global.location ? location.hostname : 'localhost');
  this.port = opts.port || (global.location && location.port
      ? location.port
      : (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.transportOptions = opts.transportOptions || {};
  this.readyState = '';
  this.writeBuffer = [];
  this.prevBufferLen = 0;
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
    this.perMessageDeflate.threshold = 1024;
  }

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
  this.forceNode = !!opts.forceNode;

  // other options for Node.js client
  var freeGlobal = typeof global === 'object' && global;
  if (freeGlobal.global === freeGlobal) {
    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
      this.extraHeaders = opts.extraHeaders;
    }

    if (opts.localAddress) {
      this.localAddress = opts.localAddress;
    }
  }

  // set on handshake
  this.id = null;
  this.upgrades = null;
  this.pingInterval = null;
  this.pingTimeout = null;

  // set on heartbeat
  this.pingIntervalTimer = null;
  this.pingTimeoutTimer = null;

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = __webpack_require__(/*! ./transport */ "./node_modules/engine.io-client/lib/transport.js");
Socket.transports = __webpack_require__(/*! ./transports/index */ "./node_modules/engine.io-client/lib/transports/index.js");
Socket.parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/lib/browser.js");

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // per-transport options
  var options = this.transportOptions[name] || {};

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    query: query,
    socket: this,
    agent: options.agent || this.agent,
    hostname: options.hostname || this.hostname,
    port: options.port || this.port,
    secure: options.secure || this.secure,
    path: options.path || this.path,
    forceJSONP: options.forceJSONP || this.forceJSONP,
    jsonp: options.jsonp || this.jsonp,
    forceBase64: options.forceBase64 || this.forceBase64,
    enablesXDR: options.enablesXDR || this.enablesXDR,
    timestampRequests: options.timestampRequests || this.timestampRequests,
    timestampParam: options.timestampParam || this.timestampParam,
    policyPort: options.policyPort || this.policyPort,
    pfx: options.pfx || this.pfx,
    key: options.key || this.key,
    passphrase: options.passphrase || this.passphrase,
    cert: options.cert || this.cert,
    ca: options.ca || this.ca,
    ciphers: options.ciphers || this.ciphers,
    rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,
    perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,
    extraHeaders: options.extraHeaders || this.extraHeaders,
    forceNode: options.forceNode || this.forceNode,
    localAddress: options.localAddress || this.localAddress,
    requestTimeout: options.requestTimeout || this.requestTimeout,
    protocols: options.protocols || void (0)
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {
    transport = 'websocket';
  } else if (0 === this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function () {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function (transport) {
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function () {
    self.onDrain();
  })
  .on('packet', function (packet) {
    self.onPacket(packet);
  })
  .on('error', function (e) {
    self.onError(e);
  })
  .on('close', function () {
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 });
  var failed = false;
  var self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen () {
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' === msg.type && 'probe' === msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' === transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' === self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport () {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  // Handle any error that happens while probing
  function onerror (err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose () {
    onerror('transport closed');
  }

  // When the socket is closed while we're probing
  function onclose () {
    onerror('socket closed');
  }

  // When the socket is upgraded while we're probing
  function onupgrade (to) {
    if (transport && to.name !== transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  // Remove all listeners on the transport and on self
  function cleanup () {
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();
};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' === this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' === this.readyState || 'open' === this.readyState ||
      'closing' === this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(JSON.parse(packet.data));
        break;

      case 'pong':
        this.setPing();
        this.emit('pong');
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.onError(err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if ('closed' === this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' === self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api private
*/

Socket.prototype.ping = function () {
  var self = this;
  this.sendPacket('ping', function () {
    self.emit('ping');
  });
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function () {
  this.writeBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (0 === this.writeBuffer.length) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' !== this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @param {Object} options.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, options, fn) {
  this.sendPacket('message', msg, options, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Object} options.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, options, fn) {
  if ('function' === typeof data) {
    fn = data;
    data = undefined;
  }

  if ('function' === typeof options) {
    fn = options;
    options = null;
  }

  if ('closing' === this.readyState || 'closed' === this.readyState) {
    return;
  }

  options = options || {};
  options.compress = false !== options.compress;

  var packet = {
    type: type,
    data: data,
    options: options
  };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  if (fn) this.once('flush', fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.readyState = 'closing';

    var self = this;

    if (this.writeBuffer.length) {
      this.once('drain', function () {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  function close () {
    self.onClose('forced close');
    debug('socket closing - telling transport to close');
    self.transport.close();
  }

  function cleanupAndClose () {
    self.removeListener('upgrade', cleanupAndClose);
    self.removeListener('upgradeError', cleanupAndClose);
    close();
  }

  function waitForUpgrade () {
    // wait for upgrade to finish since we can't send packets while pausing a transport
    self.once('upgrade', cleanupAndClose);
    self.once('upgradeError', cleanupAndClose);
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);

    // clean buffers after, so users can still
    // grab the buffers on `close` event
    self.writeBuffer = [];
    self.prevBufferLen = 0;
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i < j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transport.js":
/*!********************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transport.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/lib/browser.js");
var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/component-emitter/index.js");

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
  this.forceNode = opts.forceNode;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;
  this.localAddress = opts.localAddress;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' === this.readyState || '' === this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function (packets) {
  if ('open' === this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function (data) {
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};


/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Module dependencies
 */

var XMLHttpRequest = __webpack_require__(/*! xmlhttprequest-ssl */ "./node_modules/engine.io-client/lib/xmlhttprequest.js");
var XHR = __webpack_require__(/*! ./polling-xhr */ "./node_modules/engine.io-client/lib/transports/polling-xhr.js");
var JSONP = __webpack_require__(/*! ./polling-jsonp */ "./node_modules/engine.io-client/lib/transports/polling-jsonp.js");
var websocket = __webpack_require__(/*! ./websocket */ "./node_modules/engine.io-client/lib/transports/websocket.js");

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling (opts) {
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (global.location) {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname !== location.hostname || port !== opts.port;
    xs = opts.secure !== isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/polling-jsonp.js":
/*!***********************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/polling-jsonp.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/**
 * Module requirements.
 */

var Polling = __webpack_require__(/*! ./polling */ "./node_modules/engine.io-client/lib/transports/polling.js");
var inherit = __webpack_require__(/*! component-inherit */ "./node_modules/component-inherit/index.js");

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Noop.
 */

function empty () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    if (!global.___eio) global.___eio = [];
    callbacks = global.___eio;
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (global.document && global.addEventListener) {
    global.addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function (e) {
    self.onError('jsonp poll error', e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  if (insertAt) {
    insertAt.parentNode.insertBefore(script, insertAt);
  } else {
    (document.head || document.body).appendChild(script);
  }
  this.script = script;

  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);

  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch (e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function () {
      if (self.iframe.readyState === 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/polling-xhr.js":
/*!*********************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/polling-xhr.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Module requirements.
 */

var XMLHttpRequest = __webpack_require__(/*! xmlhttprequest-ssl */ "./node_modules/engine.io-client/lib/xmlhttprequest.js");
var Polling = __webpack_require__(/*! ./polling */ "./node_modules/engine.io-client/lib/transports/polling.js");
var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/component-emitter/index.js");
var inherit = __webpack_require__(/*! component-inherit */ "./node_modules/component-inherit/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/engine.io-client/node_modules/debug/src/browser.js")('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty () {}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR (opts) {
  Polling.call(this, opts);
  this.requestTimeout = opts.requestTimeout;
  this.extraHeaders = opts.extraHeaders;

  if (global.location) {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = opts.hostname !== global.location.hostname ||
      port !== opts.port;
    this.xs = opts.secure !== isSSL;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function (opts) {
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  opts.requestTimeout = this.requestTimeout;

  // other options for Node.js client
  opts.extraHeaders = this.extraHeaders;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function (data, fn) {
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function (err) {
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function () {
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function (data) {
    self.onData(data);
  });
  req.on('error', function (err) {
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request (opts) {
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined !== opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;
  this.requestTimeout = opts.requestTimeout;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function () {
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    try {
      if (this.extraHeaders) {
        xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
        for (var i in this.extraHeaders) {
          if (this.extraHeaders.hasOwnProperty(i)) {
            xhr.setRequestHeader(i, this.extraHeaders[i]);
          }
        }
      }
    } catch (e) {}

    if ('POST' === this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    try {
      xhr.setRequestHeader('Accept', '*/*');
    } catch (e) {}

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    if (this.requestTimeout) {
      xhr.timeout = this.requestTimeout;
    }

    if (this.hasXDR()) {
      xhr.onload = function () {
        self.onLoad();
      };
      xhr.onerror = function () {
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 2) {
          try {
            var contentType = xhr.getResponseHeader('Content-Type');
            if (self.supportsBinary && contentType === 'application/octet-stream') {
              xhr.responseType = 'arraybuffer';
            }
          } catch (e) {}
        }
        if (4 !== xhr.readyState) return;
        if (200 === xhr.status || 1223 === xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function () {
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function () {
      self.onError(e);
    }, 0);
    return;
  }

  if (global.document) {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function () {
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function (data) {
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function (err) {
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function (fromError) {
  if ('undefined' === typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch (e) {}
  }

  if (global.document) {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function () {
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type');
    } catch (e) {}
    if (contentType === 'application/octet-stream') {
      data = this.xhr.response || this.xhr.responseText;
    } else {
      data = this.xhr.responseText;
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function () {
  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function () {
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

Request.requestsCount = 0;
Request.requests = {};

if (global.document) {
  if (global.attachEvent) {
    global.attachEvent('onunload', unloadHandler);
  } else if (global.addEventListener) {
    global.addEventListener('beforeunload', unloadHandler, false);
  }
}

function unloadHandler () {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/polling.js":
/*!*****************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/polling.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var Transport = __webpack_require__(/*! ../transport */ "./node_modules/engine.io-client/lib/transport.js");
var parseqs = __webpack_require__(/*! parseqs */ "./node_modules/parseqs/index.js");
var parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/lib/browser.js");
var inherit = __webpack_require__(/*! component-inherit */ "./node_modules/component-inherit/index.js");
var yeast = __webpack_require__(/*! yeast */ "./node_modules/yeast/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/engine.io-client/node_modules/debug/src/browser.js")('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function () {
  var XMLHttpRequest = __webpack_require__(/*! xmlhttprequest-ssl */ "./node_modules/engine.io-client/lib/xmlhttprequest.js");
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function () {
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function (onPause) {
  var self = this;

  this.readyState = 'pausing';

  function pause () {
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function () {
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function () {
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function () {
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function (data) {
  var self = this;
  debug('polling got data %s', data);
  var callback = function (packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' === self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' === packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' !== this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' === this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function () {
  var self = this;

  function close () {
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' === this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function (packets) {
  var self = this;
  this.writable = false;
  var callbackfn = function () {
    self.writable = true;
    self.emit('drain');
  };

  parser.encodePayload(packets, this.supportsBinary, function (data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' === schema && Number(this.port) !== 443) ||
     ('http' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};


/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/websocket.js":
/*!*******************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/websocket.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Module dependencies.
 */

var Transport = __webpack_require__(/*! ../transport */ "./node_modules/engine.io-client/lib/transport.js");
var parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/lib/browser.js");
var parseqs = __webpack_require__(/*! parseqs */ "./node_modules/parseqs/index.js");
var inherit = __webpack_require__(/*! component-inherit */ "./node_modules/component-inherit/index.js");
var yeast = __webpack_require__(/*! yeast */ "./node_modules/yeast/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/engine.io-client/node_modules/debug/src/browser.js")('engine.io-client:websocket');
var BrowserWebSocket = global.WebSocket || global.MozWebSocket;
var NodeWebSocket;
if (typeof window === 'undefined') {
  try {
    NodeWebSocket = __webpack_require__(/*! ws */ 0);
  } catch (e) { }
}

/**
 * Get either the `WebSocket` or `MozWebSocket` globals
 * in the browser or try to resolve WebSocket-compatible
 * interface exposed by `ws` for Node-like environment.
 */

var WebSocket = BrowserWebSocket;
if (!WebSocket && typeof window === 'undefined') {
  WebSocket = NodeWebSocket;
}

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  this.perMessageDeflate = opts.perMessageDeflate;
  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
  this.protocols = opts.protocols;
  if (!this.usingBrowserWebSocket) {
    WebSocket = NodeWebSocket;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function () {
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var uri = this.uri();
  var protocols = this.protocols;
  var opts = {
    agent: this.agent,
    perMessageDeflate: this.perMessageDeflate
  };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  if (this.extraHeaders) {
    opts.headers = this.extraHeaders;
  }
  if (this.localAddress) {
    opts.localAddress = this.localAddress;
  }

  try {
    this.ws = this.usingBrowserWebSocket ? (protocols ? new WebSocket(uri, protocols) : new WebSocket(uri)) : new WebSocket(uri, protocols, opts);
  } catch (err) {
    return this.emit('error', err);
  }

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  if (this.ws.supports && this.ws.supports.binary) {
    this.supportsBinary = true;
    this.ws.binaryType = 'nodebuffer';
  } else {
    this.ws.binaryType = 'arraybuffer';
  }

  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function () {
  var self = this;

  this.ws.onopen = function () {
    self.onOpen();
  };
  this.ws.onclose = function () {
    self.onClose();
  };
  this.ws.onmessage = function (ev) {
    self.onData(ev.data);
  };
  this.ws.onerror = function (e) {
    self.onError('websocket error', e);
  };
};

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function (packets) {
  var self = this;
  this.writable = false;

  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  var total = packets.length;
  for (var i = 0, l = total; i < l; i++) {
    (function (packet) {
      parser.encodePacket(packet, self.supportsBinary, function (data) {
        if (!self.usingBrowserWebSocket) {
          // always create a new object (GH-437)
          var opts = {};
          if (packet.options) {
            opts.compress = packet.options.compress;
          }

          if (self.perMessageDeflate) {
            var len = 'string' === typeof data ? global.Buffer.byteLength(data) : data.length;
            if (len < self.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }

        // Sometimes the websocket has already been closed but the browser didn't
        // have a chance of informing us about it yet, in that case send will
        // throw an error
        try {
          if (self.usingBrowserWebSocket) {
            // TypeError is thrown when passing the second argument on Safari
            self.ws.send(data);
          } else {
            self.ws.send(data, opts);
          }
        } catch (e) {
          debug('websocket closed before onclose event');
        }

        --total || done();
      });
    })(packets[i]);
  }

  function done () {
    self.emit('flush');

    // fake drain
    // defer to next tick to allow Socket to clear writeBuffer
    setTimeout(function () {
      self.writable = true;
      self.emit('drain');
    }, 0);
  }
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function () {
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function () {
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' === schema && Number(this.port) !== 443) ||
    ('ws' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function () {
  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/engine.io-client/lib/xmlhttprequest.js":
/*!*************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/xmlhttprequest.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// browser shim for xmlhttprequest module

var hasCORS = __webpack_require__(/*! has-cors */ "./node_modules/has-cors/index.js");

module.exports = function (opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new global[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
    } catch (e) { }
  }
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/engine.io-client/node_modules/debug/src/browser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/engine.io-client/node_modules/debug/src/browser.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(/*! ./debug */ "./node_modules/engine.io-client/node_modules/debug/src/debug.js");
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/engine.io-client/node_modules/debug/src/debug.js":
/*!***********************************************************************!*\
  !*** ./node_modules/engine.io-client/node_modules/debug/src/debug.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(/*! ms */ "./node_modules/ms/index.js");

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),

/***/ "./node_modules/engine.io-parser/lib/browser.js":
/*!******************************************************!*\
  !*** ./node_modules/engine.io-parser/lib/browser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var keys = __webpack_require__(/*! ./keys */ "./node_modules/engine.io-parser/lib/keys.js");
var hasBinary = __webpack_require__(/*! has-binary2 */ "./node_modules/has-binary2/index.js");
var sliceBuffer = __webpack_require__(/*! arraybuffer.slice */ "./node_modules/arraybuffer.slice/index.js");
var after = __webpack_require__(/*! after */ "./node_modules/after/index.js");
var utf8 = __webpack_require__(/*! ./utf8 */ "./node_modules/engine.io-parser/lib/utf8.js");

var base64encoder;
if (typeof ArrayBuffer !== 'undefined') {
  base64encoder = __webpack_require__(/*! base64-arraybuffer */ "./node_modules/base64-arraybuffer/lib/base64-arraybuffer.js");
}

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = __webpack_require__(/*! blob */ "./node_modules/blob/index.js");

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if (typeof utf8encode === 'function') {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (typeof Blob !== 'undefined' && data instanceof Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);
  }

  return callback('' + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    exports.encodePacket({ type: packet.type, data: fr.result }, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (typeof Blob !== 'undefined' && packet.data instanceof Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  if (data === undefined) {
    return err;
  }
  // String data
  if (typeof data === 'string') {
    if (data.charAt(0) === 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      data = tryDecode(data);
      if (data === false) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

function tryDecode(data) {
  try {
    data = utf8.decode(data, { strict: false });
  } catch (e) {
    return false;
  }
  return data;
}

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!base64encoder) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary && isBinary) {
    if (Blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data !== 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data === '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = '', n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (chr !== ':') {
      length += chr;
      continue;
    }

    if (length === '' || (length != (n = Number(length)))) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    msg = data.substr(i + 1, n);

    if (length != msg.length) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    if (msg.length) {
      packet = exports.decodePacket(msg, binaryType, false);

      if (err.type === packet.type && err.data === packet.data) {
        // parser error in individual packet - ignoring payload
        return callback(err, 0, 1);
      }

      var ret = callback(packet, i + n, l);
      if (false === ret) return;
    }

    // advance cursor
    i += n;
    length = '';
  }

  if (length !== '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] === 255) break;

      // 310 = char length of Number.MAX_VALUE
      if (msgLength.length > 310) {
        return callback(err, 0, 1);
      }

      msgLength += tailArray[i];
    }

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};


/***/ }),

/***/ "./node_modules/engine.io-parser/lib/keys.js":
/*!***************************************************!*\
  !*** ./node_modules/engine.io-parser/lib/keys.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};


/***/ }),

/***/ "./node_modules/engine.io-parser/lib/utf8.js":
/*!***************************************************!*\
  !*** ./node_modules/engine.io-parser/lib/utf8.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*! https://mths.be/utf8js v2.1.2 by @mathias */

var stringFromCharCode = String.fromCharCode;

// Taken from https://mths.be/punycode
function ucs2decode(string) {
	var output = [];
	var counter = 0;
	var length = string.length;
	var value;
	var extra;
	while (counter < length) {
		value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// high surrogate, and there is a next character
			extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) { // low surrogate
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// unmatched surrogate; only append this code unit, in case the next
				// code unit is the high surrogate of a surrogate pair
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

// Taken from https://mths.be/punycode
function ucs2encode(array) {
	var length = array.length;
	var index = -1;
	var value;
	var output = '';
	while (++index < length) {
		value = array[index];
		if (value > 0xFFFF) {
			value -= 0x10000;
			output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
			value = 0xDC00 | value & 0x3FF;
		}
		output += stringFromCharCode(value);
	}
	return output;
}

function checkScalarValue(codePoint, strict) {
	if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
		if (strict) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
		return false;
	}
	return true;
}
/*--------------------------------------------------------------------------*/

function createByte(codePoint, shift) {
	return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
}

function encodeCodePoint(codePoint, strict) {
	if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
		return stringFromCharCode(codePoint);
	}
	var symbol = '';
	if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
		symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
	}
	else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
		if (!checkScalarValue(codePoint, strict)) {
			codePoint = 0xFFFD;
		}
		symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
		symbol += createByte(codePoint, 6);
	}
	else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
		symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
		symbol += createByte(codePoint, 12);
		symbol += createByte(codePoint, 6);
	}
	symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
	return symbol;
}

function utf8encode(string, opts) {
	opts = opts || {};
	var strict = false !== opts.strict;

	var codePoints = ucs2decode(string);
	var length = codePoints.length;
	var index = -1;
	var codePoint;
	var byteString = '';
	while (++index < length) {
		codePoint = codePoints[index];
		byteString += encodeCodePoint(codePoint, strict);
	}
	return byteString;
}

/*--------------------------------------------------------------------------*/

function readContinuationByte() {
	if (byteIndex >= byteCount) {
		throw Error('Invalid byte index');
	}

	var continuationByte = byteArray[byteIndex] & 0xFF;
	byteIndex++;

	if ((continuationByte & 0xC0) == 0x80) {
		return continuationByte & 0x3F;
	}

	// If we end up here, it’s not a continuation byte
	throw Error('Invalid continuation byte');
}

function decodeSymbol(strict) {
	var byte1;
	var byte2;
	var byte3;
	var byte4;
	var codePoint;

	if (byteIndex > byteCount) {
		throw Error('Invalid byte index');
	}

	if (byteIndex == byteCount) {
		return false;
	}

	// Read first byte
	byte1 = byteArray[byteIndex] & 0xFF;
	byteIndex++;

	// 1-byte sequence (no continuation bytes)
	if ((byte1 & 0x80) == 0) {
		return byte1;
	}

	// 2-byte sequence
	if ((byte1 & 0xE0) == 0xC0) {
		byte2 = readContinuationByte();
		codePoint = ((byte1 & 0x1F) << 6) | byte2;
		if (codePoint >= 0x80) {
			return codePoint;
		} else {
			throw Error('Invalid continuation byte');
		}
	}

	// 3-byte sequence (may include unpaired surrogates)
	if ((byte1 & 0xF0) == 0xE0) {
		byte2 = readContinuationByte();
		byte3 = readContinuationByte();
		codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
		if (codePoint >= 0x0800) {
			return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
		} else {
			throw Error('Invalid continuation byte');
		}
	}

	// 4-byte sequence
	if ((byte1 & 0xF8) == 0xF0) {
		byte2 = readContinuationByte();
		byte3 = readContinuationByte();
		byte4 = readContinuationByte();
		codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
			(byte3 << 0x06) | byte4;
		if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
			return codePoint;
		}
	}

	throw Error('Invalid UTF-8 detected');
}

var byteArray;
var byteCount;
var byteIndex;
function utf8decode(byteString, opts) {
	opts = opts || {};
	var strict = false !== opts.strict;

	byteArray = ucs2decode(byteString);
	byteCount = byteArray.length;
	byteIndex = 0;
	var codePoints = [];
	var tmp;
	while ((tmp = decodeSymbol(strict)) !== false) {
		codePoints.push(tmp);
	}
	return ucs2encode(codePoints);
}

module.exports = {
	version: '2.1.2',
	encode: utf8encode,
	decode: utf8decode
};


/***/ }),

/***/ "./node_modules/has-binary2/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-binary2/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/* global Blob File */

/*
 * Module requirements.
 */

var isArray = __webpack_require__(/*! isarray */ "./node_modules/has-binary2/node_modules/isarray/index.js");

var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === 'function' ||
                        typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]';
var withNativeFile = typeof File === 'function' ||
                        typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]';

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Supports Buffer, ArrayBuffer, Blob and File.
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary (obj) {
  if (!obj || typeof obj !== 'object') {
    return false;
  }

  if (isArray(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }
    return false;
  }

  if ((typeof Buffer === 'function' && Buffer.isBuffer && Buffer.isBuffer(obj)) ||
    (typeof ArrayBuffer === 'function' && obj instanceof ArrayBuffer) ||
    (withNativeBlob && obj instanceof Blob) ||
    (withNativeFile && obj instanceof File)
  ) {
    return true;
  }

  // see: https://github.com/Automattic/has-binary/pull/4
  if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }

  return false;
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/has-binary2/node_modules/isarray/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/has-binary2/node_modules/isarray/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/has-cors/index.js":
/*!****************************************!*\
  !*** ./node_modules/has-cors/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = typeof XMLHttpRequest !== 'undefined' &&
    'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/indexof/index.js":
/*!***************************************!*\
  !*** ./node_modules/indexof/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {


var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),

/***/ "./node_modules/parseqs/index.js":
/*!***************************************!*\
  !*** ./node_modules/parseqs/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};


/***/ }),

/***/ "./node_modules/parseuri/index.js":
/*!****************************************!*\
  !*** ./node_modules/parseuri/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/socket.io-client/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/socket.io-client/lib/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var url = __webpack_require__(/*! ./url */ "./node_modules/socket.io-client/lib/url.js");
var parser = __webpack_require__(/*! socket.io-parser */ "./node_modules/socket.io-parser/index.js");
var Manager = __webpack_require__(/*! ./manager */ "./node_modules/socket.io-client/lib/manager.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/socket.io-client/node_modules/debug/src/browser.js")('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup (uri, opts) {
  if (typeof uri === 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var path = parsed.path;
  var sameNamespace = cache[id] && path in cache[id].nsps;
  var newConnection = opts.forceNew || opts['force new connection'] ||
                      false === opts.multiplex || sameNamespace;

  var io;

  if (newConnection) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.query;
  }
  return io.socket(parsed.path, opts);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = __webpack_require__(/*! ./manager */ "./node_modules/socket.io-client/lib/manager.js");
exports.Socket = __webpack_require__(/*! ./socket */ "./node_modules/socket.io-client/lib/socket.js");


/***/ }),

/***/ "./node_modules/socket.io-client/lib/manager.js":
/*!******************************************************!*\
  !*** ./node_modules/socket.io-client/lib/manager.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var eio = __webpack_require__(/*! engine.io-client */ "./node_modules/engine.io-client/lib/index.js");
var Socket = __webpack_require__(/*! ./socket */ "./node_modules/socket.io-client/lib/socket.js");
var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/component-emitter/index.js");
var parser = __webpack_require__(/*! socket.io-parser */ "./node_modules/socket.io-parser/index.js");
var on = __webpack_require__(/*! ./on */ "./node_modules/socket.io-client/lib/on.js");
var bind = __webpack_require__(/*! component-bind */ "./node_modules/component-bind/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/socket.io-client/node_modules/debug/src/browser.js")('socket.io-client:manager');
var indexOf = __webpack_require__(/*! indexof */ "./node_modules/indexof/index.js");
var Backoff = __webpack_require__(/*! backo2 */ "./node_modules/backo2/index.js");

/**
 * IE6+ hasOwnProperty
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager (uri, opts) {
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' === typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connecting = [];
  this.lastPing = null;
  this.encoding = false;
  this.packetBuffer = [];
  var _parser = opts.parser || parser;
  this.encoder = new _parser.Encoder();
  this.decoder = new _parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function () {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
    }
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function () {
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].id = this.generateId(nsp);
    }
  }
};

/**
 * generate `socket.id` for the given `nsp`
 *
 * @param {String} nsp
 * @return {String}
 * @api private
 */

Manager.prototype.generateId = function (nsp) {
  return (nsp === '/' ? '' : (nsp + '#')) + this.engine.id;
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function (v) {
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function (v) {
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function (v) {
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function (v) {
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function (v) {
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function (v) {
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function () {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};

/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function (fn, opts) {
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function () {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function (data) {
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function () {
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function () {
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
};

/**
 * Called upon a ping.
 *
 * @api private
 */

Manager.prototype.onping = function () {
  this.lastPing = new Date();
  this.emitAll('ping');
};

/**
 * Called upon a packet.
 *
 * @api private
 */

Manager.prototype.onpong = function () {
  this.emitAll('pong', new Date() - this.lastPing);
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function (data) {
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function (err) {
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function (nsp, opts) {
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp, opts);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connecting', onConnecting);
    socket.on('connect', function () {
      socket.id = self.generateId(nsp);
    });

    if (this.autoConnect) {
      // manually call here since connecting event is fired before listening
      onConnecting();
    }
  }

  function onConnecting () {
    if (!~indexOf(self.connecting, socket)) {
      self.connecting.push(socket);
    }
  }

  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function (socket) {
  var index = indexOf(this.connecting, socket);
  if (~index) this.connecting.splice(index, 1);
  if (this.connecting.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function (packet) {
  debug('writing packet %j', packet);
  var self = this;
  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function (encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i], packet.options);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function () {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function () {
  debug('cleanup');

  var subsLength = this.subs.length;
  for (var i = 0; i < subsLength; i++) {
    var sub = this.subs.shift();
    sub.destroy();
  }

  this.packetBuffer = [];
  this.encoding = false;
  this.lastPing = null;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function () {
  debug('disconnect');
  this.skipReconnect = true;
  this.reconnecting = false;
  if ('opening' === this.readyState) {
    // `onclose` will not fire because
    // an open event never happened
    this.cleanup();
  }
  this.backoff.reset();
  this.readyState = 'closed';
  if (this.engine) this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function (reason) {
  debug('onclose');

  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);

  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function () {
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function () {
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function (err) {
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function () {
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};


/***/ }),

/***/ "./node_modules/socket.io-client/lib/on.js":
/*!*************************************************!*\
  !*** ./node_modules/socket.io-client/lib/on.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on (obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function () {
      obj.removeListener(ev, fn);
    }
  };
}


/***/ }),

/***/ "./node_modules/socket.io-client/lib/socket.js":
/*!*****************************************************!*\
  !*** ./node_modules/socket.io-client/lib/socket.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var parser = __webpack_require__(/*! socket.io-parser */ "./node_modules/socket.io-parser/index.js");
var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/component-emitter/index.js");
var toArray = __webpack_require__(/*! to-array */ "./node_modules/to-array/index.js");
var on = __webpack_require__(/*! ./on */ "./node_modules/socket.io-client/lib/on.js");
var bind = __webpack_require__(/*! component-bind */ "./node_modules/component-bind/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/socket.io-client/node_modules/debug/src/browser.js")('socket.io-client:socket');
var parseqs = __webpack_require__(/*! parseqs */ "./node_modules/parseqs/index.js");
var hasBin = __webpack_require__(/*! has-binary2 */ "./node_modules/has-binary2/index.js");

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  connecting: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1,
  ping: 1,
  pong: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket (io, nsp, opts) {
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
  this.flags = {};
  if (opts && opts.query) {
    this.query = opts.query;
  }
  if (this.io.autoConnect) this.open();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function () {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function () {
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if ('open' === this.io.readyState) this.onopen();
  this.emit('connecting');
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function () {
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function (ev) {
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var packet = {
    type: (this.flags.binary !== undefined ? this.flags.binary : hasBin(args)) ? parser.BINARY_EVENT : parser.EVENT,
    data: args
  };

  packet.options = {};
  packet.options.compress = !this.flags || false !== this.flags.compress;

  // event ack callback
  if ('function' === typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  this.flags = {};

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function (packet) {
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function () {
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' !== this.nsp) {
    if (this.query) {
      var query = typeof this.query === 'object' ? parseqs.encode(this.query) : this.query;
      debug('sending connect packet with query %s', query);
      this.packet({type: parser.CONNECT, query: query});
    } else {
      this.packet({type: parser.CONNECT});
    }
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function (reason) {
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function (packet) {
  var sameNamespace = packet.nsp === this.nsp;
  var rootNamespaceError = packet.type === parser.ERROR && packet.nsp === '/';

  if (!sameNamespace && !rootNamespaceError) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function (packet) {
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function (id) {
  var self = this;
  var sent = false;
  return function () {
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    self.packet({
      type: hasBin(args) ? parser.BINARY_ACK : parser.ACK,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function (packet) {
  var ack = this.acks[packet.id];
  if ('function' === typeof ack) {
    debug('calling ack %s with %j', packet.id, packet.data);
    ack.apply(this, packet.data);
    delete this.acks[packet.id];
  } else {
    debug('bad ack %s', packet.id);
  }
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function () {
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function () {
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function () {
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function () {
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function () {
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

/**
 * Sets the compress flag.
 *
 * @param {Boolean} if `true`, compresses the sending data
 * @return {Socket} self
 * @api public
 */

Socket.prototype.compress = function (compress) {
  this.flags.compress = compress;
  return this;
};

/**
 * Sets the binary flag
 *
 * @param {Boolean} whether the emitted data contains binary
 * @return {Socket} self
 * @api public
 */

Socket.prototype.binary = function (binary) {
  this.flags.binary = binary;
  return this;
};


/***/ }),

/***/ "./node_modules/socket.io-client/lib/url.js":
/*!**************************************************!*\
  !*** ./node_modules/socket.io-client/lib/url.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/**
 * Module dependencies.
 */

var parseuri = __webpack_require__(/*! parseuri */ "./node_modules/parseuri/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/socket.io-client/node_modules/debug/src/browser.js")('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url (uri, loc) {
  var obj = uri;

  // default to window.location
  loc = loc || global.location;
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' === typeof uri) {
    if ('/' === uri.charAt(0)) {
      if ('/' === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' !== typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  var ipv6 = obj.host.indexOf(':') !== -1;
  var host = ipv6 ? '[' + obj.host + ']' : obj.host;

  // define unique id
  obj.id = obj.protocol + '://' + host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : (':' + obj.port));

  return obj;
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/debug/src/browser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/socket.io-client/node_modules/debug/src/browser.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(/*! ./debug */ "./node_modules/socket.io-client/node_modules/debug/src/debug.js");
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/debug/src/debug.js":
/*!***********************************************************************!*\
  !*** ./node_modules/socket.io-client/node_modules/debug/src/debug.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(/*! ms */ "./node_modules/ms/index.js");

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),

/***/ "./node_modules/socket.io-parser/binary.js":
/*!*************************************************!*\
  !*** ./node_modules/socket.io-parser/binary.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = __webpack_require__(/*! isarray */ "./node_modules/socket.io-parser/node_modules/isarray/index.js");
var isBuf = __webpack_require__(/*! ./is-buffer */ "./node_modules/socket.io-parser/is-buffer.js");
var toString = Object.prototype.toString;
var withNativeBlob = typeof global.Blob === 'function' || toString.call(global.Blob) === '[object BlobConstructor]';
var withNativeFile = typeof global.File === 'function' || toString.call(global.File) === '[object FileConstructor]';

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet) {
  var buffers = [];
  var packetData = packet.data;
  var pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

function _deconstructPacket(data, buffers) {
  if (!data) return data;

  if (isBuf(data)) {
    var placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (isArray(data)) {
    var newData = new Array(data.length);
    for (var i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }
    return newData;
  } else if (typeof data === 'object' && !(data instanceof Date)) {
    var newData = {};
    for (var key in data) {
      newData[key] = _deconstructPacket(data[key], buffers);
    }
    return newData;
  }
  return data;
}

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  packet.attachments = undefined; // no longer useful
  return packet;
};

function _reconstructPacket(data, buffers) {
  if (!data) return data;

  if (data && data._placeholder) {
    return buffers[data.num]; // appropriate buffer (should be natural order anyway)
  } else if (isArray(data)) {
    for (var i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (typeof data === 'object') {
    for (var key in data) {
      data[key] = _reconstructPacket(data[key], buffers);
    }
  }

  return data;
}

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((withNativeBlob && obj instanceof Blob) ||
        (withNativeFile && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (typeof obj === 'object' && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/socket.io-parser/index.js":
/*!************************************************!*\
  !*** ./node_modules/socket.io-parser/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var debug = __webpack_require__(/*! debug */ "./node_modules/socket.io-parser/node_modules/debug/src/browser.js")('socket.io-parser');
var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/component-emitter/index.js");
var binary = __webpack_require__(/*! ./binary */ "./node_modules/socket.io-parser/binary.js");
var isArray = __webpack_require__(/*! isarray */ "./node_modules/socket.io-parser/node_modules/isarray/index.js");
var isBuf = __webpack_require__(/*! ./is-buffer */ "./node_modules/socket.io-parser/is-buffer.js");

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'ACK',
  'ERROR',
  'BINARY_EVENT',
  'BINARY_ACK'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

var ERROR_PACKET = exports.ERROR + '"encode error"';

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    encodeAsBinary(obj, callback);
  } else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {

  // first is type
  var str = '' + obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    str += obj.attachments + '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' !== obj.nsp) {
    str += obj.nsp + ',';
  }

  // immediately followed by the id
  if (null != obj.id) {
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    var payload = tryStringify(obj.data);
    if (payload !== false) {
      str += payload;
    } else {
      return ERROR_PACKET;
    }
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

function tryStringify(str) {
  try {
    return JSON.stringify(str);
  } catch(e){
    return false;
  }
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an ecoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if (typeof obj === 'string') {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  }
  else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  }
  else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var i = 0;
  // look up type
  var p = {
    type: Number(str.charAt(0))
  };

  if (null == exports.types[p.type]) {
    return error('unknown packet type ' + p.type);
  }

  // look up attachments if type binary
  if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {
    var buf = '';
    while (str.charAt(++i) !== '-') {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) !== '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' === str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' === c) break;
      p.nsp += c;
      if (i === str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i === str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    var payload = tryParse(str.substr(i));
    var isPayloadValid = payload !== false && (p.type === exports.ERROR || isArray(payload));
    if (isPayloadValid) {
      p.data = payload;
    } else {
      return error('invalid payload');
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
}

function tryParse(str) {
  try {
    return JSON.parse(str);
  } catch(e){
    return false;
  }
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length === this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(msg) {
  return {
    type: exports.ERROR,
    data: 'parser error: ' + msg
  };
}


/***/ }),

/***/ "./node_modules/socket.io-parser/is-buffer.js":
/*!****************************************************!*\
  !*** ./node_modules/socket.io-parser/is-buffer.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
module.exports = isBuf;

var withNativeBuffer = typeof global.Buffer === 'function' && typeof global.Buffer.isBuffer === 'function';
var withNativeArrayBuffer = typeof global.ArrayBuffer === 'function';

var isView = (function () {
  if (withNativeArrayBuffer && typeof global.ArrayBuffer.isView === 'function') {
    return global.ArrayBuffer.isView;
  } else {
    return function (obj) { return obj.buffer instanceof global.ArrayBuffer; };
  }
})();

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (withNativeBuffer && global.Buffer.isBuffer(obj)) ||
          (withNativeArrayBuffer && (obj instanceof global.ArrayBuffer || isView(obj)));
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/socket.io-parser/node_modules/debug/src/browser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/socket.io-parser/node_modules/debug/src/browser.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(/*! ./debug */ "./node_modules/socket.io-parser/node_modules/debug/src/debug.js");
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/socket.io-parser/node_modules/debug/src/debug.js":
/*!***********************************************************************!*\
  !*** ./node_modules/socket.io-parser/node_modules/debug/src/debug.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(/*! ms */ "./node_modules/ms/index.js");

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),

/***/ "./node_modules/socket.io-parser/node_modules/isarray/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/socket.io-parser/node_modules/isarray/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/to-array/index.js":
/*!****************************************!*\
  !*** ./node_modules/to-array/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/xterm/lib/AccessibilityManager.js":
/*!********************************************************!*\
  !*** ./node_modules/xterm/lib/AccessibilityManager.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Strings = __webpack_require__(/*! ./Strings */ "./node_modules/xterm/lib/Strings.js");
var Browser_1 = __webpack_require__(/*! ./shared/utils/Browser */ "./node_modules/xterm/lib/shared/utils/Browser.js");
var RenderDebouncer_1 = __webpack_require__(/*! ./ui/RenderDebouncer */ "./node_modules/xterm/lib/ui/RenderDebouncer.js");
var Lifecycle_1 = __webpack_require__(/*! ./ui/Lifecycle */ "./node_modules/xterm/lib/ui/Lifecycle.js");
var Lifecycle_2 = __webpack_require__(/*! ./common/Lifecycle */ "./node_modules/xterm/lib/common/Lifecycle.js");
var MAX_ROWS_TO_READ = 20;
var AccessibilityManager = (function (_super) {
    __extends(AccessibilityManager, _super);
    function AccessibilityManager(_terminal) {
        var _this = _super.call(this) || this;
        _this._terminal = _terminal;
        _this._liveRegionLineCount = 0;
        _this._charsToConsume = [];
        _this._accessibilityTreeRoot = document.createElement('div');
        _this._accessibilityTreeRoot.classList.add('xterm-accessibility');
        _this._rowContainer = document.createElement('div');
        _this._rowContainer.classList.add('xterm-accessibility-tree');
        _this._rowElements = [];
        for (var i = 0; i < _this._terminal.rows; i++) {
            _this._rowElements[i] = _this._createAccessibilityTreeNode();
            _this._rowContainer.appendChild(_this._rowElements[i]);
        }
        _this._topBoundaryFocusListener = function (e) { return _this._onBoundaryFocus(e, 0); };
        _this._bottomBoundaryFocusListener = function (e) { return _this._onBoundaryFocus(e, 1); };
        _this._rowElements[0].addEventListener('focus', _this._topBoundaryFocusListener);
        _this._rowElements[_this._rowElements.length - 1].addEventListener('focus', _this._bottomBoundaryFocusListener);
        _this._refreshRowsDimensions();
        _this._accessibilityTreeRoot.appendChild(_this._rowContainer);
        _this._renderRowsDebouncer = new RenderDebouncer_1.RenderDebouncer(_this._terminal, _this._renderRows.bind(_this));
        _this._refreshRows();
        _this._liveRegion = document.createElement('div');
        _this._liveRegion.classList.add('live-region');
        _this._liveRegion.setAttribute('aria-live', 'assertive');
        _this._accessibilityTreeRoot.appendChild(_this._liveRegion);
        _this._terminal.element.insertAdjacentElement('afterbegin', _this._accessibilityTreeRoot);
        _this.register(_this._renderRowsDebouncer);
        _this.register(_this._terminal.addDisposableListener('resize', function (data) { return _this._onResize(data.rows); }));
        _this.register(_this._terminal.addDisposableListener('refresh', function (data) { return _this._refreshRows(data.start, data.end); }));
        _this.register(_this._terminal.addDisposableListener('scroll', function (data) { return _this._refreshRows(); }));
        _this.register(_this._terminal.addDisposableListener('a11y.char', function (char) { return _this._onChar(char); }));
        _this.register(_this._terminal.addDisposableListener('linefeed', function () { return _this._onChar('\n'); }));
        _this.register(_this._terminal.addDisposableListener('a11y.tab', function (spaceCount) { return _this._onTab(spaceCount); }));
        _this.register(_this._terminal.addDisposableListener('key', function (keyChar) { return _this._onKey(keyChar); }));
        _this.register(_this._terminal.addDisposableListener('blur', function () { return _this._clearLiveRegion(); }));
        _this.register(_this._terminal.addDisposableListener('dprchange', function () { return _this._refreshRowsDimensions(); }));
        _this.register(_this._terminal.renderer.addDisposableListener('resize', function () { return _this._refreshRowsDimensions(); }));
        _this.register(Lifecycle_1.addDisposableDomListener(window, 'resize', function () { return _this._refreshRowsDimensions(); }));
        return _this;
    }
    AccessibilityManager.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._terminal.element.removeChild(this._accessibilityTreeRoot);
        this._rowElements.length = 0;
    };
    AccessibilityManager.prototype._onBoundaryFocus = function (e, position) {
        var boundaryElement = e.target;
        var beforeBoundaryElement = this._rowElements[position === 0 ? 1 : this._rowElements.length - 2];
        var posInSet = boundaryElement.getAttribute('aria-posinset');
        var lastRowPos = position === 0 ? '1' : "" + this._terminal.buffer.lines.length;
        if (posInSet === lastRowPos) {
            return;
        }
        if (e.relatedTarget !== beforeBoundaryElement) {
            return;
        }
        var topBoundaryElement;
        var bottomBoundaryElement;
        if (position === 0) {
            topBoundaryElement = boundaryElement;
            bottomBoundaryElement = this._rowElements.pop();
            this._rowContainer.removeChild(bottomBoundaryElement);
        }
        else {
            topBoundaryElement = this._rowElements.shift();
            bottomBoundaryElement = boundaryElement;
            this._rowContainer.removeChild(topBoundaryElement);
        }
        topBoundaryElement.removeEventListener('focus', this._topBoundaryFocusListener);
        bottomBoundaryElement.removeEventListener('focus', this._bottomBoundaryFocusListener);
        if (position === 0) {
            var newElement = this._createAccessibilityTreeNode();
            this._rowElements.unshift(newElement);
            this._rowContainer.insertAdjacentElement('afterbegin', newElement);
        }
        else {
            var newElement = this._createAccessibilityTreeNode();
            this._rowElements.push(newElement);
            this._rowContainer.appendChild(newElement);
        }
        this._rowElements[0].addEventListener('focus', this._topBoundaryFocusListener);
        this._rowElements[this._rowElements.length - 1].addEventListener('focus', this._bottomBoundaryFocusListener);
        this._terminal.scrollLines(position === 0 ? -1 : 1);
        this._rowElements[position === 0 ? 1 : this._rowElements.length - 2].focus();
        e.preventDefault();
        e.stopImmediatePropagation();
    };
    AccessibilityManager.prototype._onResize = function (rows) {
        this._rowElements[this._rowElements.length - 1].removeEventListener('focus', this._bottomBoundaryFocusListener);
        for (var i = this._rowContainer.children.length; i < this._terminal.rows; i++) {
            this._rowElements[i] = this._createAccessibilityTreeNode();
            this._rowContainer.appendChild(this._rowElements[i]);
        }
        while (this._rowElements.length > rows) {
            this._rowContainer.removeChild(this._rowElements.pop());
        }
        this._rowElements[this._rowElements.length - 1].addEventListener('focus', this._bottomBoundaryFocusListener);
        this._refreshRowsDimensions();
    };
    AccessibilityManager.prototype._createAccessibilityTreeNode = function () {
        var element = document.createElement('div');
        element.setAttribute('role', 'listitem');
        element.tabIndex = -1;
        this._refreshRowDimensions(element);
        return element;
    };
    AccessibilityManager.prototype._onTab = function (spaceCount) {
        for (var i = 0; i < spaceCount; i++) {
            this._onChar(' ');
        }
    };
    AccessibilityManager.prototype._onChar = function (char) {
        var _this = this;
        if (this._liveRegionLineCount < MAX_ROWS_TO_READ + 1) {
            if (this._charsToConsume.length > 0) {
                var shiftedChar = this._charsToConsume.shift();
                if (shiftedChar !== char) {
                    this._announceCharacter(char);
                }
            }
            else {
                this._announceCharacter(char);
            }
            if (char === '\n') {
                this._liveRegionLineCount++;
                if (this._liveRegionLineCount === MAX_ROWS_TO_READ + 1) {
                    this._liveRegion.textContent += Strings.tooMuchOutput;
                }
            }
            if (Browser_1.isMac) {
                if (this._liveRegion.textContent && this._liveRegion.textContent.length > 0 && !this._liveRegion.parentNode) {
                    setTimeout(function () {
                        _this._accessibilityTreeRoot.appendChild(_this._liveRegion);
                    }, 0);
                }
            }
        }
    };
    AccessibilityManager.prototype._clearLiveRegion = function () {
        this._liveRegion.textContent = '';
        this._liveRegionLineCount = 0;
        if (Browser_1.isMac) {
            if (this._liveRegion.parentNode) {
                this._accessibilityTreeRoot.removeChild(this._liveRegion);
            }
        }
    };
    AccessibilityManager.prototype._onKey = function (keyChar) {
        this._clearLiveRegion();
        this._charsToConsume.push(keyChar);
    };
    AccessibilityManager.prototype._refreshRows = function (start, end) {
        this._renderRowsDebouncer.refresh(start, end);
    };
    AccessibilityManager.prototype._renderRows = function (start, end) {
        var buffer = this._terminal.buffer;
        var setSize = buffer.lines.length.toString();
        for (var i = start; i <= end; i++) {
            var lineData = buffer.translateBufferLineToString(buffer.ydisp + i, true);
            var posInSet = (buffer.ydisp + i + 1).toString();
            var element = this._rowElements[i];
            element.textContent = lineData.length === 0 ? Strings.blankLine : lineData;
            element.setAttribute('aria-posinset', posInSet);
            element.setAttribute('aria-setsize', setSize);
        }
    };
    AccessibilityManager.prototype._refreshRowsDimensions = function () {
        if (!this._terminal.renderer.dimensions.actualCellHeight) {
            return;
        }
        if (this._rowElements.length !== this._terminal.rows) {
            this._onResize(this._terminal.rows);
        }
        for (var i = 0; i < this._terminal.rows; i++) {
            this._refreshRowDimensions(this._rowElements[i]);
        }
    };
    AccessibilityManager.prototype._refreshRowDimensions = function (element) {
        element.style.height = this._terminal.renderer.dimensions.actualCellHeight + "px";
    };
    AccessibilityManager.prototype._announceCharacter = function (char) {
        if (char === ' ') {
            this._liveRegion.innerHTML += '&nbsp;';
        }
        else {
            this._liveRegion.textContent += char;
        }
    };
    return AccessibilityManager;
}(Lifecycle_2.Disposable));
exports.AccessibilityManager = AccessibilityManager;
//# sourceMappingURL=AccessibilityManager.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/Buffer.js":
/*!******************************************!*\
  !*** ./node_modules/xterm/lib/Buffer.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var CircularList_1 = __webpack_require__(/*! ./common/CircularList */ "./node_modules/xterm/lib/common/CircularList.js");
var EventEmitter_1 = __webpack_require__(/*! ./common/EventEmitter */ "./node_modules/xterm/lib/common/EventEmitter.js");
var BufferLine_1 = __webpack_require__(/*! ./BufferLine */ "./node_modules/xterm/lib/BufferLine.js");
exports.DEFAULT_ATTR = (0 << 18) | (257 << 9) | (256 << 0);
exports.CHAR_DATA_ATTR_INDEX = 0;
exports.CHAR_DATA_CHAR_INDEX = 1;
exports.CHAR_DATA_WIDTH_INDEX = 2;
exports.CHAR_DATA_CODE_INDEX = 3;
exports.MAX_BUFFER_SIZE = 4294967295;
exports.NULL_CELL_CHAR = ' ';
exports.NULL_CELL_WIDTH = 1;
exports.NULL_CELL_CODE = 32;
var Buffer = (function () {
    function Buffer(_terminal, _hasScrollback) {
        this._terminal = _terminal;
        this._hasScrollback = _hasScrollback;
        this.markers = [];
        this.clear();
    }
    Object.defineProperty(Buffer.prototype, "hasScrollback", {
        get: function () {
            return this._hasScrollback && this.lines.maxLength > this._terminal.rows;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Buffer.prototype, "isCursorInViewport", {
        get: function () {
            var absoluteY = this.ybase + this.y;
            var relativeY = absoluteY - this.ydisp;
            return (relativeY >= 0 && relativeY < this._terminal.rows);
        },
        enumerable: true,
        configurable: true
    });
    Buffer.prototype._getCorrectBufferLength = function (rows) {
        if (!this._hasScrollback) {
            return rows;
        }
        var correctBufferLength = rows + this._terminal.options.scrollback;
        return correctBufferLength > exports.MAX_BUFFER_SIZE ? exports.MAX_BUFFER_SIZE : correctBufferLength;
    };
    Buffer.prototype.fillViewportRows = function () {
        if (this.lines.length === 0) {
            var i = this._terminal.rows;
            while (i--) {
                this.lines.push(BufferLine_1.BufferLine.blankLine(this._terminal.cols, exports.DEFAULT_ATTR));
            }
        }
    };
    Buffer.prototype.clear = function () {
        this.ydisp = 0;
        this.ybase = 0;
        this.y = 0;
        this.x = 0;
        this.lines = new CircularList_1.CircularList(this._getCorrectBufferLength(this._terminal.rows));
        this.scrollTop = 0;
        this.scrollBottom = this._terminal.rows - 1;
        this.setupTabStops();
    };
    Buffer.prototype.resize = function (newCols, newRows) {
        var newMaxLength = this._getCorrectBufferLength(newRows);
        if (newMaxLength > this.lines.maxLength) {
            this.lines.maxLength = newMaxLength;
        }
        if (this.lines.length > 0) {
            if (this._terminal.cols < newCols) {
                var ch = [exports.DEFAULT_ATTR, exports.NULL_CELL_CHAR, exports.NULL_CELL_WIDTH, exports.NULL_CELL_CODE];
                for (var i = 0; i < this.lines.length; i++) {
                    while (this.lines.get(i).length < newCols) {
                        this.lines.get(i).push(ch);
                    }
                }
            }
            var addToY = 0;
            if (this._terminal.rows < newRows) {
                for (var y = this._terminal.rows; y < newRows; y++) {
                    if (this.lines.length < newRows + this.ybase) {
                        if (this.ybase > 0 && this.lines.length <= this.ybase + this.y + addToY + 1) {
                            this.ybase--;
                            addToY++;
                            if (this.ydisp > 0) {
                                this.ydisp--;
                            }
                        }
                        else {
                            this.lines.push(BufferLine_1.BufferLine.blankLine(newCols, exports.DEFAULT_ATTR));
                        }
                    }
                }
            }
            else {
                for (var y = this._terminal.rows; y > newRows; y--) {
                    if (this.lines.length > newRows + this.ybase) {
                        if (this.lines.length > this.ybase + this.y + 1) {
                            this.lines.pop();
                        }
                        else {
                            this.ybase++;
                            this.ydisp++;
                        }
                    }
                }
            }
            if (newMaxLength < this.lines.maxLength) {
                var amountToTrim = this.lines.length - newMaxLength;
                if (amountToTrim > 0) {
                    this.lines.trimStart(amountToTrim);
                    this.ybase = Math.max(this.ybase - amountToTrim, 0);
                    this.ydisp = Math.max(this.ydisp - amountToTrim, 0);
                }
                this.lines.maxLength = newMaxLength;
            }
            this.x = Math.min(this.x, newCols - 1);
            this.y = Math.min(this.y, newRows - 1);
            if (addToY) {
                this.y += addToY;
            }
            this.savedY = Math.min(this.savedY, newRows - 1);
            this.savedX = Math.min(this.savedX, newCols - 1);
            this.scrollTop = 0;
        }
        this.scrollBottom = newRows - 1;
    };
    Buffer.prototype.stringIndexToBufferIndex = function (lineIndex, stringIndex) {
        while (stringIndex) {
            var line = this.lines.get(lineIndex);
            if (!line) {
                [-1, -1];
            }
            for (var i = 0; i < line.length; ++i) {
                stringIndex -= line.get(i)[exports.CHAR_DATA_CHAR_INDEX].length;
                if (stringIndex < 0) {
                    return [lineIndex, i];
                }
            }
            lineIndex++;
        }
        return [lineIndex, 0];
    };
    Buffer.prototype.translateBufferLineToString = function (lineIndex, trimRight, startCol, endCol) {
        if (startCol === void 0) { startCol = 0; }
        if (endCol === void 0) { endCol = null; }
        var lineString = '';
        var line = this.lines.get(lineIndex);
        if (!line) {
            return '';
        }
        var startIndex = startCol;
        if (endCol === null) {
            endCol = line.length;
        }
        var endIndex = endCol;
        for (var i = 0; i < line.length; i++) {
            var char = line.get(i);
            lineString += char[exports.CHAR_DATA_CHAR_INDEX];
            if (char[exports.CHAR_DATA_WIDTH_INDEX] === 0) {
                if (startCol >= i) {
                    startIndex--;
                }
                if (endCol > i) {
                    endIndex--;
                }
            }
            else {
                if (char[exports.CHAR_DATA_CHAR_INDEX].length > 1) {
                    if (startCol > i) {
                        startIndex += char[exports.CHAR_DATA_CHAR_INDEX].length - 1;
                    }
                    if (endCol > i) {
                        endIndex += char[exports.CHAR_DATA_CHAR_INDEX].length - 1;
                    }
                }
            }
        }
        if (trimRight) {
            var rightWhitespaceIndex = lineString.search(/\s+$/);
            if (rightWhitespaceIndex !== -1) {
                endIndex = Math.min(endIndex, rightWhitespaceIndex);
            }
            if (endIndex <= startIndex) {
                return '';
            }
        }
        return lineString.substring(startIndex, endIndex);
    };
    Buffer.prototype.getWrappedRangeForLine = function (y) {
        var first = y;
        var last = y;
        while (first > 0 && this.lines.get(first).isWrapped) {
            first--;
        }
        while (last + 1 < this.lines.length && this.lines.get(last + 1).isWrapped) {
            last++;
        }
        return { first: first, last: last };
    };
    Buffer.prototype.setupTabStops = function (i) {
        if (i !== null && i !== undefined) {
            if (!this.tabs[i]) {
                i = this.prevStop(i);
            }
        }
        else {
            this.tabs = {};
            i = 0;
        }
        for (; i < this._terminal.cols; i += this._terminal.options.tabStopWidth) {
            this.tabs[i] = true;
        }
    };
    Buffer.prototype.prevStop = function (x) {
        if (x === null || x === undefined) {
            x = this.x;
        }
        while (!this.tabs[--x] && x > 0)
            ;
        return x >= this._terminal.cols ? this._terminal.cols - 1 : x < 0 ? 0 : x;
    };
    Buffer.prototype.nextStop = function (x) {
        if (x === null || x === undefined) {
            x = this.x;
        }
        while (!this.tabs[++x] && x < this._terminal.cols)
            ;
        return x >= this._terminal.cols ? this._terminal.cols - 1 : x < 0 ? 0 : x;
    };
    Buffer.prototype.addMarker = function (y) {
        var _this = this;
        var marker = new Marker(y);
        this.markers.push(marker);
        marker.register(this.lines.addDisposableListener('trim', function (amount) {
            marker.line -= amount;
            if (marker.line < 0) {
                marker.dispose();
            }
        }));
        marker.register(marker.addDisposableListener('dispose', function () { return _this._removeMarker(marker); }));
        return marker;
    };
    Buffer.prototype._removeMarker = function (marker) {
        this.markers.splice(this.markers.indexOf(marker), 1);
    };
    Buffer.prototype.iterator = function (trimRight, startIndex, endIndex, startOverscan, endOverscan) {
        return new BufferStringIterator(this, trimRight, startIndex, endIndex, startOverscan, endOverscan);
    };
    return Buffer;
}());
exports.Buffer = Buffer;
var Marker = (function (_super) {
    __extends(Marker, _super);
    function Marker(line) {
        var _this = _super.call(this) || this;
        _this.line = line;
        _this._id = Marker._nextId++;
        _this.isDisposed = false;
        return _this;
    }
    Object.defineProperty(Marker.prototype, "id", {
        get: function () { return this._id; },
        enumerable: true,
        configurable: true
    });
    Marker.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this.isDisposed = true;
        this.emit('dispose');
        _super.prototype.dispose.call(this);
    };
    Marker._nextId = 1;
    return Marker;
}(EventEmitter_1.EventEmitter));
exports.Marker = Marker;
var BufferStringIterator = (function () {
    function BufferStringIterator(_buffer, _trimRight, _startIndex, _endIndex, _startOverscan, _endOverscan) {
        if (_startIndex === void 0) { _startIndex = 0; }
        if (_endIndex === void 0) { _endIndex = _buffer.lines.length; }
        if (_startOverscan === void 0) { _startOverscan = 0; }
        if (_endOverscan === void 0) { _endOverscan = 0; }
        this._buffer = _buffer;
        this._trimRight = _trimRight;
        this._startIndex = _startIndex;
        this._endIndex = _endIndex;
        this._startOverscan = _startOverscan;
        this._endOverscan = _endOverscan;
        if (this._startIndex < 0) {
            this._startIndex = 0;
        }
        if (this._endIndex > this._buffer.lines.length) {
            this._endIndex = this._buffer.lines.length;
        }
        this._current = this._startIndex;
    }
    BufferStringIterator.prototype.hasNext = function () {
        return this._current < this._endIndex;
    };
    BufferStringIterator.prototype.next = function () {
        var range = this._buffer.getWrappedRangeForLine(this._current);
        if (range.first < this._startIndex - this._startOverscan) {
            range.first = this._startIndex - this._startOverscan;
        }
        if (range.last > this._endIndex + this._endOverscan) {
            range.last = this._endIndex + this._endOverscan;
        }
        range.first = Math.max(range.first, 0);
        range.last = Math.min(range.last, this._buffer.lines.length);
        var result = '';
        for (var i = range.first; i <= range.last; ++i) {
            result += this._buffer.translateBufferLineToString(i, (this._trimRight) ? i === range.last : false);
        }
        this._current = range.last + 1;
        return { range: range, content: result };
    };
    return BufferStringIterator;
}());
exports.BufferStringIterator = BufferStringIterator;
//# sourceMappingURL=Buffer.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/BufferLine.js":
/*!**********************************************!*\
  !*** ./node_modules/xterm/lib/BufferLine.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Buffer_1 = __webpack_require__(/*! ./Buffer */ "./node_modules/xterm/lib/Buffer.js");
var BufferLine = (function () {
    function BufferLine(cols, ch, isWrapped) {
        this.isWrapped = false;
        this._data = [];
        this.length = this._data.length;
        if (cols) {
            if (!ch) {
                ch = [0, Buffer_1.NULL_CELL_CHAR, Buffer_1.NULL_CELL_WIDTH, Buffer_1.NULL_CELL_CODE];
            }
            for (var i = 0; i < cols; i++) {
                this.push(ch);
            }
        }
        if (isWrapped) {
            this.isWrapped = true;
        }
    }
    BufferLine.blankLine = function (cols, attr, isWrapped) {
        var ch = [attr, Buffer_1.NULL_CELL_CHAR, Buffer_1.NULL_CELL_WIDTH, Buffer_1.NULL_CELL_CODE];
        return new BufferLine(cols, ch, isWrapped);
    };
    BufferLine.prototype.get = function (index) {
        return this._data[index];
    };
    BufferLine.prototype.set = function (index, data) {
        this._data[index] = data;
    };
    BufferLine.prototype.pop = function () {
        var data = this._data.pop();
        this.length = this._data.length;
        return data;
    };
    BufferLine.prototype.push = function (data) {
        this._data.push(data);
        this.length = this._data.length;
    };
    BufferLine.prototype.splice = function (start, deleteCount) {
        var items = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            items[_i - 2] = arguments[_i];
        }
        var _a;
        var removed = (_a = this._data).splice.apply(_a, [start, deleteCount].concat(items));
        this.length = this._data.length;
        return removed;
    };
    BufferLine.prototype.insertCells = function (pos, n, ch) {
        while (n--) {
            this.splice(pos, 0, ch);
            this.pop();
        }
    };
    BufferLine.prototype.deleteCells = function (pos, n, fill) {
        while (n--) {
            this.splice(pos, 1);
            this.push(fill);
        }
    };
    BufferLine.prototype.replaceCells = function (start, end, fill) {
        while (start < end && start < this.length) {
            this.set(start++, fill);
        }
    };
    return BufferLine;
}());
exports.BufferLine = BufferLine;
//# sourceMappingURL=BufferLine.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/BufferSet.js":
/*!*********************************************!*\
  !*** ./node_modules/xterm/lib/BufferSet.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Buffer_1 = __webpack_require__(/*! ./Buffer */ "./node_modules/xterm/lib/Buffer.js");
var EventEmitter_1 = __webpack_require__(/*! ./common/EventEmitter */ "./node_modules/xterm/lib/common/EventEmitter.js");
var BufferSet = (function (_super) {
    __extends(BufferSet, _super);
    function BufferSet(_terminal) {
        var _this = _super.call(this) || this;
        _this._terminal = _terminal;
        _this._normal = new Buffer_1.Buffer(_this._terminal, true);
        _this._normal.fillViewportRows();
        _this._alt = new Buffer_1.Buffer(_this._terminal, false);
        _this._activeBuffer = _this._normal;
        _this.setupTabStops();
        return _this;
    }
    Object.defineProperty(BufferSet.prototype, "alt", {
        get: function () {
            return this._alt;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BufferSet.prototype, "active", {
        get: function () {
            return this._activeBuffer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BufferSet.prototype, "normal", {
        get: function () {
            return this._normal;
        },
        enumerable: true,
        configurable: true
    });
    BufferSet.prototype.activateNormalBuffer = function () {
        if (this._activeBuffer === this._normal) {
            return;
        }
        this._alt.clear();
        this._activeBuffer = this._normal;
        this.emit('activate', {
            activeBuffer: this._normal,
            inactiveBuffer: this._alt
        });
    };
    BufferSet.prototype.activateAltBuffer = function () {
        if (this._activeBuffer === this._alt) {
            return;
        }
        this._alt.fillViewportRows();
        this._activeBuffer = this._alt;
        this.emit('activate', {
            activeBuffer: this._alt,
            inactiveBuffer: this._normal
        });
    };
    BufferSet.prototype.resize = function (newCols, newRows) {
        this._normal.resize(newCols, newRows);
        this._alt.resize(newCols, newRows);
    };
    BufferSet.prototype.setupTabStops = function (i) {
        this._normal.setupTabStops(i);
        this._alt.setupTabStops(i);
    };
    return BufferSet;
}(EventEmitter_1.EventEmitter));
exports.BufferSet = BufferSet;
//# sourceMappingURL=BufferSet.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/CharWidth.js":
/*!*********************************************!*\
  !*** ./node_modules/xterm/lib/CharWidth.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.wcwidth = (function (opts) {
    var COMBINING_BMP = [
        [0x0300, 0x036F], [0x0483, 0x0486], [0x0488, 0x0489],
        [0x0591, 0x05BD], [0x05BF, 0x05BF], [0x05C1, 0x05C2],
        [0x05C4, 0x05C5], [0x05C7, 0x05C7], [0x0600, 0x0603],
        [0x0610, 0x0615], [0x064B, 0x065E], [0x0670, 0x0670],
        [0x06D6, 0x06E4], [0x06E7, 0x06E8], [0x06EA, 0x06ED],
        [0x070F, 0x070F], [0x0711, 0x0711], [0x0730, 0x074A],
        [0x07A6, 0x07B0], [0x07EB, 0x07F3], [0x0901, 0x0902],
        [0x093C, 0x093C], [0x0941, 0x0948], [0x094D, 0x094D],
        [0x0951, 0x0954], [0x0962, 0x0963], [0x0981, 0x0981],
        [0x09BC, 0x09BC], [0x09C1, 0x09C4], [0x09CD, 0x09CD],
        [0x09E2, 0x09E3], [0x0A01, 0x0A02], [0x0A3C, 0x0A3C],
        [0x0A41, 0x0A42], [0x0A47, 0x0A48], [0x0A4B, 0x0A4D],
        [0x0A70, 0x0A71], [0x0A81, 0x0A82], [0x0ABC, 0x0ABC],
        [0x0AC1, 0x0AC5], [0x0AC7, 0x0AC8], [0x0ACD, 0x0ACD],
        [0x0AE2, 0x0AE3], [0x0B01, 0x0B01], [0x0B3C, 0x0B3C],
        [0x0B3F, 0x0B3F], [0x0B41, 0x0B43], [0x0B4D, 0x0B4D],
        [0x0B56, 0x0B56], [0x0B82, 0x0B82], [0x0BC0, 0x0BC0],
        [0x0BCD, 0x0BCD], [0x0C3E, 0x0C40], [0x0C46, 0x0C48],
        [0x0C4A, 0x0C4D], [0x0C55, 0x0C56], [0x0CBC, 0x0CBC],
        [0x0CBF, 0x0CBF], [0x0CC6, 0x0CC6], [0x0CCC, 0x0CCD],
        [0x0CE2, 0x0CE3], [0x0D41, 0x0D43], [0x0D4D, 0x0D4D],
        [0x0DCA, 0x0DCA], [0x0DD2, 0x0DD4], [0x0DD6, 0x0DD6],
        [0x0E31, 0x0E31], [0x0E34, 0x0E3A], [0x0E47, 0x0E4E],
        [0x0EB1, 0x0EB1], [0x0EB4, 0x0EB9], [0x0EBB, 0x0EBC],
        [0x0EC8, 0x0ECD], [0x0F18, 0x0F19], [0x0F35, 0x0F35],
        [0x0F37, 0x0F37], [0x0F39, 0x0F39], [0x0F71, 0x0F7E],
        [0x0F80, 0x0F84], [0x0F86, 0x0F87], [0x0F90, 0x0F97],
        [0x0F99, 0x0FBC], [0x0FC6, 0x0FC6], [0x102D, 0x1030],
        [0x1032, 0x1032], [0x1036, 0x1037], [0x1039, 0x1039],
        [0x1058, 0x1059], [0x1160, 0x11FF], [0x135F, 0x135F],
        [0x1712, 0x1714], [0x1732, 0x1734], [0x1752, 0x1753],
        [0x1772, 0x1773], [0x17B4, 0x17B5], [0x17B7, 0x17BD],
        [0x17C6, 0x17C6], [0x17C9, 0x17D3], [0x17DD, 0x17DD],
        [0x180B, 0x180D], [0x18A9, 0x18A9], [0x1920, 0x1922],
        [0x1927, 0x1928], [0x1932, 0x1932], [0x1939, 0x193B],
        [0x1A17, 0x1A18], [0x1B00, 0x1B03], [0x1B34, 0x1B34],
        [0x1B36, 0x1B3A], [0x1B3C, 0x1B3C], [0x1B42, 0x1B42],
        [0x1B6B, 0x1B73], [0x1DC0, 0x1DCA], [0x1DFE, 0x1DFF],
        [0x200B, 0x200F], [0x202A, 0x202E], [0x2060, 0x2063],
        [0x206A, 0x206F], [0x20D0, 0x20EF], [0x302A, 0x302F],
        [0x3099, 0x309A], [0xA806, 0xA806], [0xA80B, 0xA80B],
        [0xA825, 0xA826], [0xFB1E, 0xFB1E], [0xFE00, 0xFE0F],
        [0xFE20, 0xFE23], [0xFEFF, 0xFEFF], [0xFFF9, 0xFFFB]
    ];
    var COMBINING_HIGH = [
        [0x10A01, 0x10A03], [0x10A05, 0x10A06], [0x10A0C, 0x10A0F],
        [0x10A38, 0x10A3A], [0x10A3F, 0x10A3F], [0x1D167, 0x1D169],
        [0x1D173, 0x1D182], [0x1D185, 0x1D18B], [0x1D1AA, 0x1D1AD],
        [0x1D242, 0x1D244], [0xE0001, 0xE0001], [0xE0020, 0xE007F],
        [0xE0100, 0xE01EF]
    ];
    function bisearch(ucs, data) {
        var min = 0;
        var max = data.length - 1;
        var mid;
        if (ucs < data[0][0] || ucs > data[max][1]) {
            return false;
        }
        while (max >= min) {
            mid = (min + max) >> 1;
            if (ucs > data[mid][1]) {
                min = mid + 1;
            }
            else if (ucs < data[mid][0]) {
                max = mid - 1;
            }
            else {
                return true;
            }
        }
        return false;
    }
    function wcwidthBMP(ucs) {
        if (ucs === 0) {
            return opts.nul;
        }
        if (ucs < 32 || (ucs >= 0x7f && ucs < 0xa0)) {
            return opts.control;
        }
        if (bisearch(ucs, COMBINING_BMP)) {
            return 0;
        }
        if (isWideBMP(ucs)) {
            return 2;
        }
        return 1;
    }
    function isWideBMP(ucs) {
        return (ucs >= 0x1100 && (ucs <= 0x115f ||
            ucs === 0x2329 ||
            ucs === 0x232a ||
            (ucs >= 0x2e80 && ucs <= 0xa4cf && ucs !== 0x303f) ||
            (ucs >= 0xac00 && ucs <= 0xd7a3) ||
            (ucs >= 0xf900 && ucs <= 0xfaff) ||
            (ucs >= 0xfe10 && ucs <= 0xfe19) ||
            (ucs >= 0xfe30 && ucs <= 0xfe6f) ||
            (ucs >= 0xff00 && ucs <= 0xff60) ||
            (ucs >= 0xffe0 && ucs <= 0xffe6)));
    }
    function wcwidthHigh(ucs) {
        if (bisearch(ucs, COMBINING_HIGH)) {
            return 0;
        }
        if ((ucs >= 0x20000 && ucs <= 0x2fffd) || (ucs >= 0x30000 && ucs <= 0x3fffd)) {
            return 2;
        }
        return 1;
    }
    var control = opts.control | 0;
    var table = null;
    function initTable() {
        var CODEPOINTS = 65536;
        var BITWIDTH = 2;
        var ITEMSIZE = 32;
        var CONTAINERSIZE = CODEPOINTS * BITWIDTH / ITEMSIZE;
        var CODEPOINTS_PER_ITEM = ITEMSIZE / BITWIDTH;
        table = (typeof Uint32Array === 'undefined')
            ? new Array(CONTAINERSIZE)
            : new Uint32Array(CONTAINERSIZE);
        for (var i = 0; i < CONTAINERSIZE; ++i) {
            var num = 0;
            var pos = CODEPOINTS_PER_ITEM;
            while (pos--) {
                num = (num << 2) | wcwidthBMP(CODEPOINTS_PER_ITEM * i + pos);
            }
            table[i] = num;
        }
        return table;
    }
    return function (num) {
        num = num | 0;
        if (num < 32) {
            return control | 0;
        }
        if (num < 127) {
            return 1;
        }
        var t = table || initTable();
        if (num < 65536) {
            return t[num >> 4] >> ((num & 15) << 1) & 3;
        }
        return wcwidthHigh(num);
    };
})({ nul: 0, control: 0 });
function getStringCellWidth(s) {
    var result = 0;
    for (var i = 0; i < s.length; ++i) {
        var code = s.charCodeAt(i);
        if (0xD800 <= code && code <= 0xDBFF) {
            var low = s.charCodeAt(i + 1);
            if (isNaN(low)) {
                return result;
            }
            code = ((code - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;
        }
        if (0xDC00 <= code && code <= 0xDFFF) {
            continue;
        }
        result += exports.wcwidth(code);
    }
    return result;
}
exports.getStringCellWidth = getStringCellWidth;
//# sourceMappingURL=CharWidth.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/CompositionHelper.js":
/*!*****************************************************!*\
  !*** ./node_modules/xterm/lib/CompositionHelper.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var CompositionHelper = (function () {
    function CompositionHelper(_textarea, _compositionView, _terminal) {
        this._textarea = _textarea;
        this._compositionView = _compositionView;
        this._terminal = _terminal;
        this._isComposing = false;
        this._isSendingComposition = false;
        this._compositionPosition = { start: null, end: null };
    }
    CompositionHelper.prototype.compositionstart = function () {
        this._isComposing = true;
        this._compositionPosition.start = this._textarea.value.length;
        this._compositionView.textContent = '';
        this._compositionView.classList.add('active');
    };
    CompositionHelper.prototype.compositionupdate = function (ev) {
        var _this = this;
        this._compositionView.textContent = ev.data;
        this.updateCompositionElements();
        setTimeout(function () {
            _this._compositionPosition.end = _this._textarea.value.length;
        }, 0);
    };
    CompositionHelper.prototype.compositionend = function () {
        this._finalizeComposition(true);
    };
    CompositionHelper.prototype.keydown = function (ev) {
        if (this._isComposing || this._isSendingComposition) {
            if (ev.keyCode === 229) {
                return false;
            }
            else if (ev.keyCode === 16 || ev.keyCode === 17 || ev.keyCode === 18) {
                return false;
            }
            this._finalizeComposition(false);
        }
        if (ev.keyCode === 229) {
            this._handleAnyTextareaChanges();
            return false;
        }
        return true;
    };
    CompositionHelper.prototype._finalizeComposition = function (waitForPropogation) {
        var _this = this;
        this._compositionView.classList.remove('active');
        this._isComposing = false;
        this._clearTextareaPosition();
        if (!waitForPropogation) {
            this._isSendingComposition = false;
            var input = this._textarea.value.substring(this._compositionPosition.start, this._compositionPosition.end);
            this._terminal.handler(input);
        }
        else {
            var currentCompositionPosition_1 = {
                start: this._compositionPosition.start,
                end: this._compositionPosition.end
            };
            this._isSendingComposition = true;
            setTimeout(function () {
                if (_this._isSendingComposition) {
                    _this._isSendingComposition = false;
                    var input = void 0;
                    if (_this._isComposing) {
                        input = _this._textarea.value.substring(currentCompositionPosition_1.start, currentCompositionPosition_1.end);
                    }
                    else {
                        input = _this._textarea.value.substring(currentCompositionPosition_1.start);
                    }
                    _this._terminal.handler(input);
                }
            }, 0);
        }
    };
    CompositionHelper.prototype._handleAnyTextareaChanges = function () {
        var _this = this;
        var oldValue = this._textarea.value;
        setTimeout(function () {
            if (!_this._isComposing) {
                var newValue = _this._textarea.value;
                var diff = newValue.replace(oldValue, '');
                if (diff.length > 0) {
                    _this._terminal.handler(diff);
                }
            }
        }, 0);
    };
    CompositionHelper.prototype.updateCompositionElements = function (dontRecurse) {
        var _this = this;
        if (!this._isComposing) {
            return;
        }
        if (this._terminal.buffer.isCursorInViewport) {
            var cellHeight = Math.ceil(this._terminal.charMeasure.height * this._terminal.options.lineHeight);
            var cursorTop = this._terminal.buffer.y * cellHeight;
            var cursorLeft = this._terminal.buffer.x * this._terminal.charMeasure.width;
            this._compositionView.style.left = cursorLeft + 'px';
            this._compositionView.style.top = cursorTop + 'px';
            this._compositionView.style.height = cellHeight + 'px';
            this._compositionView.style.lineHeight = cellHeight + 'px';
            var compositionViewBounds = this._compositionView.getBoundingClientRect();
            this._textarea.style.left = cursorLeft + 'px';
            this._textarea.style.top = cursorTop + 'px';
            this._textarea.style.width = compositionViewBounds.width + 'px';
            this._textarea.style.height = compositionViewBounds.height + 'px';
            this._textarea.style.lineHeight = compositionViewBounds.height + 'px';
        }
        if (!dontRecurse) {
            setTimeout(function () { return _this.updateCompositionElements(true); }, 0);
        }
    };
    CompositionHelper.prototype._clearTextareaPosition = function () {
        this._textarea.style.left = '';
        this._textarea.style.top = '';
    };
    return CompositionHelper;
}());
exports.CompositionHelper = CompositionHelper;
//# sourceMappingURL=CompositionHelper.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/EscapeSequenceParser.js":
/*!********************************************************!*\
  !*** ./node_modules/xterm/lib/EscapeSequenceParser.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Lifecycle_1 = __webpack_require__(/*! ./common/Lifecycle */ "./node_modules/xterm/lib/common/Lifecycle.js");
function r(low, high) {
    var c = high - low;
    var arr = new Array(c);
    while (c--) {
        arr[c] = --high;
    }
    return arr;
}
var TransitionTable = (function () {
    function TransitionTable(length) {
        this.table = (typeof Uint8Array === 'undefined')
            ? new Array(length)
            : new Uint8Array(length);
    }
    TransitionTable.prototype.add = function (code, state, action, next) {
        this.table[state << 8 | code] = ((action | 0) << 4) | ((next === undefined) ? state : next);
    };
    TransitionTable.prototype.addMany = function (codes, state, action, next) {
        for (var i = 0; i < codes.length; i++) {
            this.add(codes[i], state, action, next);
        }
    };
    return TransitionTable;
}());
exports.TransitionTable = TransitionTable;
var PRINTABLES = r(0x20, 0x7f);
var EXECUTABLES = r(0x00, 0x18);
EXECUTABLES.push(0x19);
EXECUTABLES.concat(r(0x1c, 0x20));
var DEFAULT_TRANSITION = 1 << 4 | 0;
exports.VT500_TRANSITION_TABLE = (function () {
    var table = new TransitionTable(4095);
    var states = r(0, 13 + 1);
    var state;
    for (state in states) {
        for (var code = 0; code < 160; ++code) {
            table.add(code, state, 1, 0);
        }
    }
    table.addMany(PRINTABLES, 0, 2, 0);
    for (state in states) {
        table.addMany([0x18, 0x1a, 0x99, 0x9a], state, 3, 0);
        table.addMany(r(0x80, 0x90), state, 3, 0);
        table.addMany(r(0x90, 0x98), state, 3, 0);
        table.add(0x9c, state, 0, 0);
        table.add(0x1b, state, 11, 1);
        table.add(0x9d, state, 4, 8);
        table.addMany([0x98, 0x9e, 0x9f], state, 0, 7);
        table.add(0x9b, state, 11, 3);
        table.add(0x90, state, 11, 9);
    }
    table.addMany(EXECUTABLES, 0, 3, 0);
    table.addMany(EXECUTABLES, 1, 3, 1);
    table.add(0x7f, 1, 0, 1);
    table.addMany(EXECUTABLES, 8, 0, 8);
    table.addMany(EXECUTABLES, 3, 3, 3);
    table.add(0x7f, 3, 0, 3);
    table.addMany(EXECUTABLES, 4, 3, 4);
    table.add(0x7f, 4, 0, 4);
    table.addMany(EXECUTABLES, 6, 3, 6);
    table.addMany(EXECUTABLES, 5, 3, 5);
    table.add(0x7f, 5, 0, 5);
    table.addMany(EXECUTABLES, 2, 3, 2);
    table.add(0x7f, 2, 0, 2);
    table.add(0x5d, 1, 4, 8);
    table.addMany(PRINTABLES, 8, 5, 8);
    table.add(0x7f, 8, 5, 8);
    table.addMany([0x9c, 0x1b, 0x18, 0x1a, 0x07], 8, 6, 0);
    table.addMany(r(0x1c, 0x20), 8, 0, 8);
    table.addMany([0x58, 0x5e, 0x5f], 1, 0, 7);
    table.addMany(PRINTABLES, 7, 0, 7);
    table.addMany(EXECUTABLES, 7, 0, 7);
    table.add(0x9c, 7, 0, 0);
    table.add(0x5b, 1, 11, 3);
    table.addMany(r(0x40, 0x7f), 3, 7, 0);
    table.addMany(r(0x30, 0x3a), 3, 8, 4);
    table.add(0x3b, 3, 8, 4);
    table.addMany([0x3c, 0x3d, 0x3e, 0x3f], 3, 9, 4);
    table.addMany(r(0x30, 0x3a), 4, 8, 4);
    table.add(0x3b, 4, 8, 4);
    table.addMany(r(0x40, 0x7f), 4, 7, 0);
    table.addMany([0x3a, 0x3c, 0x3d, 0x3e, 0x3f], 4, 0, 6);
    table.addMany(r(0x20, 0x40), 6, 0, 6);
    table.add(0x7f, 6, 0, 6);
    table.addMany(r(0x40, 0x7f), 6, 0, 0);
    table.add(0x3a, 3, 0, 6);
    table.addMany(r(0x20, 0x30), 3, 9, 5);
    table.addMany(r(0x20, 0x30), 5, 9, 5);
    table.addMany(r(0x30, 0x40), 5, 0, 6);
    table.addMany(r(0x40, 0x7f), 5, 7, 0);
    table.addMany(r(0x20, 0x30), 4, 9, 5);
    table.addMany(r(0x20, 0x30), 1, 9, 2);
    table.addMany(r(0x20, 0x30), 2, 9, 2);
    table.addMany(r(0x30, 0x7f), 2, 10, 0);
    table.addMany(r(0x30, 0x50), 1, 10, 0);
    table.addMany(r(0x51, 0x58), 1, 10, 0);
    table.addMany([0x59, 0x5a, 0x5c], 1, 10, 0);
    table.addMany(r(0x60, 0x7f), 1, 10, 0);
    table.add(0x50, 1, 11, 9);
    table.addMany(EXECUTABLES, 9, 0, 9);
    table.add(0x7f, 9, 0, 9);
    table.addMany(r(0x1c, 0x20), 9, 0, 9);
    table.addMany(r(0x20, 0x30), 9, 9, 12);
    table.add(0x3a, 9, 0, 11);
    table.addMany(r(0x30, 0x3a), 9, 8, 10);
    table.add(0x3b, 9, 8, 10);
    table.addMany([0x3c, 0x3d, 0x3e, 0x3f], 9, 9, 10);
    table.addMany(EXECUTABLES, 11, 0, 11);
    table.addMany(r(0x20, 0x80), 11, 0, 11);
    table.addMany(r(0x1c, 0x20), 11, 0, 11);
    table.addMany(EXECUTABLES, 10, 0, 10);
    table.add(0x7f, 10, 0, 10);
    table.addMany(r(0x1c, 0x20), 10, 0, 10);
    table.addMany(r(0x30, 0x3a), 10, 8, 10);
    table.add(0x3b, 10, 8, 10);
    table.addMany([0x3a, 0x3c, 0x3d, 0x3e, 0x3f], 10, 0, 11);
    table.addMany(r(0x20, 0x30), 10, 9, 12);
    table.addMany(EXECUTABLES, 12, 0, 12);
    table.add(0x7f, 12, 0, 12);
    table.addMany(r(0x1c, 0x20), 12, 0, 12);
    table.addMany(r(0x20, 0x30), 12, 9, 12);
    table.addMany(r(0x30, 0x40), 12, 0, 11);
    table.addMany(r(0x40, 0x7f), 12, 12, 13);
    table.addMany(r(0x40, 0x7f), 10, 12, 13);
    table.addMany(r(0x40, 0x7f), 9, 12, 13);
    table.addMany(EXECUTABLES, 13, 13, 13);
    table.addMany(PRINTABLES, 13, 13, 13);
    table.add(0x7f, 13, 0, 13);
    table.addMany([0x1b, 0x9c], 13, 14, 0);
    return table;
})();
var DcsDummy = (function () {
    function DcsDummy() {
    }
    DcsDummy.prototype.hook = function (collect, params, flag) { };
    DcsDummy.prototype.put = function (data, start, end) { };
    DcsDummy.prototype.unhook = function () { };
    return DcsDummy;
}());
var EscapeSequenceParser = (function (_super) {
    __extends(EscapeSequenceParser, _super);
    function EscapeSequenceParser(TRANSITIONS) {
        if (TRANSITIONS === void 0) { TRANSITIONS = exports.VT500_TRANSITION_TABLE; }
        var _this = _super.call(this) || this;
        _this.TRANSITIONS = TRANSITIONS;
        _this.initialState = 0;
        _this.currentState = _this.initialState;
        _this._osc = '';
        _this._params = [0];
        _this._collect = '';
        _this._printHandlerFb = function (data, start, end) { };
        _this._executeHandlerFb = function (code) { };
        _this._csiHandlerFb = function (collect, params, flag) { };
        _this._escHandlerFb = function (collect, flag) { };
        _this._oscHandlerFb = function (identifier, data) { };
        _this._dcsHandlerFb = new DcsDummy();
        _this._errorHandlerFb = function (state) { return state; };
        _this._printHandler = _this._printHandlerFb;
        _this._executeHandlers = Object.create(null);
        _this._csiHandlers = Object.create(null);
        _this._escHandlers = Object.create(null);
        _this._oscHandlers = Object.create(null);
        _this._dcsHandlers = Object.create(null);
        _this._activeDcsHandler = null;
        _this._errorHandler = _this._errorHandlerFb;
        return _this;
    }
    EscapeSequenceParser.prototype.dispose = function () {
        this._printHandlerFb = null;
        this._executeHandlerFb = null;
        this._csiHandlerFb = null;
        this._escHandlerFb = null;
        this._oscHandlerFb = null;
        this._dcsHandlerFb = null;
        this._errorHandlerFb = null;
        this._printHandler = null;
        this._executeHandlers = null;
        this._csiHandlers = null;
        this._escHandlers = null;
        this._oscHandlers = null;
        this._dcsHandlers = null;
        this._activeDcsHandler = null;
        this._errorHandler = null;
    };
    EscapeSequenceParser.prototype.setPrintHandler = function (callback) {
        this._printHandler = callback;
    };
    EscapeSequenceParser.prototype.clearPrintHandler = function () {
        this._printHandler = this._printHandlerFb;
    };
    EscapeSequenceParser.prototype.setExecuteHandler = function (flag, callback) {
        this._executeHandlers[flag.charCodeAt(0)] = callback;
    };
    EscapeSequenceParser.prototype.clearExecuteHandler = function (flag) {
        if (this._executeHandlers[flag.charCodeAt(0)])
            delete this._executeHandlers[flag.charCodeAt(0)];
    };
    EscapeSequenceParser.prototype.setExecuteHandlerFallback = function (callback) {
        this._executeHandlerFb = callback;
    };
    EscapeSequenceParser.prototype.setCsiHandler = function (flag, callback) {
        this._csiHandlers[flag.charCodeAt(0)] = callback;
    };
    EscapeSequenceParser.prototype.clearCsiHandler = function (flag) {
        if (this._csiHandlers[flag.charCodeAt(0)])
            delete this._csiHandlers[flag.charCodeAt(0)];
    };
    EscapeSequenceParser.prototype.setCsiHandlerFallback = function (callback) {
        this._csiHandlerFb = callback;
    };
    EscapeSequenceParser.prototype.setEscHandler = function (collectAndFlag, callback) {
        this._escHandlers[collectAndFlag] = callback;
    };
    EscapeSequenceParser.prototype.clearEscHandler = function (collectAndFlag) {
        if (this._escHandlers[collectAndFlag])
            delete this._escHandlers[collectAndFlag];
    };
    EscapeSequenceParser.prototype.setEscHandlerFallback = function (callback) {
        this._escHandlerFb = callback;
    };
    EscapeSequenceParser.prototype.setOscHandler = function (ident, callback) {
        this._oscHandlers[ident] = callback;
    };
    EscapeSequenceParser.prototype.clearOscHandler = function (ident) {
        if (this._oscHandlers[ident])
            delete this._oscHandlers[ident];
    };
    EscapeSequenceParser.prototype.setOscHandlerFallback = function (callback) {
        this._oscHandlerFb = callback;
    };
    EscapeSequenceParser.prototype.setDcsHandler = function (collectAndFlag, handler) {
        this._dcsHandlers[collectAndFlag] = handler;
    };
    EscapeSequenceParser.prototype.clearDcsHandler = function (collectAndFlag) {
        if (this._dcsHandlers[collectAndFlag])
            delete this._dcsHandlers[collectAndFlag];
    };
    EscapeSequenceParser.prototype.setDcsHandlerFallback = function (handler) {
        this._dcsHandlerFb = handler;
    };
    EscapeSequenceParser.prototype.setErrorHandler = function (callback) {
        this._errorHandler = callback;
    };
    EscapeSequenceParser.prototype.clearErrorHandler = function () {
        this._errorHandler = this._errorHandlerFb;
    };
    EscapeSequenceParser.prototype.reset = function () {
        this.currentState = this.initialState;
        this._osc = '';
        this._params = [0];
        this._collect = '';
        this._activeDcsHandler = null;
    };
    EscapeSequenceParser.prototype.parse = function (data) {
        var code = 0;
        var transition = 0;
        var error = false;
        var currentState = this.currentState;
        var print = -1;
        var dcs = -1;
        var osc = this._osc;
        var collect = this._collect;
        var params = this._params;
        var table = this.TRANSITIONS.table;
        var dcsHandler = this._activeDcsHandler;
        var callback = null;
        var l = data.length;
        for (var i = 0; i < l; ++i) {
            code = data.charCodeAt(i);
            if (currentState === 0 && code > 0x1f && code < 0x80) {
                print = (~print) ? print : i;
                do
                    i++;
                while (i < l && data.charCodeAt(i) > 0x1f && data.charCodeAt(i) < 0x80);
                i--;
                continue;
            }
            if (currentState === 4 && (code > 0x2f && code < 0x39)) {
                params[params.length - 1] = params[params.length - 1] * 10 + code - 48;
                continue;
            }
            transition = (code < 0xa0) ? (table[currentState << 8 | code]) : DEFAULT_TRANSITION;
            switch (transition >> 4) {
                case 2:
                    print = (~print) ? print : i;
                    break;
                case 3:
                    if (~print) {
                        this._printHandler(data, print, i);
                        print = -1;
                    }
                    callback = this._executeHandlers[code];
                    if (callback)
                        callback();
                    else
                        this._executeHandlerFb(code);
                    break;
                case 0:
                    if (~print) {
                        this._printHandler(data, print, i);
                        print = -1;
                    }
                    else if (~dcs) {
                        dcsHandler.put(data, dcs, i);
                        dcs = -1;
                    }
                    break;
                case 1:
                    if (code > 0x9f) {
                        switch (currentState) {
                            case 0:
                                print = (~print) ? print : i;
                                break;
                            case 8:
                                osc += String.fromCharCode(code);
                                transition |= 8;
                                break;
                            case 6:
                                transition |= 6;
                                break;
                            case 11:
                                transition |= 11;
                                break;
                            case 13:
                                dcs = (~dcs) ? dcs : i;
                                transition |= 13;
                                break;
                            default:
                                error = true;
                        }
                    }
                    else {
                        error = true;
                    }
                    if (error) {
                        var inject = this._errorHandler({
                            position: i,
                            code: code,
                            currentState: currentState,
                            print: print,
                            dcs: dcs,
                            osc: osc,
                            collect: collect,
                            params: params,
                            abort: false
                        });
                        if (inject.abort)
                            return;
                        error = false;
                    }
                    break;
                case 7:
                    callback = this._csiHandlers[code];
                    if (callback)
                        callback(params, collect);
                    else
                        this._csiHandlerFb(collect, params, code);
                    break;
                case 8:
                    if (code === 0x3b)
                        params.push(0);
                    else
                        params[params.length - 1] = params[params.length - 1] * 10 + code - 48;
                    break;
                case 9:
                    collect += String.fromCharCode(code);
                    break;
                case 10:
                    callback = this._escHandlers[collect + String.fromCharCode(code)];
                    if (callback)
                        callback(collect, code);
                    else
                        this._escHandlerFb(collect, code);
                    break;
                case 11:
                    if (~print) {
                        this._printHandler(data, print, i);
                        print = -1;
                    }
                    osc = '';
                    params = [0];
                    collect = '';
                    dcs = -1;
                    break;
                case 12:
                    dcsHandler = this._dcsHandlers[collect + String.fromCharCode(code)];
                    if (!dcsHandler)
                        dcsHandler = this._dcsHandlerFb;
                    dcsHandler.hook(collect, params, code);
                    break;
                case 13:
                    dcs = (~dcs) ? dcs : i;
                    break;
                case 14:
                    if (dcsHandler) {
                        if (~dcs)
                            dcsHandler.put(data, dcs, i);
                        dcsHandler.unhook();
                        dcsHandler = null;
                    }
                    if (code === 0x1b)
                        transition |= 1;
                    osc = '';
                    params = [0];
                    collect = '';
                    dcs = -1;
                    break;
                case 4:
                    if (~print) {
                        this._printHandler(data, print, i);
                        print = -1;
                    }
                    osc = '';
                    break;
                case 5:
                    osc += data.charAt(i);
                    break;
                case 6:
                    if (osc && code !== 0x18 && code !== 0x1a) {
                        var idx = osc.indexOf(';');
                        if (idx === -1) {
                            this._oscHandlerFb(-1, osc);
                        }
                        else {
                            var identifier = parseInt(osc.substring(0, idx));
                            var content = osc.substring(idx + 1);
                            callback = this._oscHandlers[identifier];
                            if (callback)
                                callback(content);
                            else
                                this._oscHandlerFb(identifier, content);
                        }
                    }
                    if (code === 0x1b)
                        transition |= 1;
                    osc = '';
                    params = [0];
                    collect = '';
                    dcs = -1;
                    break;
            }
            currentState = transition & 15;
        }
        if (currentState === 0 && ~print) {
            this._printHandler(data, print, data.length);
        }
        else if (currentState === 13 && ~dcs && dcsHandler) {
            dcsHandler.put(data, dcs, data.length);
        }
        this._osc = osc;
        this._collect = collect;
        this._params = params;
        this._activeDcsHandler = dcsHandler;
        this.currentState = currentState;
    };
    return EscapeSequenceParser;
}(Lifecycle_1.Disposable));
exports.EscapeSequenceParser = EscapeSequenceParser;
//# sourceMappingURL=EscapeSequenceParser.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/InputHandler.js":
/*!************************************************!*\
  !*** ./node_modules/xterm/lib/InputHandler.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var EscapeSequences_1 = __webpack_require__(/*! ./common/data/EscapeSequences */ "./node_modules/xterm/lib/common/data/EscapeSequences.js");
var Charsets_1 = __webpack_require__(/*! ./core/data/Charsets */ "./node_modules/xterm/lib/core/data/Charsets.js");
var Buffer_1 = __webpack_require__(/*! ./Buffer */ "./node_modules/xterm/lib/Buffer.js");
var CharWidth_1 = __webpack_require__(/*! ./CharWidth */ "./node_modules/xterm/lib/CharWidth.js");
var EscapeSequenceParser_1 = __webpack_require__(/*! ./EscapeSequenceParser */ "./node_modules/xterm/lib/EscapeSequenceParser.js");
var Lifecycle_1 = __webpack_require__(/*! ./common/Lifecycle */ "./node_modules/xterm/lib/common/Lifecycle.js");
var BufferLine_1 = __webpack_require__(/*! ./BufferLine */ "./node_modules/xterm/lib/BufferLine.js");
var GLEVEL = { '(': 0, ')': 1, '*': 2, '+': 3, '-': 1, '.': 2 };
var RequestTerminfo = (function () {
    function RequestTerminfo(_terminal) {
        this._terminal = _terminal;
    }
    RequestTerminfo.prototype.hook = function (collect, params, flag) {
        this._data = '';
    };
    RequestTerminfo.prototype.put = function (data, start, end) {
        this._data += data.substring(start, end);
    };
    RequestTerminfo.prototype.unhook = function () {
        this._terminal.handler(EscapeSequences_1.C0.ESC + "P0+r" + this._data + EscapeSequences_1.C0.ESC + "\\");
    };
    return RequestTerminfo;
}());
var DECRQSS = (function () {
    function DECRQSS(_terminal) {
        this._terminal = _terminal;
    }
    DECRQSS.prototype.hook = function (collect, params, flag) {
        this._data = '';
    };
    DECRQSS.prototype.put = function (data, start, end) {
        this._data += data.substring(start, end);
    };
    DECRQSS.prototype.unhook = function () {
        switch (this._data) {
            case '"q':
                return this._terminal.handler(EscapeSequences_1.C0.ESC + "P1$r0\"q" + EscapeSequences_1.C0.ESC + "\\");
            case '"p':
                return this._terminal.handler(EscapeSequences_1.C0.ESC + "P1$r61\"p" + EscapeSequences_1.C0.ESC + "\\");
            case 'r':
                var pt = '' + (this._terminal.buffer.scrollTop + 1) +
                    ';' + (this._terminal.buffer.scrollBottom + 1) + 'r';
                return this._terminal.handler(EscapeSequences_1.C0.ESC + "P1$r" + pt + EscapeSequences_1.C0.ESC + "\\");
            case 'm':
                return this._terminal.handler(EscapeSequences_1.C0.ESC + "P1$r0m" + EscapeSequences_1.C0.ESC + "\\");
            case ' q':
                var STYLES = { 'block': 2, 'underline': 4, 'bar': 6 };
                var style = STYLES[this._terminal.getOption('cursorStyle')];
                style -= this._terminal.getOption('cursorBlink');
                return this._terminal.handler(EscapeSequences_1.C0.ESC + "P1$r" + style + " q" + EscapeSequences_1.C0.ESC + "\\");
            default:
                this._terminal.error('Unknown DCS $q %s', this._data);
                this._terminal.handler(EscapeSequences_1.C0.ESC + "P0$r" + this._data + EscapeSequences_1.C0.ESC + "\\");
        }
    };
    return DECRQSS;
}());
var InputHandler = (function (_super) {
    __extends(InputHandler, _super);
    function InputHandler(_terminal, _parser) {
        if (_parser === void 0) { _parser = new EscapeSequenceParser_1.EscapeSequenceParser(); }
        var _this = _super.call(this) || this;
        _this._terminal = _terminal;
        _this._parser = _parser;
        _this.register(_this._parser);
        _this._surrogateHigh = '';
        _this._parser.setCsiHandlerFallback(function (collect, params, flag) {
            _this._terminal.error('Unknown CSI code: ', { collect: collect, params: params, flag: String.fromCharCode(flag) });
        });
        _this._parser.setEscHandlerFallback(function (collect, flag) {
            _this._terminal.error('Unknown ESC code: ', { collect: collect, flag: String.fromCharCode(flag) });
        });
        _this._parser.setExecuteHandlerFallback(function (code) {
            _this._terminal.error('Unknown EXECUTE code: ', { code: code });
        });
        _this._parser.setOscHandlerFallback(function (identifier, data) {
            _this._terminal.error('Unknown OSC code: ', { identifier: identifier, data: data });
        });
        _this._parser.setPrintHandler(function (data, start, end) { return _this.print(data, start, end); });
        _this._parser.setCsiHandler('@', function (params, collect) { return _this.insertChars(params); });
        _this._parser.setCsiHandler('A', function (params, collect) { return _this.cursorUp(params); });
        _this._parser.setCsiHandler('B', function (params, collect) { return _this.cursorDown(params); });
        _this._parser.setCsiHandler('C', function (params, collect) { return _this.cursorForward(params); });
        _this._parser.setCsiHandler('D', function (params, collect) { return _this.cursorBackward(params); });
        _this._parser.setCsiHandler('E', function (params, collect) { return _this.cursorNextLine(params); });
        _this._parser.setCsiHandler('F', function (params, collect) { return _this.cursorPrecedingLine(params); });
        _this._parser.setCsiHandler('G', function (params, collect) { return _this.cursorCharAbsolute(params); });
        _this._parser.setCsiHandler('H', function (params, collect) { return _this.cursorPosition(params); });
        _this._parser.setCsiHandler('I', function (params, collect) { return _this.cursorForwardTab(params); });
        _this._parser.setCsiHandler('J', function (params, collect) { return _this.eraseInDisplay(params); });
        _this._parser.setCsiHandler('K', function (params, collect) { return _this.eraseInLine(params); });
        _this._parser.setCsiHandler('L', function (params, collect) { return _this.insertLines(params); });
        _this._parser.setCsiHandler('M', function (params, collect) { return _this.deleteLines(params); });
        _this._parser.setCsiHandler('P', function (params, collect) { return _this.deleteChars(params); });
        _this._parser.setCsiHandler('S', function (params, collect) { return _this.scrollUp(params); });
        _this._parser.setCsiHandler('T', function (params, collect) { return _this.scrollDown(params, collect); });
        _this._parser.setCsiHandler('X', function (params, collect) { return _this.eraseChars(params); });
        _this._parser.setCsiHandler('Z', function (params, collect) { return _this.cursorBackwardTab(params); });
        _this._parser.setCsiHandler('`', function (params, collect) { return _this.charPosAbsolute(params); });
        _this._parser.setCsiHandler('a', function (params, collect) { return _this.hPositionRelative(params); });
        _this._parser.setCsiHandler('b', function (params, collect) { return _this.repeatPrecedingCharacter(params); });
        _this._parser.setCsiHandler('c', function (params, collect) { return _this.sendDeviceAttributes(params, collect); });
        _this._parser.setCsiHandler('d', function (params, collect) { return _this.linePosAbsolute(params); });
        _this._parser.setCsiHandler('e', function (params, collect) { return _this.vPositionRelative(params); });
        _this._parser.setCsiHandler('f', function (params, collect) { return _this.hVPosition(params); });
        _this._parser.setCsiHandler('g', function (params, collect) { return _this.tabClear(params); });
        _this._parser.setCsiHandler('h', function (params, collect) { return _this.setMode(params, collect); });
        _this._parser.setCsiHandler('l', function (params, collect) { return _this.resetMode(params, collect); });
        _this._parser.setCsiHandler('m', function (params, collect) { return _this.charAttributes(params); });
        _this._parser.setCsiHandler('n', function (params, collect) { return _this.deviceStatus(params, collect); });
        _this._parser.setCsiHandler('p', function (params, collect) { return _this.softReset(params, collect); });
        _this._parser.setCsiHandler('q', function (params, collect) { return _this.setCursorStyle(params, collect); });
        _this._parser.setCsiHandler('r', function (params, collect) { return _this.setScrollRegion(params, collect); });
        _this._parser.setCsiHandler('s', function (params, collect) { return _this.saveCursor(params); });
        _this._parser.setCsiHandler('u', function (params, collect) { return _this.restoreCursor(params); });
        _this._parser.setExecuteHandler(EscapeSequences_1.C0.BEL, function () { return _this.bell(); });
        _this._parser.setExecuteHandler(EscapeSequences_1.C0.LF, function () { return _this.lineFeed(); });
        _this._parser.setExecuteHandler(EscapeSequences_1.C0.VT, function () { return _this.lineFeed(); });
        _this._parser.setExecuteHandler(EscapeSequences_1.C0.FF, function () { return _this.lineFeed(); });
        _this._parser.setExecuteHandler(EscapeSequences_1.C0.CR, function () { return _this.carriageReturn(); });
        _this._parser.setExecuteHandler(EscapeSequences_1.C0.BS, function () { return _this.backspace(); });
        _this._parser.setExecuteHandler(EscapeSequences_1.C0.HT, function () { return _this.tab(); });
        _this._parser.setExecuteHandler(EscapeSequences_1.C0.SO, function () { return _this.shiftOut(); });
        _this._parser.setExecuteHandler(EscapeSequences_1.C0.SI, function () { return _this.shiftIn(); });
        _this._parser.setExecuteHandler(EscapeSequences_1.C1.IND, function () { return _this.index(); });
        _this._parser.setExecuteHandler(EscapeSequences_1.C1.NEL, function () { return _this.nextLine(); });
        _this._parser.setExecuteHandler(EscapeSequences_1.C1.HTS, function () { return _this.tabSet(); });
        _this._parser.setOscHandler(0, function (data) { return _this.setTitle(data); });
        _this._parser.setOscHandler(2, function (data) { return _this.setTitle(data); });
        _this._parser.setEscHandler('7', function () { return _this.saveCursor([]); });
        _this._parser.setEscHandler('8', function () { return _this.restoreCursor([]); });
        _this._parser.setEscHandler('D', function () { return _this.index(); });
        _this._parser.setEscHandler('E', function () { return _this.nextLine(); });
        _this._parser.setEscHandler('H', function () { return _this.tabSet(); });
        _this._parser.setEscHandler('M', function () { return _this.reverseIndex(); });
        _this._parser.setEscHandler('=', function () { return _this.keypadApplicationMode(); });
        _this._parser.setEscHandler('>', function () { return _this.keypadNumericMode(); });
        _this._parser.setEscHandler('c', function () { return _this.reset(); });
        _this._parser.setEscHandler('n', function () { return _this.setgLevel(2); });
        _this._parser.setEscHandler('o', function () { return _this.setgLevel(3); });
        _this._parser.setEscHandler('|', function () { return _this.setgLevel(3); });
        _this._parser.setEscHandler('}', function () { return _this.setgLevel(2); });
        _this._parser.setEscHandler('~', function () { return _this.setgLevel(1); });
        _this._parser.setEscHandler('%@', function () { return _this.selectDefaultCharset(); });
        _this._parser.setEscHandler('%G', function () { return _this.selectDefaultCharset(); });
        var _loop_1 = function (flag) {
            this_1._parser.setEscHandler('(' + flag, function () { return _this.selectCharset('(' + flag); });
            this_1._parser.setEscHandler(')' + flag, function () { return _this.selectCharset(')' + flag); });
            this_1._parser.setEscHandler('*' + flag, function () { return _this.selectCharset('*' + flag); });
            this_1._parser.setEscHandler('+' + flag, function () { return _this.selectCharset('+' + flag); });
            this_1._parser.setEscHandler('-' + flag, function () { return _this.selectCharset('-' + flag); });
            this_1._parser.setEscHandler('.' + flag, function () { return _this.selectCharset('.' + flag); });
            this_1._parser.setEscHandler('/' + flag, function () { return _this.selectCharset('/' + flag); });
        };
        var this_1 = this;
        for (var flag in Charsets_1.CHARSETS) {
            _loop_1(flag);
        }
        _this._parser.setErrorHandler(function (state) {
            _this._terminal.error('Parsing error: ', state);
            return state;
        });
        _this._parser.setDcsHandler('$q', new DECRQSS(_this._terminal));
        _this._parser.setDcsHandler('+q', new RequestTerminfo(_this._terminal));
        return _this;
    }
    InputHandler.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._terminal = null;
    };
    InputHandler.prototype.parse = function (data) {
        if (!this._terminal) {
            return;
        }
        var buffer = this._terminal.buffer;
        var cursorStartX = buffer.x;
        var cursorStartY = buffer.y;
        if (this._terminal.debug) {
            this._terminal.log('data: ' + data);
        }
        if (this._surrogateHigh) {
            data = this._surrogateHigh + data;
            this._surrogateHigh = '';
        }
        this._parser.parse(data);
        buffer = this._terminal.buffer;
        if (buffer.x !== cursorStartX || buffer.y !== cursorStartY) {
            this._terminal.emit('cursormove');
        }
    };
    InputHandler.prototype.print = function (data, start, end) {
        var char;
        var code;
        var low;
        var chWidth;
        var buffer = this._terminal.buffer;
        var charset = this._terminal.charset;
        var screenReaderMode = this._terminal.options.screenReaderMode;
        var cols = this._terminal.cols;
        var wraparoundMode = this._terminal.wraparoundMode;
        var insertMode = this._terminal.insertMode;
        var curAttr = this._terminal.curAttr;
        var bufferRow = buffer.lines.get(buffer.y + buffer.ybase);
        this._terminal.updateRange(buffer.y);
        for (var stringPosition = start; stringPosition < end; ++stringPosition) {
            char = data.charAt(stringPosition);
            code = data.charCodeAt(stringPosition);
            if (0xD800 <= code && code <= 0xDBFF) {
                low = data.charCodeAt(stringPosition + 1);
                if (isNaN(low)) {
                    this._surrogateHigh = char;
                    continue;
                }
                code = ((code - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;
                char += data.charAt(stringPosition + 1);
            }
            if (0xDC00 <= code && code <= 0xDFFF) {
                continue;
            }
            chWidth = CharWidth_1.wcwidth(code);
            if (charset) {
                char = charset[char] || char;
                code = char.charCodeAt(0);
            }
            if (screenReaderMode) {
                this._terminal.emit('a11y.char', char);
            }
            if (!chWidth && buffer.x) {
                var chMinusOne = bufferRow.get(buffer.x - 1);
                if (chMinusOne) {
                    if (!chMinusOne[Buffer_1.CHAR_DATA_WIDTH_INDEX]) {
                        var chMinusTwo = bufferRow.get(buffer.x - 2);
                        if (chMinusTwo) {
                            chMinusTwo[Buffer_1.CHAR_DATA_CHAR_INDEX] += char;
                            chMinusTwo[Buffer_1.CHAR_DATA_CODE_INDEX] = code;
                        }
                    }
                    else {
                        chMinusOne[Buffer_1.CHAR_DATA_CHAR_INDEX] += char;
                        chMinusOne[Buffer_1.CHAR_DATA_CODE_INDEX] = code;
                    }
                }
                continue;
            }
            if (buffer.x + chWidth - 1 >= cols) {
                if (wraparoundMode) {
                    buffer.x = 0;
                    buffer.y++;
                    if (buffer.y > buffer.scrollBottom) {
                        buffer.y--;
                        this._terminal.scroll(true);
                    }
                    else {
                        buffer.lines.get(buffer.y).isWrapped = true;
                    }
                    bufferRow = buffer.lines.get(buffer.y + buffer.ybase);
                }
                else {
                    if (chWidth === 2) {
                        continue;
                    }
                }
            }
            if (insertMode) {
                for (var moves = 0; moves < chWidth; ++moves) {
                    var removed = bufferRow.pop();
                    var chMinusTwo = bufferRow.get(buffer.x - 2);
                    if (removed[Buffer_1.CHAR_DATA_WIDTH_INDEX] === 0
                        && chMinusTwo
                        && chMinusTwo[Buffer_1.CHAR_DATA_WIDTH_INDEX] === 2) {
                        bufferRow.set(this._terminal.cols - 2, [curAttr, Buffer_1.NULL_CELL_CHAR, Buffer_1.NULL_CELL_WIDTH, Buffer_1.NULL_CELL_CODE]);
                    }
                    bufferRow.splice(buffer.x, 0, [curAttr, Buffer_1.NULL_CELL_CHAR, Buffer_1.NULL_CELL_WIDTH, Buffer_1.NULL_CELL_CODE]);
                }
            }
            bufferRow.set(buffer.x++, [curAttr, char, chWidth, code]);
            if (chWidth === 2) {
                bufferRow.set(buffer.x++, [curAttr, '', 0, undefined]);
            }
        }
        this._terminal.updateRange(buffer.y);
    };
    InputHandler.prototype.bell = function () {
        this._terminal.bell();
    };
    InputHandler.prototype.lineFeed = function () {
        var buffer = this._terminal.buffer;
        if (this._terminal.options.convertEol) {
            buffer.x = 0;
        }
        buffer.y++;
        if (buffer.y > buffer.scrollBottom) {
            buffer.y--;
            this._terminal.scroll();
        }
        if (buffer.x >= this._terminal.cols) {
            buffer.x--;
        }
        this._terminal.emit('linefeed');
    };
    InputHandler.prototype.carriageReturn = function () {
        this._terminal.buffer.x = 0;
    };
    InputHandler.prototype.backspace = function () {
        if (this._terminal.buffer.x > 0) {
            this._terminal.buffer.x--;
        }
    };
    InputHandler.prototype.tab = function () {
        var originalX = this._terminal.buffer.x;
        this._terminal.buffer.x = this._terminal.buffer.nextStop();
        if (this._terminal.options.screenReaderMode) {
            this._terminal.emit('a11y.tab', this._terminal.buffer.x - originalX);
        }
    };
    InputHandler.prototype.shiftOut = function () {
        this._terminal.setgLevel(1);
    };
    InputHandler.prototype.shiftIn = function () {
        this._terminal.setgLevel(0);
    };
    InputHandler.prototype.insertChars = function (params) {
        this._terminal.buffer.lines.get(this._terminal.buffer.y + this._terminal.buffer.ybase).insertCells(this._terminal.buffer.x, params[0] || 1, [this._terminal.eraseAttr(), Buffer_1.NULL_CELL_CHAR, Buffer_1.NULL_CELL_WIDTH, Buffer_1.NULL_CELL_CODE]);
        this._terminal.updateRange(this._terminal.buffer.y);
    };
    InputHandler.prototype.cursorUp = function (params) {
        var param = params[0];
        if (param < 1) {
            param = 1;
        }
        this._terminal.buffer.y -= param;
        if (this._terminal.buffer.y < 0) {
            this._terminal.buffer.y = 0;
        }
    };
    InputHandler.prototype.cursorDown = function (params) {
        var param = params[0];
        if (param < 1) {
            param = 1;
        }
        this._terminal.buffer.y += param;
        if (this._terminal.buffer.y >= this._terminal.rows) {
            this._terminal.buffer.y = this._terminal.rows - 1;
        }
        if (this._terminal.buffer.x >= this._terminal.cols) {
            this._terminal.buffer.x--;
        }
    };
    InputHandler.prototype.cursorForward = function (params) {
        var param = params[0];
        if (param < 1) {
            param = 1;
        }
        this._terminal.buffer.x += param;
        if (this._terminal.buffer.x >= this._terminal.cols) {
            this._terminal.buffer.x = this._terminal.cols - 1;
        }
    };
    InputHandler.prototype.cursorBackward = function (params) {
        var param = params[0];
        if (param < 1) {
            param = 1;
        }
        if (this._terminal.buffer.x >= this._terminal.cols) {
            this._terminal.buffer.x--;
        }
        this._terminal.buffer.x -= param;
        if (this._terminal.buffer.x < 0) {
            this._terminal.buffer.x = 0;
        }
    };
    InputHandler.prototype.cursorNextLine = function (params) {
        var param = params[0];
        if (param < 1) {
            param = 1;
        }
        this._terminal.buffer.y += param;
        if (this._terminal.buffer.y >= this._terminal.rows) {
            this._terminal.buffer.y = this._terminal.rows - 1;
        }
        this._terminal.buffer.x = 0;
    };
    InputHandler.prototype.cursorPrecedingLine = function (params) {
        var param = params[0];
        if (param < 1) {
            param = 1;
        }
        this._terminal.buffer.y -= param;
        if (this._terminal.buffer.y < 0) {
            this._terminal.buffer.y = 0;
        }
        this._terminal.buffer.x = 0;
    };
    InputHandler.prototype.cursorCharAbsolute = function (params) {
        var param = params[0];
        if (param < 1) {
            param = 1;
        }
        this._terminal.buffer.x = param - 1;
    };
    InputHandler.prototype.cursorPosition = function (params) {
        var col;
        var row = params[0] - 1;
        if (params.length >= 2) {
            col = params[1] - 1;
        }
        else {
            col = 0;
        }
        if (row < 0) {
            row = 0;
        }
        else if (row >= this._terminal.rows) {
            row = this._terminal.rows - 1;
        }
        if (col < 0) {
            col = 0;
        }
        else if (col >= this._terminal.cols) {
            col = this._terminal.cols - 1;
        }
        this._terminal.buffer.x = col;
        this._terminal.buffer.y = row;
    };
    InputHandler.prototype.cursorForwardTab = function (params) {
        var param = params[0] || 1;
        while (param--) {
            this._terminal.buffer.x = this._terminal.buffer.nextStop();
        }
    };
    InputHandler.prototype._eraseInBufferLine = function (y, start, end) {
        this._terminal.buffer.lines.get(this._terminal.buffer.ybase + y).replaceCells(start, end, [this._terminal.eraseAttr(), Buffer_1.NULL_CELL_CHAR, Buffer_1.NULL_CELL_WIDTH, Buffer_1.NULL_CELL_CODE]);
    };
    InputHandler.prototype.eraseInDisplay = function (params) {
        var j;
        switch (params[0]) {
            case 0:
                j = this._terminal.buffer.y;
                this._terminal.updateRange(j);
                this._eraseInBufferLine(j++, this._terminal.buffer.x, this._terminal.cols);
                for (; j < this._terminal.rows; j++) {
                    this._eraseInBufferLine(j, 0, this._terminal.cols);
                }
                this._terminal.updateRange(j);
                break;
            case 1:
                j = this._terminal.buffer.y;
                this._terminal.updateRange(j);
                this._eraseInBufferLine(j, 0, this._terminal.buffer.x + 1);
                while (j--) {
                    this._eraseInBufferLine(j, 0, this._terminal.cols);
                }
                this._terminal.updateRange(0);
                break;
            case 2:
                j = this._terminal.rows;
                this._terminal.updateRange(j - 1);
                while (j--) {
                    this._eraseInBufferLine(j, 0, this._terminal.cols);
                }
                this._terminal.updateRange(0);
                break;
            case 3:
                var scrollBackSize = this._terminal.buffer.lines.length - this._terminal.rows;
                if (scrollBackSize > 0) {
                    this._terminal.buffer.lines.trimStart(scrollBackSize);
                    this._terminal.buffer.ybase = Math.max(this._terminal.buffer.ybase - scrollBackSize, 0);
                    this._terminal.buffer.ydisp = Math.max(this._terminal.buffer.ydisp - scrollBackSize, 0);
                    this._terminal.emit('scroll', 0);
                }
                break;
        }
    };
    InputHandler.prototype.eraseInLine = function (params) {
        switch (params[0]) {
            case 0:
                this._eraseInBufferLine(this._terminal.buffer.y, this._terminal.buffer.x, this._terminal.cols);
                break;
            case 1:
                this._eraseInBufferLine(this._terminal.buffer.y, 0, this._terminal.buffer.x + 1);
                break;
            case 2:
                this._eraseInBufferLine(this._terminal.buffer.y, 0, this._terminal.cols);
                break;
        }
        this._terminal.updateRange(this._terminal.buffer.y);
    };
    InputHandler.prototype.insertLines = function (params) {
        var param = params[0];
        if (param < 1) {
            param = 1;
        }
        var buffer = this._terminal.buffer;
        var row = buffer.y + buffer.ybase;
        var scrollBottomRowsOffset = this._terminal.rows - 1 - buffer.scrollBottom;
        var scrollBottomAbsolute = this._terminal.rows - 1 + buffer.ybase - scrollBottomRowsOffset + 1;
        while (param--) {
            buffer.lines.splice(scrollBottomAbsolute - 1, 1);
            buffer.lines.splice(row, 0, BufferLine_1.BufferLine.blankLine(this._terminal.cols, this._terminal.eraseAttr()));
        }
        this._terminal.updateRange(buffer.y);
        this._terminal.updateRange(buffer.scrollBottom);
    };
    InputHandler.prototype.deleteLines = function (params) {
        var param = params[0];
        if (param < 1) {
            param = 1;
        }
        var buffer = this._terminal.buffer;
        var row = buffer.y + buffer.ybase;
        var j;
        j = this._terminal.rows - 1 - buffer.scrollBottom;
        j = this._terminal.rows - 1 + buffer.ybase - j;
        while (param--) {
            buffer.lines.splice(row, 1);
            buffer.lines.splice(j, 0, BufferLine_1.BufferLine.blankLine(this._terminal.cols, this._terminal.eraseAttr()));
        }
        this._terminal.updateRange(buffer.y);
        this._terminal.updateRange(buffer.scrollBottom);
    };
    InputHandler.prototype.deleteChars = function (params) {
        this._terminal.buffer.lines.get(this._terminal.buffer.y + this._terminal.buffer.ybase).deleteCells(this._terminal.buffer.x, params[0] || 1, [this._terminal.eraseAttr(), Buffer_1.NULL_CELL_CHAR, Buffer_1.NULL_CELL_WIDTH, Buffer_1.NULL_CELL_CODE]);
        this._terminal.updateRange(this._terminal.buffer.y);
    };
    InputHandler.prototype.scrollUp = function (params) {
        var param = params[0] || 1;
        var buffer = this._terminal.buffer;
        while (param--) {
            buffer.lines.splice(buffer.ybase + buffer.scrollTop, 1);
            buffer.lines.splice(buffer.ybase + buffer.scrollBottom, 0, BufferLine_1.BufferLine.blankLine(this._terminal.cols, Buffer_1.DEFAULT_ATTR));
        }
        this._terminal.updateRange(buffer.scrollTop);
        this._terminal.updateRange(buffer.scrollBottom);
    };
    InputHandler.prototype.scrollDown = function (params, collect) {
        if (params.length < 2 && !collect) {
            var param = params[0] || 1;
            var buffer = this._terminal.buffer;
            while (param--) {
                buffer.lines.splice(buffer.ybase + buffer.scrollBottom, 1);
                buffer.lines.splice(buffer.ybase + buffer.scrollBottom, 0, BufferLine_1.BufferLine.blankLine(this._terminal.cols, Buffer_1.DEFAULT_ATTR));
            }
            this._terminal.updateRange(buffer.scrollTop);
            this._terminal.updateRange(buffer.scrollBottom);
        }
    };
    InputHandler.prototype.eraseChars = function (params) {
        this._terminal.buffer.lines.get(this._terminal.buffer.y + this._terminal.buffer.ybase).replaceCells(this._terminal.buffer.x, this._terminal.buffer.x + (params[0] || 1), [this._terminal.eraseAttr(), Buffer_1.NULL_CELL_CHAR, Buffer_1.NULL_CELL_WIDTH, Buffer_1.NULL_CELL_CODE]);
    };
    InputHandler.prototype.cursorBackwardTab = function (params) {
        var param = params[0] || 1;
        var buffer = this._terminal.buffer;
        while (param--) {
            buffer.x = buffer.prevStop();
        }
    };
    InputHandler.prototype.charPosAbsolute = function (params) {
        var param = params[0];
        if (param < 1) {
            param = 1;
        }
        this._terminal.buffer.x = param - 1;
        if (this._terminal.buffer.x >= this._terminal.cols) {
            this._terminal.buffer.x = this._terminal.cols - 1;
        }
    };
    InputHandler.prototype.hPositionRelative = function (params) {
        var param = params[0];
        if (param < 1) {
            param = 1;
        }
        this._terminal.buffer.x += param;
        if (this._terminal.buffer.x >= this._terminal.cols) {
            this._terminal.buffer.x = this._terminal.cols - 1;
        }
    };
    InputHandler.prototype.repeatPrecedingCharacter = function (params) {
        var buffer = this._terminal.buffer;
        var line = buffer.lines.get(buffer.ybase + buffer.y);
        line.replaceCells(buffer.x, buffer.x + (params[0] || 1), line.get(buffer.x - 1) || [Buffer_1.DEFAULT_ATTR, Buffer_1.NULL_CELL_CHAR, Buffer_1.NULL_CELL_WIDTH, Buffer_1.NULL_CELL_CODE]);
    };
    InputHandler.prototype.sendDeviceAttributes = function (params, collect) {
        if (params[0] > 0) {
            return;
        }
        if (!collect) {
            if (this._terminal.is('xterm') || this._terminal.is('rxvt-unicode') || this._terminal.is('screen')) {
                this._terminal.handler(EscapeSequences_1.C0.ESC + '[?1;2c');
            }
            else if (this._terminal.is('linux')) {
                this._terminal.handler(EscapeSequences_1.C0.ESC + '[?6c');
            }
        }
        else if (collect === '>') {
            if (this._terminal.is('xterm')) {
                this._terminal.handler(EscapeSequences_1.C0.ESC + '[>0;276;0c');
            }
            else if (this._terminal.is('rxvt-unicode')) {
                this._terminal.handler(EscapeSequences_1.C0.ESC + '[>85;95;0c');
            }
            else if (this._terminal.is('linux')) {
                this._terminal.handler(params[0] + 'c');
            }
            else if (this._terminal.is('screen')) {
                this._terminal.handler(EscapeSequences_1.C0.ESC + '[>83;40003;0c');
            }
        }
    };
    InputHandler.prototype.linePosAbsolute = function (params) {
        var param = params[0];
        if (param < 1) {
            param = 1;
        }
        this._terminal.buffer.y = param - 1;
        if (this._terminal.buffer.y >= this._terminal.rows) {
            this._terminal.buffer.y = this._terminal.rows - 1;
        }
    };
    InputHandler.prototype.vPositionRelative = function (params) {
        var param = params[0];
        if (param < 1) {
            param = 1;
        }
        this._terminal.buffer.y += param;
        if (this._terminal.buffer.y >= this._terminal.rows) {
            this._terminal.buffer.y = this._terminal.rows - 1;
        }
        if (this._terminal.buffer.x >= this._terminal.cols) {
            this._terminal.buffer.x--;
        }
    };
    InputHandler.prototype.hVPosition = function (params) {
        if (params[0] < 1)
            params[0] = 1;
        if (params[1] < 1)
            params[1] = 1;
        this._terminal.buffer.y = params[0] - 1;
        if (this._terminal.buffer.y >= this._terminal.rows) {
            this._terminal.buffer.y = this._terminal.rows - 1;
        }
        this._terminal.buffer.x = params[1] - 1;
        if (this._terminal.buffer.x >= this._terminal.cols) {
            this._terminal.buffer.x = this._terminal.cols - 1;
        }
    };
    InputHandler.prototype.tabClear = function (params) {
        var param = params[0];
        if (param <= 0) {
            delete this._terminal.buffer.tabs[this._terminal.buffer.x];
        }
        else if (param === 3) {
            this._terminal.buffer.tabs = {};
        }
    };
    InputHandler.prototype.setMode = function (params, collect) {
        if (params.length > 1) {
            for (var i = 0; i < params.length; i++) {
                this.setMode([params[i]]);
            }
            return;
        }
        if (!collect) {
            switch (params[0]) {
                case 4:
                    this._terminal.insertMode = true;
                    break;
                case 20:
                    break;
            }
        }
        else if (collect === '?') {
            switch (params[0]) {
                case 1:
                    this._terminal.applicationCursor = true;
                    break;
                case 2:
                    this._terminal.setgCharset(0, Charsets_1.DEFAULT_CHARSET);
                    this._terminal.setgCharset(1, Charsets_1.DEFAULT_CHARSET);
                    this._terminal.setgCharset(2, Charsets_1.DEFAULT_CHARSET);
                    this._terminal.setgCharset(3, Charsets_1.DEFAULT_CHARSET);
                    break;
                case 3:
                    this._terminal.savedCols = this._terminal.cols;
                    this._terminal.resize(132, this._terminal.rows);
                    break;
                case 6:
                    this._terminal.originMode = true;
                    break;
                case 7:
                    this._terminal.wraparoundMode = true;
                    break;
                case 12:
                    break;
                case 66:
                    this._terminal.log('Serial port requested application keypad.');
                    this._terminal.applicationKeypad = true;
                    this._terminal.viewport.syncScrollArea();
                    break;
                case 9:
                case 1000:
                case 1002:
                case 1003:
                    this._terminal.x10Mouse = params[0] === 9;
                    this._terminal.vt200Mouse = params[0] === 1000;
                    this._terminal.normalMouse = params[0] > 1000;
                    this._terminal.mouseEvents = true;
                    this._terminal.element.classList.add('enable-mouse-events');
                    this._terminal.selectionManager.disable();
                    this._terminal.log('Binding to mouse events.');
                    break;
                case 1004:
                    this._terminal.sendFocus = true;
                    break;
                case 1005:
                    this._terminal.utfMouse = true;
                    break;
                case 1006:
                    this._terminal.sgrMouse = true;
                    break;
                case 1015:
                    this._terminal.urxvtMouse = true;
                    break;
                case 25:
                    this._terminal.cursorHidden = false;
                    break;
                case 1049:
                case 47:
                case 1047:
                    this._terminal.buffers.activateAltBuffer();
                    this._terminal.viewport.syncScrollArea();
                    this._terminal.showCursor();
                    break;
                case 2004:
                    this._terminal.bracketedPasteMode = true;
                    break;
            }
        }
    };
    InputHandler.prototype.resetMode = function (params, collect) {
        if (params.length > 1) {
            for (var i = 0; i < params.length; i++) {
                this.resetMode([params[i]]);
            }
            return;
        }
        if (!collect) {
            switch (params[0]) {
                case 4:
                    this._terminal.insertMode = false;
                    break;
                case 20:
                    break;
            }
        }
        else if (collect === '?') {
            switch (params[0]) {
                case 1:
                    this._terminal.applicationCursor = false;
                    break;
                case 3:
                    if (this._terminal.cols === 132 && this._terminal.savedCols) {
                        this._terminal.resize(this._terminal.savedCols, this._terminal.rows);
                    }
                    delete this._terminal.savedCols;
                    break;
                case 6:
                    this._terminal.originMode = false;
                    break;
                case 7:
                    this._terminal.wraparoundMode = false;
                    break;
                case 12:
                    break;
                case 66:
                    this._terminal.log('Switching back to normal keypad.');
                    this._terminal.applicationKeypad = false;
                    this._terminal.viewport.syncScrollArea();
                    break;
                case 9:
                case 1000:
                case 1002:
                case 1003:
                    this._terminal.x10Mouse = false;
                    this._terminal.vt200Mouse = false;
                    this._terminal.normalMouse = false;
                    this._terminal.mouseEvents = false;
                    this._terminal.element.classList.remove('enable-mouse-events');
                    this._terminal.selectionManager.enable();
                    break;
                case 1004:
                    this._terminal.sendFocus = false;
                    break;
                case 1005:
                    this._terminal.utfMouse = false;
                    break;
                case 1006:
                    this._terminal.sgrMouse = false;
                    break;
                case 1015:
                    this._terminal.urxvtMouse = false;
                    break;
                case 25:
                    this._terminal.cursorHidden = true;
                    break;
                case 1049:
                case 47:
                case 1047:
                    this._terminal.buffers.activateNormalBuffer();
                    this._terminal.refresh(0, this._terminal.rows - 1);
                    this._terminal.viewport.syncScrollArea();
                    this._terminal.showCursor();
                    break;
                case 2004:
                    this._terminal.bracketedPasteMode = false;
                    break;
            }
        }
    };
    InputHandler.prototype.charAttributes = function (params) {
        if (params.length === 1 && params[0] === 0) {
            this._terminal.curAttr = Buffer_1.DEFAULT_ATTR;
            return;
        }
        var l = params.length;
        var flags = this._terminal.curAttr >> 18;
        var fg = (this._terminal.curAttr >> 9) & 0x1ff;
        var bg = this._terminal.curAttr & 0x1ff;
        var p;
        for (var i = 0; i < l; i++) {
            p = params[i];
            if (p >= 30 && p <= 37) {
                fg = p - 30;
            }
            else if (p >= 40 && p <= 47) {
                bg = p - 40;
            }
            else if (p >= 90 && p <= 97) {
                p += 8;
                fg = p - 90;
            }
            else if (p >= 100 && p <= 107) {
                p += 8;
                bg = p - 100;
            }
            else if (p === 0) {
                flags = Buffer_1.DEFAULT_ATTR >> 18;
                fg = (Buffer_1.DEFAULT_ATTR >> 9) & 0x1ff;
                bg = Buffer_1.DEFAULT_ATTR & 0x1ff;
            }
            else if (p === 1) {
                flags |= 1;
            }
            else if (p === 3) {
                flags |= 64;
            }
            else if (p === 4) {
                flags |= 2;
            }
            else if (p === 5) {
                flags |= 4;
            }
            else if (p === 7) {
                flags |= 8;
            }
            else if (p === 8) {
                flags |= 16;
            }
            else if (p === 2) {
                flags |= 32;
            }
            else if (p === 22) {
                flags &= ~1;
                flags &= ~32;
            }
            else if (p === 23) {
                flags &= ~64;
            }
            else if (p === 24) {
                flags &= ~2;
            }
            else if (p === 25) {
                flags &= ~4;
            }
            else if (p === 27) {
                flags &= ~8;
            }
            else if (p === 28) {
                flags &= ~16;
            }
            else if (p === 39) {
                fg = (Buffer_1.DEFAULT_ATTR >> 9) & 0x1ff;
            }
            else if (p === 49) {
                bg = Buffer_1.DEFAULT_ATTR & 0x1ff;
            }
            else if (p === 38) {
                if (params[i + 1] === 2) {
                    i += 2;
                    fg = this._terminal.matchColor(params[i] & 0xff, params[i + 1] & 0xff, params[i + 2] & 0xff);
                    if (fg === -1)
                        fg = 0x1ff;
                    i += 2;
                }
                else if (params[i + 1] === 5) {
                    i += 2;
                    p = params[i] & 0xff;
                    fg = p;
                }
            }
            else if (p === 48) {
                if (params[i + 1] === 2) {
                    i += 2;
                    bg = this._terminal.matchColor(params[i] & 0xff, params[i + 1] & 0xff, params[i + 2] & 0xff);
                    if (bg === -1)
                        bg = 0x1ff;
                    i += 2;
                }
                else if (params[i + 1] === 5) {
                    i += 2;
                    p = params[i] & 0xff;
                    bg = p;
                }
            }
            else if (p === 100) {
                fg = (Buffer_1.DEFAULT_ATTR >> 9) & 0x1ff;
                bg = Buffer_1.DEFAULT_ATTR & 0x1ff;
            }
            else {
                this._terminal.error('Unknown SGR attribute: %d.', p);
            }
        }
        this._terminal.curAttr = (flags << 18) | (fg << 9) | bg;
    };
    InputHandler.prototype.deviceStatus = function (params, collect) {
        if (!collect) {
            switch (params[0]) {
                case 5:
                    this._terminal.emit('data', EscapeSequences_1.C0.ESC + "[0n");
                    break;
                case 6:
                    var y = this._terminal.buffer.y + 1;
                    var x = this._terminal.buffer.x + 1;
                    this._terminal.emit('data', EscapeSequences_1.C0.ESC + "[" + y + ";" + x + "R");
                    break;
            }
        }
        else if (collect === '?') {
            switch (params[0]) {
                case 6:
                    var y = this._terminal.buffer.y + 1;
                    var x = this._terminal.buffer.x + 1;
                    this._terminal.emit('data', EscapeSequences_1.C0.ESC + "[?" + y + ";" + x + "R");
                    break;
                case 15:
                    break;
                case 25:
                    break;
                case 26:
                    break;
                case 53:
                    break;
            }
        }
    };
    InputHandler.prototype.softReset = function (params, collect) {
        if (collect === '!') {
            this._terminal.cursorHidden = false;
            this._terminal.insertMode = false;
            this._terminal.originMode = false;
            this._terminal.wraparoundMode = true;
            this._terminal.applicationKeypad = false;
            this._terminal.viewport.syncScrollArea();
            this._terminal.applicationCursor = false;
            this._terminal.buffer.scrollTop = 0;
            this._terminal.buffer.scrollBottom = this._terminal.rows - 1;
            this._terminal.curAttr = Buffer_1.DEFAULT_ATTR;
            this._terminal.buffer.x = this._terminal.buffer.y = 0;
            this._terminal.charset = null;
            this._terminal.glevel = 0;
            this._terminal.charsets = [null];
        }
    };
    InputHandler.prototype.setCursorStyle = function (params, collect) {
        if (collect === ' ') {
            var param = params[0] < 1 ? 1 : params[0];
            switch (param) {
                case 1:
                case 2:
                    this._terminal.setOption('cursorStyle', 'block');
                    break;
                case 3:
                case 4:
                    this._terminal.setOption('cursorStyle', 'underline');
                    break;
                case 5:
                case 6:
                    this._terminal.setOption('cursorStyle', 'bar');
                    break;
            }
            var isBlinking = param % 2 === 1;
            this._terminal.setOption('cursorBlink', isBlinking);
        }
    };
    InputHandler.prototype.setScrollRegion = function (params, collect) {
        if (collect)
            return;
        this._terminal.buffer.scrollTop = (params[0] || 1) - 1;
        this._terminal.buffer.scrollBottom = (params[1] && params[1] <= this._terminal.rows ? params[1] : this._terminal.rows) - 1;
        this._terminal.buffer.x = 0;
        this._terminal.buffer.y = 0;
    };
    InputHandler.prototype.saveCursor = function (params) {
        this._terminal.buffer.savedX = this._terminal.buffer.x;
        this._terminal.buffer.savedY = this._terminal.buffer.y;
        this._terminal.savedCurAttr = this._terminal.curAttr;
    };
    InputHandler.prototype.restoreCursor = function (params) {
        this._terminal.buffer.x = this._terminal.buffer.savedX || 0;
        this._terminal.buffer.y = this._terminal.buffer.savedY || 0;
        this._terminal.curAttr = this._terminal.savedCurAttr || Buffer_1.DEFAULT_ATTR;
    };
    InputHandler.prototype.setTitle = function (data) {
        this._terminal.handleTitle(data);
    };
    InputHandler.prototype.nextLine = function () {
        this._terminal.buffer.x = 0;
        this.index();
    };
    InputHandler.prototype.keypadApplicationMode = function () {
        this._terminal.log('Serial port requested application keypad.');
        this._terminal.applicationKeypad = true;
        if (this._terminal.viewport) {
            this._terminal.viewport.syncScrollArea();
        }
    };
    InputHandler.prototype.keypadNumericMode = function () {
        this._terminal.log('Switching back to normal keypad.');
        this._terminal.applicationKeypad = false;
        if (this._terminal.viewport) {
            this._terminal.viewport.syncScrollArea();
        }
    };
    InputHandler.prototype.selectDefaultCharset = function () {
        this._terminal.setgLevel(0);
        this._terminal.setgCharset(0, Charsets_1.DEFAULT_CHARSET);
    };
    InputHandler.prototype.selectCharset = function (collectAndFlag) {
        if (collectAndFlag.length !== 2)
            return this.selectDefaultCharset();
        if (collectAndFlag[0] === '/')
            return;
        this._terminal.setgCharset(GLEVEL[collectAndFlag[0]], Charsets_1.CHARSETS[collectAndFlag[1]] || Charsets_1.DEFAULT_CHARSET);
    };
    InputHandler.prototype.index = function () {
        this._terminal.index();
    };
    InputHandler.prototype.tabSet = function () {
        this._terminal.tabSet();
    };
    InputHandler.prototype.reverseIndex = function () {
        this._terminal.reverseIndex();
    };
    InputHandler.prototype.reset = function () {
        this._parser.reset();
        this._terminal.reset();
    };
    InputHandler.prototype.setgLevel = function (level) {
        this._terminal.setgLevel(level);
    };
    return InputHandler;
}(Lifecycle_1.Disposable));
exports.InputHandler = InputHandler;
//# sourceMappingURL=InputHandler.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/Linkifier.js":
/*!*********************************************!*\
  !*** ./node_modules/xterm/lib/Linkifier.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var MouseZoneManager_1 = __webpack_require__(/*! ./ui/MouseZoneManager */ "./node_modules/xterm/lib/ui/MouseZoneManager.js");
var EventEmitter_1 = __webpack_require__(/*! ./common/EventEmitter */ "./node_modules/xterm/lib/common/EventEmitter.js");
var Buffer_1 = __webpack_require__(/*! ./Buffer */ "./node_modules/xterm/lib/Buffer.js");
var CharWidth_1 = __webpack_require__(/*! ./CharWidth */ "./node_modules/xterm/lib/CharWidth.js");
var Linkifier = (function (_super) {
    __extends(Linkifier, _super);
    function Linkifier(_terminal) {
        var _this = _super.call(this) || this;
        _this._terminal = _terminal;
        _this._linkMatchers = [];
        _this._nextLinkMatcherId = 0;
        _this._rowsToLinkify = {
            start: null,
            end: null
        };
        return _this;
    }
    Linkifier.prototype.attachToDom = function (mouseZoneManager) {
        this._mouseZoneManager = mouseZoneManager;
    };
    Linkifier.prototype.linkifyRows = function (start, end) {
        var _this = this;
        if (!this._mouseZoneManager) {
            return;
        }
        if (this._rowsToLinkify.start === null) {
            this._rowsToLinkify.start = start;
            this._rowsToLinkify.end = end;
        }
        else {
            this._rowsToLinkify.start = Math.min(this._rowsToLinkify.start, start);
            this._rowsToLinkify.end = Math.max(this._rowsToLinkify.end, end);
        }
        this._mouseZoneManager.clearAll(start, end);
        if (this._rowsTimeoutId) {
            clearTimeout(this._rowsTimeoutId);
        }
        this._rowsTimeoutId = setTimeout(function () { return _this._linkifyRows(); }, Linkifier.TIME_BEFORE_LINKIFY);
    };
    Linkifier.prototype._linkifyRows = function () {
        this._rowsTimeoutId = null;
        var buffer = this._terminal.buffer;
        var absoluteRowIndexStart = buffer.ydisp + this._rowsToLinkify.start;
        if (absoluteRowIndexStart >= buffer.lines.length) {
            return;
        }
        var absoluteRowIndexEnd = buffer.ydisp + Math.min(this._rowsToLinkify.end, this._terminal.rows) + 1;
        var overscanLineLimit = Math.ceil(Linkifier.OVERSCAN_CHAR_LIMIT / this._terminal.cols);
        var iterator = this._terminal.buffer.iterator(false, absoluteRowIndexStart, absoluteRowIndexEnd, overscanLineLimit, overscanLineLimit);
        while (iterator.hasNext()) {
            var lineData = iterator.next();
            for (var i = 0; i < this._linkMatchers.length; i++) {
                this._doLinkifyRow(lineData.range.first, lineData.content, this._linkMatchers[i]);
            }
        }
        this._rowsToLinkify.start = null;
        this._rowsToLinkify.end = null;
    };
    Linkifier.prototype.registerLinkMatcher = function (regex, handler, options) {
        if (options === void 0) { options = {}; }
        if (!handler) {
            throw new Error('handler must be defined');
        }
        var matcher = {
            id: this._nextLinkMatcherId++,
            regex: regex,
            handler: handler,
            matchIndex: options.matchIndex,
            validationCallback: options.validationCallback,
            hoverTooltipCallback: options.tooltipCallback,
            hoverLeaveCallback: options.leaveCallback,
            willLinkActivate: options.willLinkActivate,
            priority: options.priority || 0
        };
        this._addLinkMatcherToList(matcher);
        return matcher.id;
    };
    Linkifier.prototype._addLinkMatcherToList = function (matcher) {
        if (this._linkMatchers.length === 0) {
            this._linkMatchers.push(matcher);
            return;
        }
        for (var i = this._linkMatchers.length - 1; i >= 0; i--) {
            if (matcher.priority <= this._linkMatchers[i].priority) {
                this._linkMatchers.splice(i + 1, 0, matcher);
                return;
            }
        }
        this._linkMatchers.splice(0, 0, matcher);
    };
    Linkifier.prototype.deregisterLinkMatcher = function (matcherId) {
        for (var i = 0; i < this._linkMatchers.length; i++) {
            if (this._linkMatchers[i].id === matcherId) {
                this._linkMatchers.splice(i, 1);
                return true;
            }
        }
        return false;
    };
    Linkifier.prototype._doLinkifyRow = function (rowIndex, text, matcher) {
        var _this = this;
        var rex = new RegExp(matcher.regex.source, matcher.regex.flags + 'g');
        var match;
        var stringIndex = -1;
        var _loop_1 = function () {
            var uri = match[typeof matcher.matchIndex !== 'number' ? 0 : matcher.matchIndex];
            if (!uri) {
                if (this_1._terminal.debug) {
                    console.log({ match: match, matcher: matcher });
                    throw new Error('match found without corresponding matchIndex');
                }
                return "break";
            }
            stringIndex = text.indexOf(uri, stringIndex + 1);
            rex.lastIndex = stringIndex + uri.length;
            var bufferIndex = this_1._terminal.buffer.stringIndexToBufferIndex(rowIndex, stringIndex);
            var line = this_1._terminal.buffer.lines.get(bufferIndex[0]);
            var char = line.get(bufferIndex[1]);
            var fg;
            if (char) {
                var attr = char[Buffer_1.CHAR_DATA_ATTR_INDEX];
                fg = (attr >> 9) & 0x1ff;
            }
            if (matcher.validationCallback) {
                matcher.validationCallback(uri, function (isValid) {
                    if (_this._rowsTimeoutId) {
                        return;
                    }
                    if (isValid) {
                        _this._addLink(bufferIndex[1], bufferIndex[0] - _this._terminal.buffer.ydisp, uri, matcher, fg);
                    }
                });
            }
            else {
                this_1._addLink(bufferIndex[1], bufferIndex[0] - this_1._terminal.buffer.ydisp, uri, matcher, fg);
            }
        };
        var this_1 = this;
        while ((match = rex.exec(text)) !== null) {
            var state_1 = _loop_1();
            if (state_1 === "break")
                break;
        }
    };
    Linkifier.prototype._addLink = function (x, y, uri, matcher, fg) {
        var _this = this;
        var width = CharWidth_1.getStringCellWidth(uri);
        var x1 = x % this._terminal.cols;
        var y1 = y + Math.floor(x / this._terminal.cols);
        var x2 = (x1 + width) % this._terminal.cols;
        var y2 = y1 + Math.floor((x1 + width) / this._terminal.cols);
        if (x2 === 0) {
            x2 = this._terminal.cols;
            y2--;
        }
        this._mouseZoneManager.add(new MouseZoneManager_1.MouseZone(x1 + 1, y1 + 1, x2 + 1, y2 + 1, function (e) {
            if (matcher.handler) {
                return matcher.handler(e, uri);
            }
            window.open(uri, '_blank');
        }, function (e) {
            _this.emit("linkhover", _this._createLinkHoverEvent(x1, y1, x2, y2, fg));
            _this._terminal.element.classList.add('xterm-cursor-pointer');
        }, function (e) {
            _this.emit("linktooltip", _this._createLinkHoverEvent(x1, y1, x2, y2, fg));
            if (matcher.hoverTooltipCallback) {
                matcher.hoverTooltipCallback(e, uri);
            }
        }, function () {
            _this.emit("linkleave", _this._createLinkHoverEvent(x1, y1, x2, y2, fg));
            _this._terminal.element.classList.remove('xterm-cursor-pointer');
            if (matcher.hoverLeaveCallback) {
                matcher.hoverLeaveCallback();
            }
        }, function (e) {
            if (matcher.willLinkActivate) {
                return matcher.willLinkActivate(e, uri);
            }
            return true;
        }));
    };
    Linkifier.prototype._createLinkHoverEvent = function (x1, y1, x2, y2, fg) {
        return { x1: x1, y1: y1, x2: x2, y2: y2, cols: this._terminal.cols, fg: fg };
    };
    Linkifier.TIME_BEFORE_LINKIFY = 200;
    Linkifier.OVERSCAN_CHAR_LIMIT = 2000;
    return Linkifier;
}(EventEmitter_1.EventEmitter));
exports.Linkifier = Linkifier;
//# sourceMappingURL=Linkifier.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/SelectionManager.js":
/*!****************************************************!*\
  !*** ./node_modules/xterm/lib/SelectionManager.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var MouseHelper_1 = __webpack_require__(/*! ./utils/MouseHelper */ "./node_modules/xterm/lib/utils/MouseHelper.js");
var Browser = __webpack_require__(/*! ./shared/utils/Browser */ "./node_modules/xterm/lib/shared/utils/Browser.js");
var EventEmitter_1 = __webpack_require__(/*! ./common/EventEmitter */ "./node_modules/xterm/lib/common/EventEmitter.js");
var SelectionModel_1 = __webpack_require__(/*! ./SelectionModel */ "./node_modules/xterm/lib/SelectionModel.js");
var Buffer_1 = __webpack_require__(/*! ./Buffer */ "./node_modules/xterm/lib/Buffer.js");
var AltClickHandler_1 = __webpack_require__(/*! ./handlers/AltClickHandler */ "./node_modules/xterm/lib/handlers/AltClickHandler.js");
var DRAG_SCROLL_MAX_THRESHOLD = 50;
var DRAG_SCROLL_MAX_SPEED = 15;
var DRAG_SCROLL_INTERVAL = 50;
var ALT_CLICK_MOVE_CURSOR_TIME = 500;
var WORD_SEPARATORS = ' ()[]{}\'"';
var NON_BREAKING_SPACE_CHAR = String.fromCharCode(160);
var ALL_NON_BREAKING_SPACE_REGEX = new RegExp(NON_BREAKING_SPACE_CHAR, 'g');
var SelectionManager = (function (_super) {
    __extends(SelectionManager, _super);
    function SelectionManager(_terminal, _charMeasure) {
        var _this = _super.call(this) || this;
        _this._terminal = _terminal;
        _this._charMeasure = _charMeasure;
        _this._enabled = true;
        _this._initListeners();
        _this.enable();
        _this._model = new SelectionModel_1.SelectionModel(_terminal);
        _this._activeSelectionMode = 0;
        return _this;
    }
    SelectionManager.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._removeMouseDownListeners();
    };
    Object.defineProperty(SelectionManager.prototype, "_buffer", {
        get: function () {
            return this._terminal.buffers.active;
        },
        enumerable: true,
        configurable: true
    });
    SelectionManager.prototype._initListeners = function () {
        var _this = this;
        this._mouseMoveListener = function (event) { return _this._onMouseMove(event); };
        this._mouseUpListener = function (event) { return _this._onMouseUp(event); };
        this._trimListener = function (amount) { return _this._onTrim(amount); };
        this.initBuffersListeners();
    };
    SelectionManager.prototype.initBuffersListeners = function () {
        var _this = this;
        this._terminal.buffer.lines.on('trim', this._trimListener);
        this._terminal.buffers.on('activate', function (e) { return _this._onBufferActivate(e); });
    };
    SelectionManager.prototype.disable = function () {
        this.clearSelection();
        this._enabled = false;
    };
    SelectionManager.prototype.enable = function () {
        this._enabled = true;
    };
    Object.defineProperty(SelectionManager.prototype, "selectionStart", {
        get: function () { return this._model.finalSelectionStart; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionManager.prototype, "selectionEnd", {
        get: function () { return this._model.finalSelectionEnd; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionManager.prototype, "hasSelection", {
        get: function () {
            var start = this._model.finalSelectionStart;
            var end = this._model.finalSelectionEnd;
            if (!start || !end) {
                return false;
            }
            return start[0] !== end[0] || start[1] !== end[1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionManager.prototype, "selectionText", {
        get: function () {
            var start = this._model.finalSelectionStart;
            var end = this._model.finalSelectionEnd;
            if (!start || !end) {
                return '';
            }
            var result = [];
            if (this._activeSelectionMode === 3) {
                if (start[0] === end[0]) {
                    return '';
                }
                for (var i = start[1]; i <= end[1]; i++) {
                    var lineText = this._buffer.translateBufferLineToString(i, true, start[0], end[0]);
                    result.push(lineText);
                }
            }
            else {
                var startRowEndCol = start[1] === end[1] ? end[0] : null;
                result.push(this._buffer.translateBufferLineToString(start[1], true, start[0], startRowEndCol));
                for (var i = start[1] + 1; i <= end[1] - 1; i++) {
                    var bufferLine = this._buffer.lines.get(i);
                    var lineText = this._buffer.translateBufferLineToString(i, true);
                    if (bufferLine.isWrapped) {
                        result[result.length - 1] += lineText;
                    }
                    else {
                        result.push(lineText);
                    }
                }
                if (start[1] !== end[1]) {
                    var bufferLine = this._buffer.lines.get(end[1]);
                    var lineText = this._buffer.translateBufferLineToString(end[1], true, 0, end[0]);
                    if (bufferLine.isWrapped) {
                        result[result.length - 1] += lineText;
                    }
                    else {
                        result.push(lineText);
                    }
                }
            }
            var formattedResult = result.map(function (line) {
                return line.replace(ALL_NON_BREAKING_SPACE_REGEX, ' ');
            }).join(Browser.isMSWindows ? '\r\n' : '\n');
            return formattedResult;
        },
        enumerable: true,
        configurable: true
    });
    SelectionManager.prototype.clearSelection = function () {
        this._model.clearSelection();
        this._removeMouseDownListeners();
        this.refresh();
    };
    SelectionManager.prototype.refresh = function (isNewSelection) {
        var _this = this;
        if (!this._refreshAnimationFrame) {
            this._refreshAnimationFrame = window.requestAnimationFrame(function () { return _this._refresh(); });
        }
        if (Browser.isLinux && isNewSelection) {
            var selectionText = this.selectionText;
            if (selectionText.length) {
                this.emit('newselection', this.selectionText);
            }
        }
    };
    SelectionManager.prototype._refresh = function () {
        this._refreshAnimationFrame = null;
        this.emit('refresh', {
            start: this._model.finalSelectionStart,
            end: this._model.finalSelectionEnd,
            columnSelectMode: this._activeSelectionMode === 3
        });
    };
    SelectionManager.prototype.isClickInSelection = function (event) {
        var coords = this._getMouseBufferCoords(event);
        var start = this._model.finalSelectionStart;
        var end = this._model.finalSelectionEnd;
        if (!start || !end) {
            return false;
        }
        return (coords[1] > start[1] && coords[1] < end[1]) ||
            (start[1] === end[1] && coords[1] === start[1] && coords[0] > start[0] && coords[0] < end[0]) ||
            (start[1] < end[1] && coords[1] === end[1] && coords[0] < end[0]);
    };
    SelectionManager.prototype.selectWordAtCursor = function (event) {
        var coords = this._getMouseBufferCoords(event);
        if (coords) {
            this._selectWordAt(coords, false);
            this._model.selectionEnd = null;
            this.refresh(true);
        }
    };
    SelectionManager.prototype.selectAll = function () {
        this._model.isSelectAllActive = true;
        this.refresh();
        this._terminal.emit('selection');
    };
    SelectionManager.prototype.selectLines = function (start, end) {
        this._model.clearSelection();
        start = Math.max(start, 0);
        end = Math.min(end, this._terminal.buffer.lines.length - 1);
        this._model.selectionStart = [0, start];
        this._model.selectionEnd = [this._terminal.cols, end];
        this.refresh();
        this._terminal.emit('selection');
    };
    SelectionManager.prototype._onTrim = function (amount) {
        var needsRefresh = this._model.onTrim(amount);
        if (needsRefresh) {
            this.refresh();
        }
    };
    SelectionManager.prototype._getMouseBufferCoords = function (event) {
        var coords = this._terminal.mouseHelper.getCoords(event, this._terminal.screenElement, this._charMeasure, this._terminal.options.lineHeight, this._terminal.cols, this._terminal.rows, true);
        if (!coords) {
            return null;
        }
        coords[0]--;
        coords[1]--;
        coords[1] += this._terminal.buffer.ydisp;
        return coords;
    };
    SelectionManager.prototype._getMouseEventScrollAmount = function (event) {
        var offset = MouseHelper_1.MouseHelper.getCoordsRelativeToElement(event, this._terminal.screenElement)[1];
        var terminalHeight = this._terminal.rows * Math.ceil(this._charMeasure.height * this._terminal.options.lineHeight);
        if (offset >= 0 && offset <= terminalHeight) {
            return 0;
        }
        if (offset > terminalHeight) {
            offset -= terminalHeight;
        }
        offset = Math.min(Math.max(offset, -DRAG_SCROLL_MAX_THRESHOLD), DRAG_SCROLL_MAX_THRESHOLD);
        offset /= DRAG_SCROLL_MAX_THRESHOLD;
        return (offset / Math.abs(offset)) + Math.round(offset * (DRAG_SCROLL_MAX_SPEED - 1));
    };
    SelectionManager.prototype.shouldForceSelection = function (event) {
        if (Browser.isMac) {
            return event.altKey && this._terminal.options.macOptionClickForcesSelection;
        }
        return event.shiftKey;
    };
    SelectionManager.prototype.onMouseDown = function (event) {
        this._mouseDownTimeStamp = event.timeStamp;
        if (event.button === 2 && this.hasSelection) {
            return;
        }
        if (event.button !== 0) {
            return;
        }
        if (!this._enabled) {
            if (!this.shouldForceSelection(event)) {
                return;
            }
            event.stopPropagation();
        }
        event.preventDefault();
        this._dragScrollAmount = 0;
        if (this._enabled && event.shiftKey) {
            this._onIncrementalClick(event);
        }
        else {
            if (event.detail === 1) {
                this._onSingleClick(event);
            }
            else if (event.detail === 2) {
                this._onDoubleClick(event);
            }
            else if (event.detail === 3) {
                this._onTripleClick(event);
            }
        }
        this._addMouseDownListeners();
        this.refresh(true);
    };
    SelectionManager.prototype._addMouseDownListeners = function () {
        var _this = this;
        this._terminal.element.ownerDocument.addEventListener('mousemove', this._mouseMoveListener);
        this._terminal.element.ownerDocument.addEventListener('mouseup', this._mouseUpListener);
        this._dragScrollIntervalTimer = setInterval(function () { return _this._dragScroll(); }, DRAG_SCROLL_INTERVAL);
    };
    SelectionManager.prototype._removeMouseDownListeners = function () {
        if (this._terminal.element.ownerDocument) {
            this._terminal.element.ownerDocument.removeEventListener('mousemove', this._mouseMoveListener);
            this._terminal.element.ownerDocument.removeEventListener('mouseup', this._mouseUpListener);
        }
        clearInterval(this._dragScrollIntervalTimer);
        this._dragScrollIntervalTimer = null;
    };
    SelectionManager.prototype._onIncrementalClick = function (event) {
        if (this._model.selectionStart) {
            this._model.selectionEnd = this._getMouseBufferCoords(event);
        }
    };
    SelectionManager.prototype._onSingleClick = function (event) {
        this._model.selectionStartLength = 0;
        this._model.isSelectAllActive = false;
        this._activeSelectionMode = this.shouldColumnSelect(event) ? 3 : 0;
        this._model.selectionStart = this._getMouseBufferCoords(event);
        if (!this._model.selectionStart) {
            return;
        }
        this._model.selectionEnd = null;
        var line = this._buffer.lines.get(this._model.selectionStart[1]);
        if (!line) {
            return;
        }
        if (line.length >= this._model.selectionStart[0]) {
            return;
        }
        var char = line.get(this._model.selectionStart[0]);
        if (char[Buffer_1.CHAR_DATA_WIDTH_INDEX] === 0) {
            this._model.selectionStart[0]++;
        }
    };
    SelectionManager.prototype._onDoubleClick = function (event) {
        var coords = this._getMouseBufferCoords(event);
        if (coords) {
            this._activeSelectionMode = 1;
            this._selectWordAt(coords, true);
        }
    };
    SelectionManager.prototype._onTripleClick = function (event) {
        var coords = this._getMouseBufferCoords(event);
        if (coords) {
            this._activeSelectionMode = 2;
            this._selectLineAt(coords[1]);
        }
    };
    SelectionManager.prototype.shouldColumnSelect = function (event) {
        return event.altKey && !(Browser.isMac && this._terminal.options.macOptionClickForcesSelection);
    };
    SelectionManager.prototype._onMouseMove = function (event) {
        event.stopImmediatePropagation();
        var previousSelectionEnd = this._model.selectionEnd ? [this._model.selectionEnd[0], this._model.selectionEnd[1]] : null;
        this._model.selectionEnd = this._getMouseBufferCoords(event);
        if (!this._model.selectionEnd) {
            this.refresh(true);
            return;
        }
        if (this._activeSelectionMode === 2) {
            if (this._model.selectionEnd[1] < this._model.selectionStart[1]) {
                this._model.selectionEnd[0] = 0;
            }
            else {
                this._model.selectionEnd[0] = this._terminal.cols;
            }
        }
        else if (this._activeSelectionMode === 1) {
            this._selectToWordAt(this._model.selectionEnd);
        }
        this._dragScrollAmount = this._getMouseEventScrollAmount(event);
        if (this._activeSelectionMode !== 3) {
            if (this._dragScrollAmount > 0) {
                this._model.selectionEnd[0] = this._terminal.cols;
            }
            else if (this._dragScrollAmount < 0) {
                this._model.selectionEnd[0] = 0;
            }
        }
        if (this._model.selectionEnd[1] < this._buffer.lines.length) {
            var char = this._buffer.lines.get(this._model.selectionEnd[1]).get(this._model.selectionEnd[0]);
            if (char && char[Buffer_1.CHAR_DATA_WIDTH_INDEX] === 0) {
                this._model.selectionEnd[0]++;
            }
        }
        if (!previousSelectionEnd ||
            previousSelectionEnd[0] !== this._model.selectionEnd[0] ||
            previousSelectionEnd[1] !== this._model.selectionEnd[1]) {
            this.refresh(true);
        }
    };
    SelectionManager.prototype._dragScroll = function () {
        if (this._dragScrollAmount) {
            this._terminal.scrollLines(this._dragScrollAmount, false);
            if (this._dragScrollAmount > 0) {
                if (this._activeSelectionMode !== 3) {
                    this._model.selectionEnd[0] = this._terminal.cols;
                }
                this._model.selectionEnd[1] = Math.min(this._terminal.buffer.ydisp + this._terminal.rows, this._terminal.buffer.lines.length - 1);
            }
            else {
                if (this._activeSelectionMode !== 3) {
                    this._model.selectionEnd[0] = 0;
                }
                this._model.selectionEnd[1] = this._terminal.buffer.ydisp;
            }
            this.refresh();
        }
    };
    SelectionManager.prototype._onMouseUp = function (event) {
        var timeElapsed = event.timeStamp - this._mouseDownTimeStamp;
        this._removeMouseDownListeners();
        if (this.selectionText.length <= 1 && timeElapsed < ALT_CLICK_MOVE_CURSOR_TIME) {
            (new AltClickHandler_1.AltClickHandler(event, this._terminal)).move();
        }
        else if (this.hasSelection) {
            this._terminal.emit('selection');
        }
    };
    SelectionManager.prototype._onBufferActivate = function (e) {
        this.clearSelection();
        e.inactiveBuffer.lines.off('trim', this._trimListener);
        e.activeBuffer.lines.on('trim', this._trimListener);
    };
    SelectionManager.prototype._convertViewportColToCharacterIndex = function (bufferLine, coords) {
        var charIndex = coords[0];
        for (var i = 0; coords[0] >= i; i++) {
            var char = bufferLine.get(i);
            if (char[Buffer_1.CHAR_DATA_WIDTH_INDEX] === 0) {
                charIndex--;
            }
            else if (char[Buffer_1.CHAR_DATA_CHAR_INDEX].length > 1 && coords[0] !== i) {
                charIndex += char[Buffer_1.CHAR_DATA_CHAR_INDEX].length - 1;
            }
        }
        return charIndex;
    };
    SelectionManager.prototype.setSelection = function (col, row, length) {
        this._model.clearSelection();
        this._removeMouseDownListeners();
        this._model.selectionStart = [col, row];
        this._model.selectionStartLength = length;
        this.refresh();
    };
    SelectionManager.prototype._getWordAt = function (coords, allowWhitespaceOnlySelection, followWrappedLinesAbove, followWrappedLinesBelow) {
        if (followWrappedLinesAbove === void 0) { followWrappedLinesAbove = true; }
        if (followWrappedLinesBelow === void 0) { followWrappedLinesBelow = true; }
        if (coords[0] >= this._terminal.cols) {
            return null;
        }
        var bufferLine = this._buffer.lines.get(coords[1]);
        if (!bufferLine) {
            return null;
        }
        var line = this._buffer.translateBufferLineToString(coords[1], false);
        var startIndex = this._convertViewportColToCharacterIndex(bufferLine, coords);
        var endIndex = startIndex;
        var charOffset = coords[0] - startIndex;
        var leftWideCharCount = 0;
        var rightWideCharCount = 0;
        var leftLongCharOffset = 0;
        var rightLongCharOffset = 0;
        if (line.charAt(startIndex) === ' ') {
            while (startIndex > 0 && line.charAt(startIndex - 1) === ' ') {
                startIndex--;
            }
            while (endIndex < line.length && line.charAt(endIndex + 1) === ' ') {
                endIndex++;
            }
        }
        else {
            var startCol = coords[0];
            var endCol = coords[0];
            if (bufferLine.get(startCol)[Buffer_1.CHAR_DATA_WIDTH_INDEX] === 0) {
                leftWideCharCount++;
                startCol--;
            }
            if (bufferLine.get(endCol)[Buffer_1.CHAR_DATA_WIDTH_INDEX] === 2) {
                rightWideCharCount++;
                endCol++;
            }
            if (bufferLine.get(endCol)[Buffer_1.CHAR_DATA_CHAR_INDEX].length > 1) {
                rightLongCharOffset += bufferLine.get(endCol)[Buffer_1.CHAR_DATA_CHAR_INDEX].length - 1;
                endIndex += bufferLine.get(endCol)[Buffer_1.CHAR_DATA_CHAR_INDEX].length - 1;
            }
            while (startCol > 0 && startIndex > 0 && !this._isCharWordSeparator(bufferLine.get(startCol - 1))) {
                var char = bufferLine.get(startCol - 1);
                if (char[Buffer_1.CHAR_DATA_WIDTH_INDEX] === 0) {
                    leftWideCharCount++;
                    startCol--;
                }
                else if (char[Buffer_1.CHAR_DATA_CHAR_INDEX].length > 1) {
                    leftLongCharOffset += char[Buffer_1.CHAR_DATA_CHAR_INDEX].length - 1;
                    startIndex -= char[Buffer_1.CHAR_DATA_CHAR_INDEX].length - 1;
                }
                startIndex--;
                startCol--;
            }
            while (endCol < bufferLine.length && endIndex + 1 < line.length && !this._isCharWordSeparator(bufferLine.get(endCol + 1))) {
                var char = bufferLine.get(endCol + 1);
                if (char[Buffer_1.CHAR_DATA_WIDTH_INDEX] === 2) {
                    rightWideCharCount++;
                    endCol++;
                }
                else if (char[Buffer_1.CHAR_DATA_CHAR_INDEX].length > 1) {
                    rightLongCharOffset += char[Buffer_1.CHAR_DATA_CHAR_INDEX].length - 1;
                    endIndex += char[Buffer_1.CHAR_DATA_CHAR_INDEX].length - 1;
                }
                endIndex++;
                endCol++;
            }
        }
        endIndex++;
        var start = startIndex
            + charOffset
            - leftWideCharCount
            + leftLongCharOffset;
        var length = Math.min(this._terminal.cols, endIndex
            - startIndex
            + leftWideCharCount
            + rightWideCharCount
            - leftLongCharOffset
            - rightLongCharOffset);
        if (!allowWhitespaceOnlySelection && line.slice(startIndex, endIndex).trim() === '') {
            return null;
        }
        if (followWrappedLinesAbove) {
            if (start === 0 && bufferLine.get(0)[Buffer_1.CHAR_DATA_CODE_INDEX] !== 32) {
                var previousBufferLine = this._buffer.lines.get(coords[1] - 1);
                if (previousBufferLine && bufferLine.isWrapped && previousBufferLine.get(this._terminal.cols - 1)[Buffer_1.CHAR_DATA_CODE_INDEX] !== 32) {
                    var previousLineWordPosition = this._getWordAt([this._terminal.cols - 1, coords[1] - 1], false, true, false);
                    if (previousLineWordPosition) {
                        var offset = this._terminal.cols - previousLineWordPosition.start;
                        start -= offset;
                        length += offset;
                    }
                }
            }
        }
        if (followWrappedLinesBelow) {
            if (start + length === this._terminal.cols && bufferLine.get(this._terminal.cols - 1)[Buffer_1.CHAR_DATA_CODE_INDEX] !== 32) {
                var nextBufferLine = this._buffer.lines.get(coords[1] + 1);
                if (nextBufferLine && nextBufferLine.isWrapped && nextBufferLine.get(0)[Buffer_1.CHAR_DATA_CODE_INDEX] !== 32) {
                    var nextLineWordPosition = this._getWordAt([0, coords[1] + 1], false, false, true);
                    if (nextLineWordPosition) {
                        length += nextLineWordPosition.length;
                    }
                }
            }
        }
        return { start: start, length: length };
    };
    SelectionManager.prototype._selectWordAt = function (coords, allowWhitespaceOnlySelection) {
        var wordPosition = this._getWordAt(coords, allowWhitespaceOnlySelection);
        if (wordPosition) {
            while (wordPosition.start < 0) {
                wordPosition.start += this._terminal.cols;
                coords[1]--;
            }
            this._model.selectionStart = [wordPosition.start, coords[1]];
            this._model.selectionStartLength = wordPosition.length;
        }
    };
    SelectionManager.prototype._selectToWordAt = function (coords) {
        var wordPosition = this._getWordAt(coords, true);
        if (wordPosition) {
            var endRow = coords[1];
            while (wordPosition.start < 0) {
                wordPosition.start += this._terminal.cols;
                endRow--;
            }
            if (!this._model.areSelectionValuesReversed()) {
                while (wordPosition.start + wordPosition.length > this._terminal.cols) {
                    wordPosition.length -= this._terminal.cols;
                    endRow++;
                }
            }
            this._model.selectionEnd = [this._model.areSelectionValuesReversed() ? wordPosition.start : wordPosition.start + wordPosition.length, endRow];
        }
    };
    SelectionManager.prototype._isCharWordSeparator = function (charData) {
        if (charData[Buffer_1.CHAR_DATA_WIDTH_INDEX] === 0) {
            return false;
        }
        return WORD_SEPARATORS.indexOf(charData[Buffer_1.CHAR_DATA_CHAR_INDEX]) >= 0;
    };
    SelectionManager.prototype._selectLineAt = function (line) {
        var wrappedRange = this._buffer.getWrappedRangeForLine(line);
        this._model.selectionStart = [0, wrappedRange.first];
        this._model.selectionEnd = [this._terminal.cols, wrappedRange.last];
        this._model.selectionStartLength = 0;
    };
    return SelectionManager;
}(EventEmitter_1.EventEmitter));
exports.SelectionManager = SelectionManager;
//# sourceMappingURL=SelectionManager.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/SelectionModel.js":
/*!**************************************************!*\
  !*** ./node_modules/xterm/lib/SelectionModel.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var SelectionModel = (function () {
    function SelectionModel(_terminal) {
        this._terminal = _terminal;
        this.clearSelection();
    }
    SelectionModel.prototype.clearSelection = function () {
        this.selectionStart = null;
        this.selectionEnd = null;
        this.isSelectAllActive = false;
        this.selectionStartLength = 0;
    };
    Object.defineProperty(SelectionModel.prototype, "finalSelectionStart", {
        get: function () {
            if (this.isSelectAllActive) {
                return [0, 0];
            }
            if (!this.selectionEnd || !this.selectionStart) {
                return this.selectionStart;
            }
            return this.areSelectionValuesReversed() ? this.selectionEnd : this.selectionStart;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionModel.prototype, "finalSelectionEnd", {
        get: function () {
            if (this.isSelectAllActive) {
                return [this._terminal.cols, this._terminal.buffer.ybase + this._terminal.rows - 1];
            }
            if (!this.selectionStart) {
                return null;
            }
            if (!this.selectionEnd || this.areSelectionValuesReversed()) {
                var startPlusLength = this.selectionStart[0] + this.selectionStartLength;
                if (startPlusLength > this._terminal.cols) {
                    return [startPlusLength % this._terminal.cols, this.selectionStart[1] + Math.floor(startPlusLength / this._terminal.cols)];
                }
                return [startPlusLength, this.selectionStart[1]];
            }
            if (this.selectionStartLength) {
                if (this.selectionEnd[1] === this.selectionStart[1]) {
                    return [Math.max(this.selectionStart[0] + this.selectionStartLength, this.selectionEnd[0]), this.selectionEnd[1]];
                }
            }
            return this.selectionEnd;
        },
        enumerable: true,
        configurable: true
    });
    SelectionModel.prototype.areSelectionValuesReversed = function () {
        var start = this.selectionStart;
        var end = this.selectionEnd;
        if (!start || !end) {
            return false;
        }
        return start[1] > end[1] || (start[1] === end[1] && start[0] > end[0]);
    };
    SelectionModel.prototype.onTrim = function (amount) {
        if (this.selectionStart) {
            this.selectionStart[1] -= amount;
        }
        if (this.selectionEnd) {
            this.selectionEnd[1] -= amount;
        }
        if (this.selectionEnd && this.selectionEnd[1] < 0) {
            this.clearSelection();
            return true;
        }
        if (this.selectionStart && this.selectionStart[1] < 0) {
            this.selectionStart[1] = 0;
        }
        return false;
    };
    return SelectionModel;
}());
exports.SelectionModel = SelectionModel;
//# sourceMappingURL=SelectionModel.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/SoundManager.js":
/*!************************************************!*\
  !*** ./node_modules/xterm/lib/SoundManager.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_BELL_SOUND = 'data:audio/wav;base64,UklGRigBAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQBAADpAFgCwAMlBZoG/wdmCcoKRAypDQ8PbRDBEQQTOxRtFYcWlBePGIUZXhoiG88bcBz7HHIdzh0WHlMeZx51HmkeUx4WHs8dah0AHXwc3hs9G4saxRnyGBIYGBcQFv8U4RPAEoYRQBACD70NWwwHC6gJOwjWBloF7gOBAhABkf8b/qv8R/ve+Xf4Ife79W/0JfPZ8Z/wde9N7ijtE+wU6xvqM+lb6H7nw+YX5mrlxuQz5Mzje+Ma49fioeKD4nXiYeJy4pHitOL04j/jn+MN5IPkFOWs5U3mDefM55/ogOl36m7rdOyE7abuyu8D8Unyj/Pg9D/2qfcb+Yn6/vuK/Qj/lAAlAg==';
var SoundManager = (function () {
    function SoundManager(_terminal) {
        this._terminal = _terminal;
    }
    SoundManager.prototype.playBellSound = function () {
        var audioContextCtor = window.AudioContext || window.webkitAudioContext;
        if (!this._audioContext && audioContextCtor) {
            this._audioContext = new audioContextCtor();
        }
        if (this._audioContext) {
            var bellAudioSource_1 = this._audioContext.createBufferSource();
            var context_1 = this._audioContext;
            this._audioContext.decodeAudioData(this._base64ToArrayBuffer(this._removeMimeType(this._terminal.options.bellSound)), function (buffer) {
                bellAudioSource_1.buffer = buffer;
                bellAudioSource_1.connect(context_1.destination);
                bellAudioSource_1.start(0);
            });
        }
        else {
            console.warn('Sorry, but the Web Audio API is not supported by your browser. Please, consider upgrading to the latest version');
        }
    };
    SoundManager.prototype._base64ToArrayBuffer = function (base64) {
        var binaryString = window.atob(base64);
        var len = binaryString.length;
        var bytes = new Uint8Array(len);
        for (var i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
    };
    SoundManager.prototype._removeMimeType = function (dataURI) {
        var splitUri = dataURI.split(',');
        return splitUri[1];
    };
    return SoundManager;
}());
exports.SoundManager = SoundManager;
//# sourceMappingURL=SoundManager.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/Strings.js":
/*!*******************************************!*\
  !*** ./node_modules/xterm/lib/Strings.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.blankLine = 'Blank line';
exports.promptLabel = 'Terminal input';
exports.tooMuchOutput = 'Too much output to announce, navigate to rows manually to read';
//# sourceMappingURL=Strings.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/Terminal.js":
/*!********************************************!*\
  !*** ./node_modules/xterm/lib/Terminal.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BufferSet_1 = __webpack_require__(/*! ./BufferSet */ "./node_modules/xterm/lib/BufferSet.js");
var Buffer_1 = __webpack_require__(/*! ./Buffer */ "./node_modules/xterm/lib/Buffer.js");
var CompositionHelper_1 = __webpack_require__(/*! ./CompositionHelper */ "./node_modules/xterm/lib/CompositionHelper.js");
var EventEmitter_1 = __webpack_require__(/*! ./common/EventEmitter */ "./node_modules/xterm/lib/common/EventEmitter.js");
var Viewport_1 = __webpack_require__(/*! ./Viewport */ "./node_modules/xterm/lib/Viewport.js");
var Clipboard_1 = __webpack_require__(/*! ./handlers/Clipboard */ "./node_modules/xterm/lib/handlers/Clipboard.js");
var EscapeSequences_1 = __webpack_require__(/*! ./common/data/EscapeSequences */ "./node_modules/xterm/lib/common/data/EscapeSequences.js");
var InputHandler_1 = __webpack_require__(/*! ./InputHandler */ "./node_modules/xterm/lib/InputHandler.js");
var Renderer_1 = __webpack_require__(/*! ./renderer/Renderer */ "./node_modules/xterm/lib/renderer/Renderer.js");
var Linkifier_1 = __webpack_require__(/*! ./Linkifier */ "./node_modules/xterm/lib/Linkifier.js");
var SelectionManager_1 = __webpack_require__(/*! ./SelectionManager */ "./node_modules/xterm/lib/SelectionManager.js");
var CharMeasure_1 = __webpack_require__(/*! ./ui/CharMeasure */ "./node_modules/xterm/lib/ui/CharMeasure.js");
var Browser = __webpack_require__(/*! ./shared/utils/Browser */ "./node_modules/xterm/lib/shared/utils/Browser.js");
var Lifecycle_1 = __webpack_require__(/*! ./ui/Lifecycle */ "./node_modules/xterm/lib/ui/Lifecycle.js");
var Strings = __webpack_require__(/*! ./Strings */ "./node_modules/xterm/lib/Strings.js");
var MouseHelper_1 = __webpack_require__(/*! ./utils/MouseHelper */ "./node_modules/xterm/lib/utils/MouseHelper.js");
var Clone_1 = __webpack_require__(/*! ./utils/Clone */ "./node_modules/xterm/lib/utils/Clone.js");
var SoundManager_1 = __webpack_require__(/*! ./SoundManager */ "./node_modules/xterm/lib/SoundManager.js");
var ColorManager_1 = __webpack_require__(/*! ./renderer/ColorManager */ "./node_modules/xterm/lib/renderer/ColorManager.js");
var MouseZoneManager_1 = __webpack_require__(/*! ./ui/MouseZoneManager */ "./node_modules/xterm/lib/ui/MouseZoneManager.js");
var AccessibilityManager_1 = __webpack_require__(/*! ./AccessibilityManager */ "./node_modules/xterm/lib/AccessibilityManager.js");
var ScreenDprMonitor_1 = __webpack_require__(/*! ./ui/ScreenDprMonitor */ "./node_modules/xterm/lib/ui/ScreenDprMonitor.js");
var CharAtlasCache_1 = __webpack_require__(/*! ./renderer/atlas/CharAtlasCache */ "./node_modules/xterm/lib/renderer/atlas/CharAtlasCache.js");
var DomRenderer_1 = __webpack_require__(/*! ./renderer/dom/DomRenderer */ "./node_modules/xterm/lib/renderer/dom/DomRenderer.js");
var Keyboard_1 = __webpack_require__(/*! ./core/input/Keyboard */ "./node_modules/xterm/lib/core/input/Keyboard.js");
var BufferLine_1 = __webpack_require__(/*! ./BufferLine */ "./node_modules/xterm/lib/BufferLine.js");
var document = (typeof window !== 'undefined') ? window.document : null;
var WRITE_BUFFER_PAUSE_THRESHOLD = 5;
var WRITE_BATCH_SIZE = 300;
var CONSTRUCTOR_ONLY_OPTIONS = ['cols', 'rows'];
var DEFAULT_OPTIONS = {
    cols: 80,
    rows: 24,
    convertEol: false,
    termName: 'xterm',
    cursorBlink: false,
    cursorStyle: 'block',
    bellSound: SoundManager_1.DEFAULT_BELL_SOUND,
    bellStyle: 'none',
    drawBoldTextInBrightColors: true,
    enableBold: true,
    experimentalCharAtlas: 'static',
    fontFamily: 'courier-new, courier, monospace',
    fontSize: 15,
    fontWeight: 'normal',
    fontWeightBold: 'bold',
    lineHeight: 1.0,
    letterSpacing: 0,
    scrollback: 1000,
    screenKeys: false,
    screenReaderMode: false,
    debug: false,
    macOptionIsMeta: false,
    macOptionClickForcesSelection: false,
    cancelEvents: false,
    disableStdin: false,
    useFlowControl: false,
    allowTransparency: false,
    tabStopWidth: 8,
    theme: null,
    rightClickSelectsWord: Browser.isMac,
    rendererType: 'canvas'
};
var Terminal = (function (_super) {
    __extends(Terminal, _super);
    function Terminal(options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this) || this;
        _this.browser = Browser;
        _this.options = Clone_1.clone(options);
        _this._setup();
        return _this;
    }
    Terminal.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._customKeyEventHandler = null;
        CharAtlasCache_1.removeTerminalFromCache(this);
        this.handler = function () { };
        this.write = function () { };
        if (this.element && this.element.parentNode) {
            this.element.parentNode.removeChild(this.element);
        }
    };
    Terminal.prototype.destroy = function () {
        this.dispose();
    };
    Terminal.prototype._setup = function () {
        var _this = this;
        Object.keys(DEFAULT_OPTIONS).forEach(function (key) {
            if (_this.options[key] === null || _this.options[key] === undefined) {
                _this.options[key] = DEFAULT_OPTIONS[key];
            }
        });
        this._parent = document ? document.body : null;
        this.cols = this.options.cols;
        this.rows = this.options.rows;
        if (this.options.handler) {
            this.on('data', this.options.handler);
        }
        this.cursorState = 0;
        this.cursorHidden = false;
        this._customKeyEventHandler = null;
        this.applicationKeypad = false;
        this.applicationCursor = false;
        this.originMode = false;
        this.insertMode = false;
        this.wraparoundMode = true;
        this.bracketedPasteMode = false;
        this.charset = null;
        this.gcharset = null;
        this.glevel = 0;
        this.charsets = [null];
        this.curAttr = Buffer_1.DEFAULT_ATTR;
        this.params = [];
        this.currentParam = 0;
        this.writeBuffer = [];
        this._writeInProgress = false;
        this._xoffSentToCatchUp = false;
        this._userScrolling = false;
        this._inputHandler = new InputHandler_1.InputHandler(this);
        this.register(this._inputHandler);
        this.renderer = this.renderer || null;
        this.selectionManager = this.selectionManager || null;
        this.linkifier = this.linkifier || new Linkifier_1.Linkifier(this);
        this._mouseZoneManager = this._mouseZoneManager || null;
        this.soundManager = this.soundManager || new SoundManager_1.SoundManager(this);
        this.buffers = new BufferSet_1.BufferSet(this);
        if (this.selectionManager) {
            this.selectionManager.clearSelection();
            this.selectionManager.initBuffersListeners();
        }
    };
    Object.defineProperty(Terminal.prototype, "buffer", {
        get: function () {
            return this.buffers.active;
        },
        enumerable: true,
        configurable: true
    });
    Terminal.prototype.eraseAttr = function () {
        return (Buffer_1.DEFAULT_ATTR & ~0x1ff) | (this.curAttr & 0x1ff);
    };
    Terminal.prototype.focus = function () {
        if (this.textarea) {
            this.textarea.focus();
        }
    };
    Object.defineProperty(Terminal.prototype, "isFocused", {
        get: function () {
            return document.activeElement === this.textarea;
        },
        enumerable: true,
        configurable: true
    });
    Terminal.prototype.getOption = function (key) {
        if (!(key in DEFAULT_OPTIONS)) {
            throw new Error('No option with key "' + key + '"');
        }
        return this.options[key];
    };
    Terminal.prototype.setOption = function (key, value) {
        if (!(key in DEFAULT_OPTIONS)) {
            throw new Error('No option with key "' + key + '"');
        }
        if (CONSTRUCTOR_ONLY_OPTIONS.indexOf(key) !== -1) {
            console.error("Option \"" + key + "\" can only be set in the constructor");
        }
        if (this.options[key] === value) {
            return;
        }
        switch (key) {
            case 'bellStyle':
                if (!value) {
                    value = 'none';
                }
                break;
            case 'cursorStyle':
                if (!value) {
                    value = 'block';
                }
                break;
            case 'fontWeight':
                if (!value) {
                    value = 'normal';
                }
                break;
            case 'fontWeightBold':
                if (!value) {
                    value = 'bold';
                }
                break;
            case 'lineHeight':
                if (value < 1) {
                    console.warn(key + " cannot be less than 1, value: " + value);
                    return;
                }
            case 'rendererType':
                if (!value) {
                    value = 'canvas';
                }
                break;
            case 'tabStopWidth':
                if (value < 1) {
                    console.warn(key + " cannot be less than 1, value: " + value);
                    return;
                }
                break;
            case 'theme':
                if (this.renderer) {
                    this._setTheme(value);
                    return;
                }
                break;
            case 'scrollback':
                value = Math.min(value, Buffer_1.MAX_BUFFER_SIZE);
                if (value < 0) {
                    console.warn(key + " cannot be less than 0, value: " + value);
                    return;
                }
                if (this.options[key] !== value) {
                    var newBufferLength = this.rows + value;
                    if (this.buffer.lines.length > newBufferLength) {
                        var amountToTrim = this.buffer.lines.length - newBufferLength;
                        var needsRefresh = (this.buffer.ydisp - amountToTrim < 0);
                        this.buffer.lines.trimStart(amountToTrim);
                        this.buffer.ybase = Math.max(this.buffer.ybase - amountToTrim, 0);
                        this.buffer.ydisp = Math.max(this.buffer.ydisp - amountToTrim, 0);
                        if (needsRefresh) {
                            this.refresh(0, this.rows - 1);
                        }
                    }
                }
                break;
        }
        this.options[key] = value;
        switch (key) {
            case 'fontFamily':
            case 'fontSize':
                if (this.renderer) {
                    this.renderer.clear();
                    this.charMeasure.measure(this.options);
                }
                break;
            case 'drawBoldTextInBrightColors':
            case 'experimentalCharAtlas':
            case 'enableBold':
            case 'letterSpacing':
            case 'lineHeight':
            case 'fontWeight':
            case 'fontWeightBold':
                if (this.renderer) {
                    this.renderer.clear();
                    this.renderer.onResize(this.cols, this.rows);
                    this.refresh(0, this.rows - 1);
                }
            case 'rendererType':
                if (this.renderer) {
                    this.unregister(this.renderer);
                    this.renderer.dispose();
                    this.renderer = null;
                }
                this._setupRenderer();
                this.renderer.onCharSizeChanged();
                if (this._theme) {
                    this.renderer.setTheme(this._theme);
                }
                break;
            case 'scrollback':
                this.buffers.resize(this.cols, this.rows);
                if (this.viewport) {
                    this.viewport.syncScrollArea();
                }
                break;
            case 'screenReaderMode':
                if (value) {
                    if (!this._accessibilityManager) {
                        this._accessibilityManager = new AccessibilityManager_1.AccessibilityManager(this);
                    }
                }
                else {
                    if (this._accessibilityManager) {
                        this._accessibilityManager.dispose();
                        this._accessibilityManager = null;
                    }
                }
                break;
            case 'tabStopWidth':
                this.buffers.setupTabStops();
                break;
        }
        if (this.renderer) {
            this.renderer.onOptionsChanged();
        }
    };
    Terminal.prototype._onTextAreaFocus = function (ev) {
        if (this.sendFocus) {
            this.handler(EscapeSequences_1.C0.ESC + '[I');
        }
        this.updateCursorStyle(ev);
        this.element.classList.add('focus');
        this.showCursor();
        this.emit('focus');
    };
    Terminal.prototype.blur = function () {
        return this.textarea.blur();
    };
    Terminal.prototype._onTextAreaBlur = function () {
        this.textarea.value = '';
        this.refresh(this.buffer.y, this.buffer.y);
        if (this.sendFocus) {
            this.handler(EscapeSequences_1.C0.ESC + '[O');
        }
        this.element.classList.remove('focus');
        this.emit('blur');
    };
    Terminal.prototype._initGlobal = function () {
        var _this = this;
        this._bindKeys();
        this.register(Lifecycle_1.addDisposableDomListener(this.element, 'copy', function (event) {
            if (!_this.hasSelection()) {
                return;
            }
            Clipboard_1.copyHandler(event, _this, _this.selectionManager);
        }));
        var pasteHandlerWrapper = function (event) { return Clipboard_1.pasteHandler(event, _this); };
        this.register(Lifecycle_1.addDisposableDomListener(this.textarea, 'paste', pasteHandlerWrapper));
        this.register(Lifecycle_1.addDisposableDomListener(this.element, 'paste', pasteHandlerWrapper));
        if (Browser.isFirefox) {
            this.register(Lifecycle_1.addDisposableDomListener(this.element, 'mousedown', function (event) {
                if (event.button === 2) {
                    Clipboard_1.rightClickHandler(event, _this.textarea, _this.selectionManager, _this.options.rightClickSelectsWord);
                }
            }));
        }
        else {
            this.register(Lifecycle_1.addDisposableDomListener(this.element, 'contextmenu', function (event) {
                Clipboard_1.rightClickHandler(event, _this.textarea, _this.selectionManager, _this.options.rightClickSelectsWord);
            }));
        }
        if (Browser.isLinux) {
            this.register(Lifecycle_1.addDisposableDomListener(this.element, 'auxclick', function (event) {
                if (event.button === 1) {
                    Clipboard_1.moveTextAreaUnderMouseCursor(event, _this.textarea);
                }
            }));
        }
    };
    Terminal.prototype._bindKeys = function () {
        var _this = this;
        var self = this;
        this.register(Lifecycle_1.addDisposableDomListener(this.element, 'keydown', function (ev) {
            if (document.activeElement !== this) {
                return;
            }
            self._keyDown(ev);
        }, true));
        this.register(Lifecycle_1.addDisposableDomListener(this.element, 'keypress', function (ev) {
            if (document.activeElement !== this) {
                return;
            }
            self._keyPress(ev);
        }, true));
        this.register(Lifecycle_1.addDisposableDomListener(this.element, 'keyup', function (ev) {
            if (!wasModifierKeyOnlyEvent(ev)) {
                _this.focus();
            }
            self._keyUp(ev);
        }, true));
        this.register(Lifecycle_1.addDisposableDomListener(this.textarea, 'keydown', function (ev) { return _this._keyDown(ev); }, true));
        this.register(Lifecycle_1.addDisposableDomListener(this.textarea, 'keypress', function (ev) { return _this._keyPress(ev); }, true));
        this.register(Lifecycle_1.addDisposableDomListener(this.textarea, 'compositionstart', function () { return _this._compositionHelper.compositionstart(); }));
        this.register(Lifecycle_1.addDisposableDomListener(this.textarea, 'compositionupdate', function (e) { return _this._compositionHelper.compositionupdate(e); }));
        this.register(Lifecycle_1.addDisposableDomListener(this.textarea, 'compositionend', function () { return _this._compositionHelper.compositionend(); }));
        this.register(this.addDisposableListener('refresh', function () { return _this._compositionHelper.updateCompositionElements(); }));
        this.register(this.addDisposableListener('refresh', function (data) { return _this._queueLinkification(data.start, data.end); }));
    };
    Terminal.prototype.open = function (parent) {
        var _this = this;
        this._parent = parent || this._parent;
        if (!this._parent) {
            throw new Error('Terminal requires a parent element.');
        }
        this._context = this._parent.ownerDocument.defaultView;
        this._document = this._parent.ownerDocument;
        this._screenDprMonitor = new ScreenDprMonitor_1.ScreenDprMonitor();
        this._screenDprMonitor.setListener(function () { return _this.emit('dprchange', window.devicePixelRatio); });
        this.register(this._screenDprMonitor);
        this.element = this._document.createElement('div');
        this.element.dir = 'ltr';
        this.element.classList.add('terminal');
        this.element.classList.add('xterm');
        this.element.setAttribute('tabindex', '0');
        this._parent.appendChild(this.element);
        var fragment = document.createDocumentFragment();
        this._viewportElement = document.createElement('div');
        this._viewportElement.classList.add('xterm-viewport');
        fragment.appendChild(this._viewportElement);
        this._viewportScrollArea = document.createElement('div');
        this._viewportScrollArea.classList.add('xterm-scroll-area');
        this._viewportElement.appendChild(this._viewportScrollArea);
        this.screenElement = document.createElement('div');
        this.screenElement.classList.add('xterm-screen');
        this._helperContainer = document.createElement('div');
        this._helperContainer.classList.add('xterm-helpers');
        this.screenElement.appendChild(this._helperContainer);
        fragment.appendChild(this.screenElement);
        this._mouseZoneManager = new MouseZoneManager_1.MouseZoneManager(this);
        this.register(this._mouseZoneManager);
        this.register(this.addDisposableListener('scroll', function () { return _this._mouseZoneManager.clearAll(); }));
        this.linkifier.attachToDom(this._mouseZoneManager);
        this.textarea = document.createElement('textarea');
        this.textarea.classList.add('xterm-helper-textarea');
        this.textarea.setAttribute('aria-label', Strings.promptLabel);
        this.textarea.setAttribute('aria-multiline', 'false');
        this.textarea.setAttribute('autocorrect', 'off');
        this.textarea.setAttribute('autocapitalize', 'off');
        this.textarea.setAttribute('spellcheck', 'false');
        this.textarea.tabIndex = 0;
        this.register(Lifecycle_1.addDisposableDomListener(this.textarea, 'focus', function (ev) { return _this._onTextAreaFocus(ev); }));
        this.register(Lifecycle_1.addDisposableDomListener(this.textarea, 'blur', function () { return _this._onTextAreaBlur(); }));
        this._helperContainer.appendChild(this.textarea);
        this._compositionView = document.createElement('div');
        this._compositionView.classList.add('composition-view');
        this._compositionHelper = new CompositionHelper_1.CompositionHelper(this.textarea, this._compositionView, this);
        this._helperContainer.appendChild(this._compositionView);
        this.charMeasure = new CharMeasure_1.CharMeasure(document, this._helperContainer);
        this.element.appendChild(fragment);
        this._setupRenderer();
        this._theme = this.options.theme;
        this.options.theme = null;
        this.viewport = new Viewport_1.Viewport(this, this._viewportElement, this._viewportScrollArea, this.charMeasure);
        this.viewport.onThemeChanged(this.renderer.colorManager.colors);
        this.register(this.viewport);
        this.register(this.addDisposableListener('cursormove', function () { return _this.renderer.onCursorMove(); }));
        this.register(this.addDisposableListener('resize', function () { return _this.renderer.onResize(_this.cols, _this.rows); }));
        this.register(this.addDisposableListener('blur', function () { return _this.renderer.onBlur(); }));
        this.register(this.addDisposableListener('focus', function () { return _this.renderer.onFocus(); }));
        this.register(this.addDisposableListener('dprchange', function () { return _this.renderer.onWindowResize(window.devicePixelRatio); }));
        this.register(Lifecycle_1.addDisposableDomListener(window, 'resize', function () { return _this.renderer.onWindowResize(window.devicePixelRatio); }));
        this.register(this.charMeasure.addDisposableListener('charsizechanged', function () { return _this.renderer.onCharSizeChanged(); }));
        this.register(this.renderer.addDisposableListener('resize', function (dimensions) { return _this.viewport.syncScrollArea(); }));
        this.selectionManager = new SelectionManager_1.SelectionManager(this, this.charMeasure);
        this.register(Lifecycle_1.addDisposableDomListener(this.element, 'mousedown', function (e) { return _this.selectionManager.onMouseDown(e); }));
        this.register(this.selectionManager.addDisposableListener('refresh', function (data) { return _this.renderer.onSelectionChanged(data.start, data.end, data.columnSelectMode); }));
        this.register(this.selectionManager.addDisposableListener('newselection', function (text) {
            _this.textarea.value = text;
            _this.textarea.focus();
            _this.textarea.select();
        }));
        this.register(this.addDisposableListener('scroll', function () {
            _this.viewport.syncScrollArea();
            _this.selectionManager.refresh();
        }));
        this.register(Lifecycle_1.addDisposableDomListener(this._viewportElement, 'scroll', function () { return _this.selectionManager.refresh(); }));
        this.mouseHelper = new MouseHelper_1.MouseHelper(this.renderer);
        if (this.options.screenReaderMode) {
            this._accessibilityManager = new AccessibilityManager_1.AccessibilityManager(this);
        }
        this.charMeasure.measure(this.options);
        this.refresh(0, this.rows - 1);
        this._initGlobal();
        this.bindMouse();
    };
    Terminal.prototype._setupRenderer = function () {
        switch (this.options.rendererType) {
            case 'canvas':
                this.renderer = new Renderer_1.Renderer(this, this.options.theme);
                break;
            case 'dom':
                this.renderer = new DomRenderer_1.DomRenderer(this, this.options.theme);
                break;
            default: throw new Error("Unrecognized rendererType \"" + this.options.rendererType + "\"");
        }
        this.register(this.renderer);
    };
    Terminal.prototype._setTheme = function (theme) {
        this._theme = theme;
        var colors = this.renderer.setTheme(theme);
        if (this.viewport) {
            this.viewport.onThemeChanged(colors);
        }
    };
    Terminal.prototype.bindMouse = function () {
        var _this = this;
        var el = this.element;
        var self = this;
        var pressed = 32;
        function sendButton(ev) {
            var button;
            var pos;
            button = getButton(ev);
            pos = self.mouseHelper.getRawByteCoords(ev, self.screenElement, self.charMeasure, self.options.lineHeight, self.cols, self.rows);
            if (!pos)
                return;
            sendEvent(button, pos);
            switch (ev.overrideType || ev.type) {
                case 'mousedown':
                    pressed = button;
                    break;
                case 'mouseup':
                    pressed = 32;
                    break;
                case 'wheel':
                    break;
            }
        }
        function sendMove(ev) {
            var button = pressed;
            var pos = self.mouseHelper.getRawByteCoords(ev, self.screenElement, self.charMeasure, self.options.lineHeight, self.cols, self.rows);
            if (!pos)
                return;
            button += 32;
            sendEvent(button, pos);
        }
        function encode(data, ch) {
            if (!self.utfMouse) {
                if (ch === 255) {
                    data.push(0);
                    return;
                }
                if (ch > 127)
                    ch = 127;
                data.push(ch);
            }
            else {
                if (ch === 2047) {
                    data.push(0);
                    return;
                }
                if (ch < 127) {
                    data.push(ch);
                }
                else {
                    if (ch > 2047)
                        ch = 2047;
                    data.push(0xC0 | (ch >> 6));
                    data.push(0x80 | (ch & 0x3F));
                }
            }
        }
        function sendEvent(button, pos) {
            if (self._vt300Mouse) {
                button &= 3;
                pos.x -= 32;
                pos.y -= 32;
                var data_1 = EscapeSequences_1.C0.ESC + '[24';
                if (button === 0)
                    data_1 += '1';
                else if (button === 1)
                    data_1 += '3';
                else if (button === 2)
                    data_1 += '5';
                else if (button === 3)
                    return;
                else
                    data_1 += '0';
                data_1 += '~[' + pos.x + ',' + pos.y + ']\r';
                self.handler(data_1);
                return;
            }
            if (self._decLocator) {
                button &= 3;
                pos.x -= 32;
                pos.y -= 32;
                if (button === 0)
                    button = 2;
                else if (button === 1)
                    button = 4;
                else if (button === 2)
                    button = 6;
                else if (button === 3)
                    button = 3;
                self.handler(EscapeSequences_1.C0.ESC + '['
                    + button
                    + ';'
                    + (button === 3 ? 4 : 0)
                    + ';'
                    + pos.y
                    + ';'
                    + pos.x
                    + ';'
                    + pos.page || 0
                    + '&w');
                return;
            }
            if (self.urxvtMouse) {
                pos.x -= 32;
                pos.y -= 32;
                pos.x++;
                pos.y++;
                self.handler(EscapeSequences_1.C0.ESC + '[' + button + ';' + pos.x + ';' + pos.y + 'M');
                return;
            }
            if (self.sgrMouse) {
                pos.x -= 32;
                pos.y -= 32;
                self.handler(EscapeSequences_1.C0.ESC + '[<'
                    + (((button & 3) === 3 ? button & ~3 : button) - 32)
                    + ';'
                    + pos.x
                    + ';'
                    + pos.y
                    + ((button & 3) === 3 ? 'm' : 'M'));
                return;
            }
            var data = [];
            encode(data, button);
            encode(data, pos.x);
            encode(data, pos.y);
            self.handler(EscapeSequences_1.C0.ESC + '[M' + String.fromCharCode.apply(String, data));
        }
        function getButton(ev) {
            var button;
            var shift;
            var meta;
            var ctrl;
            var mod;
            switch (ev.overrideType || ev.type) {
                case 'mousedown':
                    button = ev.button !== null && ev.button !== undefined
                        ? +ev.button
                        : ev.which !== null && ev.which !== undefined
                            ? ev.which - 1
                            : null;
                    if (Browser.isMSIE) {
                        button = button === 1 ? 0 : button === 4 ? 1 : button;
                    }
                    break;
                case 'mouseup':
                    button = 3;
                    break;
                case 'DOMMouseScroll':
                    button = ev.detail < 0
                        ? 64
                        : 65;
                    break;
                case 'wheel':
                    button = ev.wheelDeltaY > 0
                        ? 64
                        : 65;
                    break;
            }
            shift = ev.shiftKey ? 4 : 0;
            meta = ev.metaKey ? 8 : 0;
            ctrl = ev.ctrlKey ? 16 : 0;
            mod = shift | meta | ctrl;
            if (self.vt200Mouse) {
                mod &= ctrl;
            }
            else if (!self.normalMouse) {
                mod = 0;
            }
            button = (32 + (mod << 2)) + button;
            return button;
        }
        this.register(Lifecycle_1.addDisposableDomListener(el, 'mousedown', function (ev) {
            ev.preventDefault();
            _this.focus();
            if (!_this.mouseEvents || _this.selectionManager.shouldForceSelection(ev)) {
                return;
            }
            sendButton(ev);
            if (_this.vt200Mouse) {
                ev.overrideType = 'mouseup';
                sendButton(ev);
                return _this.cancel(ev);
            }
            var moveHandler;
            if (_this.normalMouse) {
                moveHandler = function (event) {
                    if (!_this.normalMouse) {
                        return;
                    }
                    sendMove(event);
                };
                _this._document.addEventListener('mousemove', moveHandler);
            }
            var handler = function (ev) {
                if (_this.normalMouse && !_this.x10Mouse) {
                    sendButton(ev);
                }
                if (moveHandler) {
                    _this._document.removeEventListener('mousemove', moveHandler);
                    moveHandler = null;
                }
                _this._document.removeEventListener('mouseup', handler);
                return _this.cancel(ev);
            };
            _this._document.addEventListener('mouseup', handler);
            return _this.cancel(ev);
        }));
        this.register(Lifecycle_1.addDisposableDomListener(el, 'wheel', function (ev) {
            if (!_this.mouseEvents) {
                if (!_this.buffer.hasScrollback) {
                    var amount = _this.viewport.getLinesScrolled(ev);
                    if (amount === 0) {
                        return;
                    }
                    var sequence = EscapeSequences_1.C0.ESC + (_this.applicationCursor ? 'O' : '[') + (ev.deltaY < 0 ? 'A' : 'B');
                    var data = '';
                    for (var i = 0; i < Math.abs(amount); i++) {
                        data += sequence;
                    }
                    _this.handler(data);
                }
                return;
            }
            if (_this.x10Mouse || _this._vt300Mouse || _this._decLocator)
                return;
            sendButton(ev);
            ev.preventDefault();
        }));
        this.register(Lifecycle_1.addDisposableDomListener(el, 'wheel', function (ev) {
            if (_this.mouseEvents)
                return;
            _this.viewport.onWheel(ev);
            return _this.cancel(ev);
        }));
        this.register(Lifecycle_1.addDisposableDomListener(el, 'touchstart', function (ev) {
            if (_this.mouseEvents)
                return;
            _this.viewport.onTouchStart(ev);
            return _this.cancel(ev);
        }));
        this.register(Lifecycle_1.addDisposableDomListener(el, 'touchmove', function (ev) {
            if (_this.mouseEvents)
                return;
            _this.viewport.onTouchMove(ev);
            return _this.cancel(ev);
        }));
    };
    Terminal.prototype.refresh = function (start, end) {
        if (this.renderer) {
            this.renderer.refreshRows(start, end);
        }
    };
    Terminal.prototype._queueLinkification = function (start, end) {
        if (this.linkifier) {
            this.linkifier.linkifyRows(start, end);
        }
    };
    Terminal.prototype.updateCursorStyle = function (ev) {
        if (this.selectionManager && this.selectionManager.shouldColumnSelect(ev)) {
            this.element.classList.add('xterm-cursor-crosshair');
        }
        else {
            this.element.classList.remove('xterm-cursor-crosshair');
        }
    };
    Terminal.prototype.showCursor = function () {
        if (!this.cursorState) {
            this.cursorState = 1;
            this.refresh(this.buffer.y, this.buffer.y);
        }
    };
    Terminal.prototype.scroll = function (isWrapped) {
        var newLine = BufferLine_1.BufferLine.blankLine(this.cols, Buffer_1.DEFAULT_ATTR, isWrapped);
        var topRow = this.buffer.ybase + this.buffer.scrollTop;
        var bottomRow = this.buffer.ybase + this.buffer.scrollBottom;
        if (this.buffer.scrollTop === 0) {
            var willBufferBeTrimmed = this.buffer.lines.length === this.buffer.lines.maxLength;
            if (bottomRow === this.buffer.lines.length - 1) {
                this.buffer.lines.push(newLine);
            }
            else {
                this.buffer.lines.splice(bottomRow + 1, 0, newLine);
            }
            if (!willBufferBeTrimmed) {
                this.buffer.ybase++;
                if (!this._userScrolling) {
                    this.buffer.ydisp++;
                }
            }
            else {
                if (this._userScrolling) {
                    this.buffer.ydisp = Math.max(this.buffer.ydisp - 1, 0);
                }
            }
        }
        else {
            var scrollRegionHeight = bottomRow - topRow + 1;
            this.buffer.lines.shiftElements(topRow + 1, scrollRegionHeight - 1, -1);
            this.buffer.lines.set(bottomRow, newLine);
        }
        if (!this._userScrolling) {
            this.buffer.ydisp = this.buffer.ybase;
        }
        this.updateRange(this.buffer.scrollTop);
        this.updateRange(this.buffer.scrollBottom);
        this.emit('scroll', this.buffer.ydisp);
    };
    Terminal.prototype.scrollLines = function (disp, suppressScrollEvent) {
        if (disp < 0) {
            if (this.buffer.ydisp === 0) {
                return;
            }
            this._userScrolling = true;
        }
        else if (disp + this.buffer.ydisp >= this.buffer.ybase) {
            this._userScrolling = false;
        }
        var oldYdisp = this.buffer.ydisp;
        this.buffer.ydisp = Math.max(Math.min(this.buffer.ydisp + disp, this.buffer.ybase), 0);
        if (oldYdisp === this.buffer.ydisp) {
            return;
        }
        if (!suppressScrollEvent) {
            this.emit('scroll', this.buffer.ydisp);
        }
        this.refresh(0, this.rows - 1);
    };
    Terminal.prototype.scrollPages = function (pageCount) {
        this.scrollLines(pageCount * (this.rows - 1));
    };
    Terminal.prototype.scrollToTop = function () {
        this.scrollLines(-this.buffer.ydisp);
    };
    Terminal.prototype.scrollToBottom = function () {
        this.scrollLines(this.buffer.ybase - this.buffer.ydisp);
    };
    Terminal.prototype.scrollToLine = function (line) {
        var scrollAmount = line - this.buffer.ydisp;
        if (scrollAmount !== 0) {
            this.scrollLines(scrollAmount);
        }
    };
    Terminal.prototype.write = function (data) {
        var _this = this;
        if (this._isDisposed) {
            return;
        }
        if (!data) {
            return;
        }
        this.writeBuffer.push(data);
        if (this.options.useFlowControl && !this._xoffSentToCatchUp && this.writeBuffer.length >= WRITE_BUFFER_PAUSE_THRESHOLD) {
            this.handler(EscapeSequences_1.C0.DC3);
            this._xoffSentToCatchUp = true;
        }
        if (!this._writeInProgress && this.writeBuffer.length > 0) {
            this._writeInProgress = true;
            setTimeout(function () {
                _this._innerWrite();
            });
        }
    };
    Terminal.prototype._innerWrite = function () {
        var _this = this;
        if (this._isDisposed) {
            this.writeBuffer = [];
        }
        var writeBatch = this.writeBuffer.splice(0, WRITE_BATCH_SIZE);
        while (writeBatch.length > 0) {
            var data = writeBatch.shift();
            if (this._xoffSentToCatchUp && writeBatch.length === 0 && this.writeBuffer.length === 0) {
                this.handler(EscapeSequences_1.C0.DC1);
                this._xoffSentToCatchUp = false;
            }
            this._refreshStart = this.buffer.y;
            this._refreshEnd = this.buffer.y;
            this._inputHandler.parse(data);
            this.updateRange(this.buffer.y);
            this.refresh(this._refreshStart, this._refreshEnd);
        }
        if (this.writeBuffer.length > 0) {
            setTimeout(function () { return _this._innerWrite(); }, 0);
        }
        else {
            this._writeInProgress = false;
        }
    };
    Terminal.prototype.writeln = function (data) {
        this.write(data + '\r\n');
    };
    Terminal.prototype.attachCustomKeyEventHandler = function (customKeyEventHandler) {
        this._customKeyEventHandler = customKeyEventHandler;
    };
    Terminal.prototype.registerLinkMatcher = function (regex, handler, options) {
        var matcherId = this.linkifier.registerLinkMatcher(regex, handler, options);
        this.refresh(0, this.rows - 1);
        return matcherId;
    };
    Terminal.prototype.deregisterLinkMatcher = function (matcherId) {
        if (this.linkifier.deregisterLinkMatcher(matcherId)) {
            this.refresh(0, this.rows - 1);
        }
    };
    Terminal.prototype.registerCharacterJoiner = function (handler) {
        var joinerId = this.renderer.registerCharacterJoiner(handler);
        this.refresh(0, this.rows - 1);
        return joinerId;
    };
    Terminal.prototype.deregisterCharacterJoiner = function (joinerId) {
        if (this.renderer.deregisterCharacterJoiner(joinerId)) {
            this.refresh(0, this.rows - 1);
        }
    };
    Object.defineProperty(Terminal.prototype, "markers", {
        get: function () {
            return this.buffer.markers;
        },
        enumerable: true,
        configurable: true
    });
    Terminal.prototype.addMarker = function (cursorYOffset) {
        if (this.buffer !== this.buffers.normal) {
            return;
        }
        return this.buffer.addMarker(this.buffer.ybase + this.buffer.y + cursorYOffset);
    };
    Terminal.prototype.hasSelection = function () {
        return this.selectionManager ? this.selectionManager.hasSelection : false;
    };
    Terminal.prototype.getSelection = function () {
        return this.selectionManager ? this.selectionManager.selectionText : '';
    };
    Terminal.prototype.clearSelection = function () {
        if (this.selectionManager) {
            this.selectionManager.clearSelection();
        }
    };
    Terminal.prototype.selectAll = function () {
        if (this.selectionManager) {
            this.selectionManager.selectAll();
        }
    };
    Terminal.prototype.selectLines = function (start, end) {
        if (this.selectionManager) {
            this.selectionManager.selectLines(start, end);
        }
    };
    Terminal.prototype._keyDown = function (event) {
        if (this._customKeyEventHandler && this._customKeyEventHandler(event) === false) {
            return false;
        }
        if (!this._compositionHelper.keydown(event)) {
            if (this.buffer.ybase !== this.buffer.ydisp) {
                this.scrollToBottom();
            }
            return false;
        }
        var result = Keyboard_1.evaluateKeyboardEvent(event, this.applicationCursor, this.browser.isMac, this.options.macOptionIsMeta);
        this.updateCursorStyle(event);
        if (result.type === 3 || result.type === 2) {
            var scrollCount = this.rows - 1;
            this.scrollLines(result.type === 2 ? -scrollCount : scrollCount);
            return this.cancel(event, true);
        }
        if (result.type === 1) {
            this.selectAll();
        }
        if (this._isThirdLevelShift(this.browser, event)) {
            return true;
        }
        if (result.cancel) {
            this.cancel(event, true);
        }
        if (!result.key) {
            return true;
        }
        this.emit('keydown', event);
        this.emit('key', result.key, event);
        this.showCursor();
        this.handler(result.key);
        return this.cancel(event, true);
    };
    Terminal.prototype._isThirdLevelShift = function (browser, ev) {
        var thirdLevelKey = (browser.isMac && !this.options.macOptionIsMeta && ev.altKey && !ev.ctrlKey && !ev.metaKey) ||
            (browser.isMSWindows && ev.altKey && ev.ctrlKey && !ev.metaKey);
        if (ev.type === 'keypress') {
            return thirdLevelKey;
        }
        return thirdLevelKey && (!ev.keyCode || ev.keyCode > 47);
    };
    Terminal.prototype.setgLevel = function (g) {
        this.glevel = g;
        this.charset = this.charsets[g];
    };
    Terminal.prototype.setgCharset = function (g, charset) {
        this.charsets[g] = charset;
        if (this.glevel === g) {
            this.charset = charset;
        }
    };
    Terminal.prototype._keyUp = function (ev) {
        this.updateCursorStyle(ev);
    };
    Terminal.prototype._keyPress = function (ev) {
        var key;
        if (this._customKeyEventHandler && this._customKeyEventHandler(ev) === false) {
            return false;
        }
        this.cancel(ev);
        if (ev.charCode) {
            key = ev.charCode;
        }
        else if (ev.which === null || ev.which === undefined) {
            key = ev.keyCode;
        }
        else if (ev.which !== 0 && ev.charCode !== 0) {
            key = ev.which;
        }
        else {
            return false;
        }
        if (!key || ((ev.altKey || ev.ctrlKey || ev.metaKey) && !this._isThirdLevelShift(this.browser, ev))) {
            return false;
        }
        key = String.fromCharCode(key);
        this.emit('keypress', key, ev);
        this.emit('key', key, ev);
        this.showCursor();
        this.handler(key);
        return true;
    };
    Terminal.prototype.bell = function () {
        var _this = this;
        this.emit('bell');
        if (this._soundBell()) {
            this.soundManager.playBellSound();
        }
        if (this._visualBell()) {
            this.element.classList.add('visual-bell-active');
            clearTimeout(this._visualBellTimer);
            this._visualBellTimer = window.setTimeout(function () {
                _this.element.classList.remove('visual-bell-active');
            }, 200);
        }
    };
    Terminal.prototype.log = function (text, data) {
        if (!this.options.debug)
            return;
        if (!this._context.console || !this._context.console.log)
            return;
        this._context.console.log(text, data);
    };
    Terminal.prototype.error = function (text, data) {
        if (!this.options.debug)
            return;
        if (!this._context.console || !this._context.console.error)
            return;
        this._context.console.error(text, data);
    };
    Terminal.prototype.resize = function (x, y) {
        if (isNaN(x) || isNaN(y)) {
            return;
        }
        if (x === this.cols && y === this.rows) {
            if (this.charMeasure && (!this.charMeasure.width || !this.charMeasure.height)) {
                this.charMeasure.measure(this.options);
            }
            return;
        }
        if (x < 1)
            x = 1;
        if (y < 1)
            y = 1;
        this.buffers.resize(x, y);
        this.cols = x;
        this.rows = y;
        this.buffers.setupTabStops(this.cols);
        if (this.charMeasure) {
            this.charMeasure.measure(this.options);
        }
        this.refresh(0, this.rows - 1);
        this.emit('resize', { cols: x, rows: y });
    };
    Terminal.prototype.updateRange = function (y) {
        if (y < this._refreshStart)
            this._refreshStart = y;
        if (y > this._refreshEnd)
            this._refreshEnd = y;
    };
    Terminal.prototype.maxRange = function () {
        this._refreshStart = 0;
        this._refreshEnd = this.rows - 1;
    };
    Terminal.prototype.clear = function () {
        if (this.buffer.ybase === 0 && this.buffer.y === 0) {
            return;
        }
        this.buffer.lines.set(0, this.buffer.lines.get(this.buffer.ybase + this.buffer.y));
        this.buffer.lines.length = 1;
        this.buffer.ydisp = 0;
        this.buffer.ybase = 0;
        this.buffer.y = 0;
        for (var i = 1; i < this.rows; i++) {
            this.buffer.lines.push(BufferLine_1.BufferLine.blankLine(this.cols, Buffer_1.DEFAULT_ATTR));
        }
        this.refresh(0, this.rows - 1);
        this.emit('scroll', this.buffer.ydisp);
    };
    Terminal.prototype.ch = function (cur) {
        if (cur) {
            return [this.eraseAttr(), Buffer_1.NULL_CELL_CHAR, Buffer_1.NULL_CELL_WIDTH, Buffer_1.NULL_CELL_CODE];
        }
        return [Buffer_1.DEFAULT_ATTR, Buffer_1.NULL_CELL_CHAR, Buffer_1.NULL_CELL_WIDTH, Buffer_1.NULL_CELL_CODE];
    };
    Terminal.prototype.is = function (term) {
        return (this.options.termName + '').indexOf(term) === 0;
    };
    Terminal.prototype.handler = function (data) {
        if (this.options.disableStdin) {
            return;
        }
        if (this.selectionManager && this.selectionManager.hasSelection) {
            this.selectionManager.clearSelection();
        }
        if (this.buffer.ybase !== this.buffer.ydisp) {
            this.scrollToBottom();
        }
        this.emit('data', data);
    };
    Terminal.prototype.handleTitle = function (title) {
        this.emit('title', title);
    };
    Terminal.prototype.index = function () {
        this.buffer.y++;
        if (this.buffer.y > this.buffer.scrollBottom) {
            this.buffer.y--;
            this.scroll();
        }
        if (this.buffer.x >= this.cols) {
            this.buffer.x--;
        }
    };
    Terminal.prototype.reverseIndex = function () {
        if (this.buffer.y === this.buffer.scrollTop) {
            var scrollRegionHeight = this.buffer.scrollBottom - this.buffer.scrollTop;
            this.buffer.lines.shiftElements(this.buffer.y + this.buffer.ybase, scrollRegionHeight, 1);
            this.buffer.lines.set(this.buffer.y + this.buffer.ybase, BufferLine_1.BufferLine.blankLine(this.cols, this.eraseAttr()));
            this.updateRange(this.buffer.scrollTop);
            this.updateRange(this.buffer.scrollBottom);
        }
        else {
            this.buffer.y--;
        }
    };
    Terminal.prototype.reset = function () {
        this.options.rows = this.rows;
        this.options.cols = this.cols;
        var customKeyEventHandler = this._customKeyEventHandler;
        var inputHandler = this._inputHandler;
        var cursorState = this.cursorState;
        this._setup();
        this._customKeyEventHandler = customKeyEventHandler;
        this._inputHandler = inputHandler;
        this.cursorState = cursorState;
        this.refresh(0, this.rows - 1);
        if (this.viewport) {
            this.viewport.syncScrollArea();
        }
    };
    Terminal.prototype.tabSet = function () {
        this.buffer.tabs[this.buffer.x] = true;
    };
    Terminal.prototype.cancel = function (ev, force) {
        if (!this.options.cancelEvents && !force) {
            return;
        }
        ev.preventDefault();
        ev.stopPropagation();
        return false;
    };
    Terminal.prototype.matchColor = function (r1, g1, b1) {
        var hash = (r1 << 16) | (g1 << 8) | b1;
        if (matchColorCache[hash] !== null && matchColorCache[hash] !== undefined) {
            return matchColorCache[hash];
        }
        var ldiff = Infinity;
        var li = -1;
        var i = 0;
        var c;
        var r2;
        var g2;
        var b2;
        var diff;
        for (; i < ColorManager_1.DEFAULT_ANSI_COLORS.length; i++) {
            c = ColorManager_1.DEFAULT_ANSI_COLORS[i].rgba;
            r2 = c >>> 24;
            g2 = c >>> 16 & 0xFF;
            b2 = c >>> 8 & 0xFF;
            diff = matchColorDistance(r1, g1, b1, r2, g2, b2);
            if (diff === 0) {
                li = i;
                break;
            }
            if (diff < ldiff) {
                ldiff = diff;
                li = i;
            }
        }
        return matchColorCache[hash] = li;
    };
    Terminal.prototype._visualBell = function () {
        return false;
    };
    Terminal.prototype._soundBell = function () {
        return this.options.bellStyle === 'sound';
    };
    return Terminal;
}(EventEmitter_1.EventEmitter));
exports.Terminal = Terminal;
function wasModifierKeyOnlyEvent(ev) {
    return ev.keyCode === 16 ||
        ev.keyCode === 17 ||
        ev.keyCode === 18;
}
var matchColorCache = {};
function matchColorDistance(r1, g1, b1, r2, g2, b2) {
    return Math.pow(30 * (r1 - r2), 2)
        + Math.pow(59 * (g1 - g2), 2)
        + Math.pow(11 * (b1 - b2), 2);
}
//# sourceMappingURL=Terminal.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/Viewport.js":
/*!********************************************!*\
  !*** ./node_modules/xterm/lib/Viewport.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Lifecycle_1 = __webpack_require__(/*! ./common/Lifecycle */ "./node_modules/xterm/lib/common/Lifecycle.js");
var Lifecycle_2 = __webpack_require__(/*! ./ui/Lifecycle */ "./node_modules/xterm/lib/ui/Lifecycle.js");
var FALLBACK_SCROLL_BAR_WIDTH = 15;
var Viewport = (function (_super) {
    __extends(Viewport, _super);
    function Viewport(_terminal, _viewportElement, _scrollArea, _charMeasure) {
        var _this = _super.call(this) || this;
        _this._terminal = _terminal;
        _this._viewportElement = _viewportElement;
        _this._scrollArea = _scrollArea;
        _this._charMeasure = _charMeasure;
        _this.scrollBarWidth = 0;
        _this._currentRowHeight = 0;
        _this._lastRecordedBufferLength = 0;
        _this._lastRecordedViewportHeight = 0;
        _this._lastRecordedBufferHeight = 0;
        _this._lastScrollTop = 0;
        _this._wheelPartialScroll = 0;
        _this._refreshAnimationFrame = null;
        _this._ignoreNextScrollEvent = false;
        _this.scrollBarWidth = (_this._viewportElement.offsetWidth - _this._scrollArea.offsetWidth) || FALLBACK_SCROLL_BAR_WIDTH;
        _this.register(Lifecycle_2.addDisposableDomListener(_this._viewportElement, 'scroll', _this._onScroll.bind(_this)));
        setTimeout(function () { return _this.syncScrollArea(); }, 0);
        return _this;
    }
    Viewport.prototype.onThemeChanged = function (colors) {
        this._viewportElement.style.backgroundColor = colors.background.css;
    };
    Viewport.prototype._refresh = function () {
        var _this = this;
        if (this._refreshAnimationFrame === null) {
            this._refreshAnimationFrame = requestAnimationFrame(function () { return _this._innerRefresh(); });
        }
    };
    Viewport.prototype._innerRefresh = function () {
        if (this._charMeasure.height > 0) {
            this._currentRowHeight = this._terminal.renderer.dimensions.scaledCellHeight / window.devicePixelRatio;
            this._lastRecordedViewportHeight = this._viewportElement.offsetHeight;
            var newBufferHeight = Math.round(this._currentRowHeight * this._lastRecordedBufferLength) + (this._lastRecordedViewportHeight - this._terminal.renderer.dimensions.canvasHeight);
            if (this._lastRecordedBufferHeight !== newBufferHeight) {
                this._lastRecordedBufferHeight = newBufferHeight;
                this._scrollArea.style.height = this._lastRecordedBufferHeight + 'px';
            }
        }
        var scrollTop = this._terminal.buffer.ydisp * this._currentRowHeight;
        if (this._viewportElement.scrollTop !== scrollTop) {
            this._ignoreNextScrollEvent = true;
            this._viewportElement.scrollTop = scrollTop;
        }
        this._refreshAnimationFrame = null;
    };
    Viewport.prototype.syncScrollArea = function () {
        if (this._lastRecordedBufferLength !== this._terminal.buffer.lines.length) {
            this._lastRecordedBufferLength = this._terminal.buffer.lines.length;
            this._refresh();
            return;
        }
        if (this._lastRecordedViewportHeight !== this._terminal.renderer.dimensions.canvasHeight) {
            this._refresh();
            return;
        }
        var newScrollTop = this._terminal.buffer.ydisp * this._currentRowHeight;
        if (this._lastScrollTop !== newScrollTop) {
            this._refresh();
            return;
        }
        if (this._lastScrollTop !== this._viewportElement.scrollTop) {
            this._refresh();
            return;
        }
        if (this._terminal.renderer.dimensions.scaledCellHeight / window.devicePixelRatio !== this._currentRowHeight) {
            this._refresh();
            return;
        }
    };
    Viewport.prototype._onScroll = function (ev) {
        this._lastScrollTop = this._viewportElement.scrollTop;
        if (!this._viewportElement.offsetParent) {
            return;
        }
        if (this._ignoreNextScrollEvent) {
            this._ignoreNextScrollEvent = false;
            return;
        }
        var newRow = Math.round(this._lastScrollTop / this._currentRowHeight);
        var diff = newRow - this._terminal.buffer.ydisp;
        this._terminal.scrollLines(diff, true);
    };
    Viewport.prototype.onWheel = function (ev) {
        var amount = this._getPixelsScrolled(ev);
        if (amount === 0) {
            return;
        }
        this._viewportElement.scrollTop += amount;
        ev.preventDefault();
    };
    Viewport.prototype._getPixelsScrolled = function (ev) {
        if (ev.deltaY === 0) {
            return 0;
        }
        var amount = ev.deltaY;
        if (ev.deltaMode === WheelEvent.DOM_DELTA_LINE) {
            amount *= this._currentRowHeight;
        }
        else if (ev.deltaMode === WheelEvent.DOM_DELTA_PAGE) {
            amount *= this._currentRowHeight * this._terminal.rows;
        }
        return amount;
    };
    Viewport.prototype.getLinesScrolled = function (ev) {
        if (ev.deltaY === 0) {
            return 0;
        }
        var amount = ev.deltaY;
        if (ev.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
            amount /= this._currentRowHeight + 0.0;
            this._wheelPartialScroll += amount;
            amount = Math.floor(Math.abs(this._wheelPartialScroll)) * (this._wheelPartialScroll > 0 ? 1 : -1);
            this._wheelPartialScroll %= 1;
        }
        else if (ev.deltaMode === WheelEvent.DOM_DELTA_PAGE) {
            amount *= this._terminal.rows;
        }
        return amount;
    };
    Viewport.prototype.onTouchStart = function (ev) {
        this._lastTouchY = ev.touches[0].pageY;
    };
    Viewport.prototype.onTouchMove = function (ev) {
        var deltaY = this._lastTouchY - ev.touches[0].pageY;
        this._lastTouchY = ev.touches[0].pageY;
        if (deltaY === 0) {
            return;
        }
        this._viewportElement.scrollTop += deltaY;
        ev.preventDefault();
    };
    return Viewport;
}(Lifecycle_1.Disposable));
exports.Viewport = Viewport;
//# sourceMappingURL=Viewport.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/addons/attach/attach.js":
/*!********************************************************!*\
  !*** ./node_modules/xterm/lib/addons/attach/attach.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function attach(term, socket, bidirectional, buffered) {
    var addonTerminal = term;
    bidirectional = (typeof bidirectional === 'undefined') ? true : bidirectional;
    addonTerminal.__socket = socket;
    addonTerminal.__flushBuffer = function () {
        addonTerminal.write(addonTerminal.__attachSocketBuffer);
        addonTerminal.__attachSocketBuffer = null;
    };
    addonTerminal.__pushToBuffer = function (data) {
        if (addonTerminal.__attachSocketBuffer) {
            addonTerminal.__attachSocketBuffer += data;
        }
        else {
            addonTerminal.__attachSocketBuffer = data;
            setTimeout(addonTerminal.__flushBuffer, 10);
        }
    };
    var myTextDecoder;
    addonTerminal.__getMessage = function (ev) {
        var str;
        if (typeof ev.data === 'object') {
            if (!myTextDecoder) {
                myTextDecoder = new TextDecoder();
            }
            if (ev.data instanceof ArrayBuffer) {
                str = myTextDecoder.decode(ev.data);
                displayData(str);
            }
            else {
                var fileReader_1 = new FileReader();
                fileReader_1.addEventListener('load', function () {
                    str = myTextDecoder.decode(fileReader_1.result);
                    displayData(str);
                });
                fileReader_1.readAsArrayBuffer(ev.data);
            }
        }
        else if (typeof ev.data === 'string') {
            displayData(ev.data);
        }
        else {
            throw Error("Cannot handle \"" + typeof ev.data + "\" websocket message.");
        }
    };
    function displayData(str, data) {
        if (buffered) {
            addonTerminal.__pushToBuffer(str || data);
        }
        else {
            addonTerminal.write(str || data);
        }
    }
    addonTerminal.__sendData = function (data) {
        if (socket.readyState !== 1) {
            return;
        }
        socket.send(data);
    };
    addonTerminal._core.register(addSocketListener(socket, 'message', addonTerminal.__getMessage));
    if (bidirectional) {
        addonTerminal._core.register(addonTerminal.addDisposableListener('data', addonTerminal.__sendData));
    }
    addonTerminal._core.register(addSocketListener(socket, 'close', function () { return detach(addonTerminal, socket); }));
    addonTerminal._core.register(addSocketListener(socket, 'error', function () { return detach(addonTerminal, socket); }));
}
exports.attach = attach;
function addSocketListener(socket, type, handler) {
    socket.addEventListener(type, handler);
    return {
        dispose: function () {
            if (!handler) {
                return;
            }
            socket.removeEventListener(type, handler);
            handler = null;
        }
    };
}
function detach(term, socket) {
    var addonTerminal = term;
    addonTerminal.off('data', addonTerminal.__sendData);
    socket = (typeof socket === 'undefined') ? addonTerminal.__socket : socket;
    if (socket) {
        socket.removeEventListener('message', addonTerminal.__getMessage);
    }
    delete addonTerminal.__socket;
}
exports.detach = detach;
function apply(terminalConstructor) {
    terminalConstructor.prototype.attach = function (socket, bidirectional, buffered) {
        attach(this, socket, bidirectional, buffered);
    };
    terminalConstructor.prototype.detach = function (socket) {
        detach(this, socket);
    };
}
exports.apply = apply;
//# sourceMappingURL=attach.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/addons/fit/fit.js":
/*!**************************************************!*\
  !*** ./node_modules/xterm/lib/addons/fit/fit.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function proposeGeometry(term) {
    if (!term.element.parentElement) {
        return null;
    }
    var parentElementStyle = window.getComputedStyle(term.element.parentElement);
    var parentElementHeight = parseInt(parentElementStyle.getPropertyValue('height'));
    var parentElementWidth = Math.max(0, parseInt(parentElementStyle.getPropertyValue('width')));
    var elementStyle = window.getComputedStyle(term.element);
    var elementPadding = {
        top: parseInt(elementStyle.getPropertyValue('padding-top')),
        bottom: parseInt(elementStyle.getPropertyValue('padding-bottom')),
        right: parseInt(elementStyle.getPropertyValue('padding-right')),
        left: parseInt(elementStyle.getPropertyValue('padding-left'))
    };
    var elementPaddingVer = elementPadding.top + elementPadding.bottom;
    var elementPaddingHor = elementPadding.right + elementPadding.left;
    var availableHeight = parentElementHeight - elementPaddingVer;
    var availableWidth = parentElementWidth - elementPaddingHor - term._core.viewport.scrollBarWidth;
    var geometry = {
        cols: Math.floor(availableWidth / term._core.renderer.dimensions.actualCellWidth),
        rows: Math.floor(availableHeight / term._core.renderer.dimensions.actualCellHeight)
    };
    return geometry;
}
exports.proposeGeometry = proposeGeometry;
function fit(term) {
    var geometry = proposeGeometry(term);
    if (geometry) {
        if (term.rows !== geometry.rows || term.cols !== geometry.cols) {
            term._core.renderer.clear();
            term.resize(geometry.cols, geometry.rows);
        }
    }
}
exports.fit = fit;
function apply(terminalConstructor) {
    terminalConstructor.prototype.proposeGeometry = function () {
        return proposeGeometry(this);
    };
    terminalConstructor.prototype.fit = function () {
        fit(this);
    };
}
exports.apply = apply;
//# sourceMappingURL=fit.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/addons/fullscreen/fullscreen.js":
/*!****************************************************************!*\
  !*** ./node_modules/xterm/lib/addons/fullscreen/fullscreen.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function toggleFullScreen(term, fullscreen) {
    var fn;
    if (typeof fullscreen === 'undefined') {
        fn = (term.element.classList.contains('fullscreen')) ? 'remove' : 'add';
    }
    else if (!fullscreen) {
        fn = 'remove';
    }
    else {
        fn = 'add';
    }
    term.element.classList[fn]('fullscreen');
}
exports.toggleFullScreen = toggleFullScreen;
function apply(terminalConstructor) {
    terminalConstructor.prototype.toggleFullScreen = function (fullscreen) {
        toggleFullScreen(this, fullscreen);
    };
}
exports.apply = apply;
//# sourceMappingURL=fullscreen.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/addons/search/SearchHelper.js":
/*!**************************************************************!*\
  !*** ./node_modules/xterm/lib/addons/search/SearchHelper.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var nonWordCharacters = ' ~!@#$%^&*()_+`-=[]{}|\;:"\',./<>?';
var SearchHelper = (function () {
    function SearchHelper(_terminal) {
        this._terminal = _terminal;
    }
    SearchHelper.prototype.findNext = function (term, searchOptions) {
        if (!term || term.length === 0) {
            return false;
        }
        var result;
        var startRow = this._terminal._core.buffer.ydisp;
        if (this._terminal._core.selectionManager.selectionEnd) {
            startRow = this._terminal._core.selectionManager.selectionEnd[1];
        }
        for (var y = startRow + 1; y < this._terminal._core.buffer.ybase + this._terminal.rows; y++) {
            result = this._findInLine(term, y, searchOptions);
            if (result) {
                break;
            }
        }
        if (!result) {
            for (var y = 0; y < startRow; y++) {
                result = this._findInLine(term, y, searchOptions);
                if (result) {
                    break;
                }
            }
        }
        return this._selectResult(result);
    };
    SearchHelper.prototype.findPrevious = function (term, searchOptions) {
        if (!term || term.length === 0) {
            return false;
        }
        var result;
        var startRow = this._terminal._core.buffer.ydisp;
        if (this._terminal._core.selectionManager.selectionStart) {
            startRow = this._terminal._core.selectionManager.selectionStart[1];
        }
        for (var y = startRow - 1; y >= 0; y--) {
            result = this._findInLine(term, y, searchOptions);
            if (result) {
                break;
            }
        }
        if (!result) {
            for (var y = this._terminal._core.buffer.ybase + this._terminal.rows - 1; y > startRow; y--) {
                result = this._findInLine(term, y, searchOptions);
                if (result) {
                    break;
                }
            }
        }
        return this._selectResult(result);
    };
    SearchHelper.prototype._isWholeWord = function (searchIndex, line, term) {
        return (((searchIndex === 0) || (nonWordCharacters.indexOf(line[searchIndex - 1]) !== -1)) &&
            (((searchIndex + term.length) === line.length) || (nonWordCharacters.indexOf(line[searchIndex + term.length]) !== -1)));
    };
    SearchHelper.prototype._findInLine = function (term, y, searchOptions) {
        if (searchOptions === void 0) { searchOptions = {}; }
        if (this._terminal._core.buffer.lines.get(y).isWrapped) {
            return;
        }
        var stringLine = this.translateBufferLineToStringWithWrap(y, true);
        var searchStringLine = searchOptions.caseSensitive ? stringLine : stringLine.toLowerCase();
        var searchTerm = searchOptions.caseSensitive ? term : term.toLowerCase();
        var searchIndex = -1;
        if (searchOptions.regex) {
            var searchRegex = RegExp(searchTerm, 'g');
            var foundTerm = searchRegex.exec(searchStringLine);
            if (foundTerm && foundTerm[0].length > 0) {
                searchIndex = searchRegex.lastIndex - foundTerm[0].length;
                term = foundTerm[0];
            }
        }
        else {
            searchIndex = searchStringLine.indexOf(searchTerm);
        }
        if (searchIndex >= 0) {
            if (searchIndex >= this._terminal.cols) {
                y += Math.floor(searchIndex / this._terminal.cols);
                searchIndex = searchIndex % this._terminal.cols;
            }
            if (searchOptions.wholeWord && !this._isWholeWord(searchIndex, searchStringLine, term)) {
                return;
            }
            var line = this._terminal._core.buffer.lines.get(y);
            for (var i = 0; i < searchIndex; i++) {
                var charData = line.get(i);
                var char = charData[1];
                if (char.length > 1) {
                    searchIndex -= char.length - 1;
                }
                var charWidth = charData[2];
                if (charWidth === 0) {
                    searchIndex++;
                }
            }
            return {
                term: term,
                col: searchIndex,
                row: y
            };
        }
    };
    SearchHelper.prototype.translateBufferLineToStringWithWrap = function (lineIndex, trimRight) {
        var lineString = '';
        var lineWrapsToNext;
        do {
            var nextLine = this._terminal._core.buffer.lines.get(lineIndex + 1);
            lineWrapsToNext = nextLine ? nextLine.isWrapped : false;
            lineString += this._terminal._core.buffer.translateBufferLineToString(lineIndex, !lineWrapsToNext && trimRight);
            lineIndex++;
        } while (lineWrapsToNext);
        return lineString;
    };
    SearchHelper.prototype._selectResult = function (result) {
        if (!result) {
            return false;
        }
        this._terminal._core.selectionManager.setSelection(result.col, result.row, result.term.length);
        this._terminal.scrollLines(result.row - this._terminal._core.buffer.ydisp);
        return true;
    };
    return SearchHelper;
}());
exports.SearchHelper = SearchHelper;
//# sourceMappingURL=SearchHelper.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/addons/search/search.js":
/*!********************************************************!*\
  !*** ./node_modules/xterm/lib/addons/search/search.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var SearchHelper_1 = __webpack_require__(/*! ./SearchHelper */ "./node_modules/xterm/lib/addons/search/SearchHelper.js");
function findNext(terminal, term, searchOptions) {
    if (searchOptions === void 0) { searchOptions = {}; }
    var addonTerminal = terminal;
    if (!addonTerminal.__searchHelper) {
        addonTerminal.__searchHelper = new SearchHelper_1.SearchHelper(addonTerminal);
    }
    return addonTerminal.__searchHelper.findNext(term, searchOptions);
}
exports.findNext = findNext;
function findPrevious(terminal, term, searchOptions) {
    var addonTerminal = terminal;
    if (!addonTerminal.__searchHelper) {
        addonTerminal.__searchHelper = new SearchHelper_1.SearchHelper(addonTerminal);
    }
    return addonTerminal.__searchHelper.findPrevious(term, searchOptions);
}
exports.findPrevious = findPrevious;
function apply(terminalConstructor) {
    terminalConstructor.prototype.findNext = function (term, searchOptions) {
        return findNext(this, term, searchOptions);
    };
    terminalConstructor.prototype.findPrevious = function (term, searchOptions) {
        return findPrevious(this, term, searchOptions);
    };
}
exports.apply = apply;
//# sourceMappingURL=search.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/addons/webLinks/webLinks.js":
/*!************************************************************!*\
  !*** ./node_modules/xterm/lib/addons/webLinks/webLinks.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var protocolClause = '(https?:\\/\\/)';
var domainCharacterSet = '[\\da-z\\.-]+';
var negatedDomainCharacterSet = '[^\\da-z\\.-]+';
var domainBodyClause = '(' + domainCharacterSet + ')';
var tldClause = '([a-z\\.]{2,6})';
var ipClause = '((\\d{1,3}\\.){3}\\d{1,3})';
var localHostClause = '(localhost)';
var portClause = '(:\\d{1,5})';
var hostClause = '((' + domainBodyClause + '\\.' + tldClause + ')|' + ipClause + '|' + localHostClause + ')' + portClause + '?';
var pathClause = '(\\/[\\/\\w\\.\\-%~]*)*';
var queryStringHashFragmentCharacterSet = '[0-9\\w\\[\\]\\(\\)\\/\\?\\!#@$%&\'*+,:;~\\=\\.\\-]*';
var queryStringClause = '(\\?' + queryStringHashFragmentCharacterSet + ')?';
var hashFragmentClause = '(#' + queryStringHashFragmentCharacterSet + ')?';
var negatedPathCharacterSet = '[^\\/\\w\\.\\-%]+';
var bodyClause = hostClause + pathClause + queryStringClause + hashFragmentClause;
var start = '(?:^|' + negatedDomainCharacterSet + ')(';
var end = ')($|' + negatedPathCharacterSet + ')';
var strictUrlRegex = new RegExp(start + protocolClause + bodyClause + end);
function handleLink(event, uri) {
    window.open(uri, '_blank');
}
function webLinksInit(term, handler, options) {
    if (handler === void 0) { handler = handleLink; }
    if (options === void 0) { options = {}; }
    options.matchIndex = 1;
    term.registerLinkMatcher(strictUrlRegex, handler, options);
}
exports.webLinksInit = webLinksInit;
function apply(terminalConstructor) {
    terminalConstructor.prototype.webLinksInit = function (handler, options) {
        webLinksInit(this, handler, options);
    };
}
exports.apply = apply;
//# sourceMappingURL=webLinks.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/addons/winptyCompat/winptyCompat.js":
/*!********************************************************************!*\
  !*** ./node_modules/xterm/lib/addons/winptyCompat/winptyCompat.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var CHAR_DATA_CODE_INDEX = 3;
var NULL_CELL_CODE = 32;
function winptyCompatInit(terminal) {
    var addonTerminal = terminal;
    var isWindows = ['Windows', 'Win16', 'Win32', 'WinCE'].indexOf(navigator.platform) >= 0;
    if (!isWindows) {
        return;
    }
    addonTerminal.on('linefeed', function () {
        var line = addonTerminal._core.buffer.lines.get(addonTerminal._core.buffer.ybase + addonTerminal._core.buffer.y - 1);
        var lastChar = line.get(addonTerminal.cols - 1);
        if (lastChar[CHAR_DATA_CODE_INDEX] !== NULL_CELL_CODE) {
            var nextLine = addonTerminal._core.buffer.lines.get(addonTerminal._core.buffer.ybase + addonTerminal._core.buffer.y);
            nextLine.isWrapped = true;
        }
    });
}
exports.winptyCompatInit = winptyCompatInit;
function apply(terminalConstructor) {
    terminalConstructor.prototype.winptyCompatInit = function () {
        winptyCompatInit(this);
    };
}
exports.apply = apply;
//# sourceMappingURL=winptyCompat.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/common/CircularList.js":
/*!*******************************************************!*\
  !*** ./node_modules/xterm/lib/common/CircularList.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var EventEmitter_1 = __webpack_require__(/*! ./EventEmitter */ "./node_modules/xterm/lib/common/EventEmitter.js");
var CircularList = (function (_super) {
    __extends(CircularList, _super);
    function CircularList(_maxLength) {
        var _this = _super.call(this) || this;
        _this._maxLength = _maxLength;
        _this._array = new Array(_this._maxLength);
        _this._startIndex = 0;
        _this._length = 0;
        return _this;
    }
    Object.defineProperty(CircularList.prototype, "maxLength", {
        get: function () {
            return this._maxLength;
        },
        set: function (newMaxLength) {
            if (this._maxLength === newMaxLength) {
                return;
            }
            var newArray = new Array(newMaxLength);
            for (var i = 0; i < Math.min(newMaxLength, this.length); i++) {
                newArray[i] = this._array[this._getCyclicIndex(i)];
            }
            this._array = newArray;
            this._maxLength = newMaxLength;
            this._startIndex = 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CircularList.prototype, "length", {
        get: function () {
            return this._length;
        },
        set: function (newLength) {
            if (newLength > this._length) {
                for (var i = this._length; i < newLength; i++) {
                    this._array[i] = undefined;
                }
            }
            this._length = newLength;
        },
        enumerable: true,
        configurable: true
    });
    CircularList.prototype.get = function (index) {
        return this._array[this._getCyclicIndex(index)];
    };
    CircularList.prototype.set = function (index, value) {
        this._array[this._getCyclicIndex(index)] = value;
    };
    CircularList.prototype.push = function (value) {
        this._array[this._getCyclicIndex(this._length)] = value;
        if (this._length === this._maxLength) {
            this._startIndex++;
            if (this._startIndex === this._maxLength) {
                this._startIndex = 0;
            }
            this.emit('trim', 1);
        }
        else {
            this._length++;
        }
    };
    CircularList.prototype.pop = function () {
        return this._array[this._getCyclicIndex(this._length-- - 1)];
    };
    CircularList.prototype.splice = function (start, deleteCount) {
        var items = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            items[_i - 2] = arguments[_i];
        }
        if (deleteCount) {
            for (var i = start; i < this._length - deleteCount; i++) {
                this._array[this._getCyclicIndex(i)] = this._array[this._getCyclicIndex(i + deleteCount)];
            }
            this._length -= deleteCount;
        }
        if (items && items.length) {
            for (var i = this._length - 1; i >= start; i--) {
                this._array[this._getCyclicIndex(i + items.length)] = this._array[this._getCyclicIndex(i)];
            }
            for (var i = 0; i < items.length; i++) {
                this._array[this._getCyclicIndex(start + i)] = items[i];
            }
            if (this._length + items.length > this.maxLength) {
                var countToTrim = (this._length + items.length) - this.maxLength;
                this._startIndex += countToTrim;
                this._length = this.maxLength;
                this.emit('trim', countToTrim);
            }
            else {
                this._length += items.length;
            }
        }
    };
    CircularList.prototype.trimStart = function (count) {
        if (count > this._length) {
            count = this._length;
        }
        this._startIndex += count;
        this._length -= count;
        this.emit('trim', count);
    };
    CircularList.prototype.shiftElements = function (start, count, offset) {
        if (count <= 0) {
            return;
        }
        if (start < 0 || start >= this._length) {
            throw new Error('start argument out of range');
        }
        if (start + offset < 0) {
            throw new Error('Cannot shift elements in list beyond index 0');
        }
        if (offset > 0) {
            for (var i = count - 1; i >= 0; i--) {
                this.set(start + i + offset, this.get(start + i));
            }
            var expandListBy = (start + count + offset) - this._length;
            if (expandListBy > 0) {
                this._length += expandListBy;
                while (this._length > this.maxLength) {
                    this._length--;
                    this._startIndex++;
                    this.emit('trim', 1);
                }
            }
        }
        else {
            for (var i = 0; i < count; i++) {
                this.set(start + i + offset, this.get(start + i));
            }
        }
    };
    CircularList.prototype._getCyclicIndex = function (index) {
        return (this._startIndex + index) % this.maxLength;
    };
    return CircularList;
}(EventEmitter_1.EventEmitter));
exports.CircularList = CircularList;
//# sourceMappingURL=CircularList.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/common/EventEmitter.js":
/*!*******************************************************!*\
  !*** ./node_modules/xterm/lib/common/EventEmitter.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Lifecycle_1 = __webpack_require__(/*! ./Lifecycle */ "./node_modules/xterm/lib/common/Lifecycle.js");
var EventEmitter = (function (_super) {
    __extends(EventEmitter, _super);
    function EventEmitter() {
        var _this = _super.call(this) || this;
        _this._events = _this._events || {};
        return _this;
    }
    EventEmitter.prototype.on = function (type, listener) {
        this._events[type] = this._events[type] || [];
        this._events[type].push(listener);
    };
    EventEmitter.prototype.addDisposableListener = function (type, handler) {
        var _this = this;
        this.on(type, handler);
        var disposed = false;
        return {
            dispose: function () {
                if (disposed) {
                    return;
                }
                _this.off(type, handler);
                disposed = true;
            }
        };
    };
    EventEmitter.prototype.off = function (type, listener) {
        if (!this._events[type]) {
            return;
        }
        var obj = this._events[type];
        var i = obj.length;
        while (i--) {
            if (obj[i] === listener) {
                obj.splice(i, 1);
                return;
            }
        }
    };
    EventEmitter.prototype.removeAllListeners = function (type) {
        if (this._events[type]) {
            delete this._events[type];
        }
    };
    EventEmitter.prototype.emit = function (type) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (!this._events[type]) {
            return;
        }
        var obj = this._events[type];
        for (var i = 0; i < obj.length; i++) {
            obj[i].apply(this, args);
        }
    };
    EventEmitter.prototype.listeners = function (type) {
        return this._events[type] || [];
    };
    EventEmitter.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._events = {};
    };
    return EventEmitter;
}(Lifecycle_1.Disposable));
exports.EventEmitter = EventEmitter;
//# sourceMappingURL=EventEmitter.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/common/Lifecycle.js":
/*!****************************************************!*\
  !*** ./node_modules/xterm/lib/common/Lifecycle.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Disposable = (function () {
    function Disposable() {
        this._disposables = [];
        this._isDisposed = false;
    }
    Disposable.prototype.dispose = function () {
        this._isDisposed = true;
        this._disposables.forEach(function (d) { return d.dispose(); });
        this._disposables.length = 0;
    };
    Disposable.prototype.register = function (d) {
        this._disposables.push(d);
    };
    Disposable.prototype.unregister = function (d) {
        var index = this._disposables.indexOf(d);
        if (index !== -1) {
            this._disposables.splice(index, 1);
        }
    };
    return Disposable;
}());
exports.Disposable = Disposable;
//# sourceMappingURL=Lifecycle.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/common/data/EscapeSequences.js":
/*!***************************************************************!*\
  !*** ./node_modules/xterm/lib/common/data/EscapeSequences.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var C0;
(function (C0) {
    C0.NUL = '\x00';
    C0.SOH = '\x01';
    C0.STX = '\x02';
    C0.ETX = '\x03';
    C0.EOT = '\x04';
    C0.ENQ = '\x05';
    C0.ACK = '\x06';
    C0.BEL = '\x07';
    C0.BS = '\x08';
    C0.HT = '\x09';
    C0.LF = '\x0a';
    C0.VT = '\x0b';
    C0.FF = '\x0c';
    C0.CR = '\x0d';
    C0.SO = '\x0e';
    C0.SI = '\x0f';
    C0.DLE = '\x10';
    C0.DC1 = '\x11';
    C0.DC2 = '\x12';
    C0.DC3 = '\x13';
    C0.DC4 = '\x14';
    C0.NAK = '\x15';
    C0.SYN = '\x16';
    C0.ETB = '\x17';
    C0.CAN = '\x18';
    C0.EM = '\x19';
    C0.SUB = '\x1a';
    C0.ESC = '\x1b';
    C0.FS = '\x1c';
    C0.GS = '\x1d';
    C0.RS = '\x1e';
    C0.US = '\x1f';
    C0.SP = '\x20';
    C0.DEL = '\x7f';
})(C0 = exports.C0 || (exports.C0 = {}));
var C1;
(function (C1) {
    C1.PAD = '\x80';
    C1.HOP = '\x81';
    C1.BPH = '\x82';
    C1.NBH = '\x83';
    C1.IND = '\x84';
    C1.NEL = '\x85';
    C1.SSA = '\x86';
    C1.ESA = '\x87';
    C1.HTS = '\x88';
    C1.HTJ = '\x89';
    C1.VTS = '\x8a';
    C1.PLD = '\x8b';
    C1.PLU = '\x8c';
    C1.RI = '\x8d';
    C1.SS2 = '\x8e';
    C1.SS3 = '\x8f';
    C1.DCS = '\x90';
    C1.PU1 = '\x91';
    C1.PU2 = '\x92';
    C1.STS = '\x93';
    C1.CCH = '\x94';
    C1.MW = '\x95';
    C1.SPA = '\x96';
    C1.EPA = '\x97';
    C1.SOS = '\x98';
    C1.SGCI = '\x99';
    C1.SCI = '\x9a';
    C1.CSI = '\x9b';
    C1.ST = '\x9c';
    C1.OSC = '\x9d';
    C1.PM = '\x9e';
    C1.APC = '\x9f';
})(C1 = exports.C1 || (exports.C1 = {}));
//# sourceMappingURL=EscapeSequences.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/core/data/Charsets.js":
/*!******************************************************!*\
  !*** ./node_modules/xterm/lib/core/data/Charsets.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CHARSETS = {};
exports.DEFAULT_CHARSET = exports.CHARSETS['B'];
exports.CHARSETS['0'] = {
    '`': '\u25c6',
    'a': '\u2592',
    'b': '\u0009',
    'c': '\u000c',
    'd': '\u000d',
    'e': '\u000a',
    'f': '\u00b0',
    'g': '\u00b1',
    'h': '\u2424',
    'i': '\u000b',
    'j': '\u2518',
    'k': '\u2510',
    'l': '\u250c',
    'm': '\u2514',
    'n': '\u253c',
    'o': '\u23ba',
    'p': '\u23bb',
    'q': '\u2500',
    'r': '\u23bc',
    's': '\u23bd',
    't': '\u251c',
    'u': '\u2524',
    'v': '\u2534',
    'w': '\u252c',
    'x': '\u2502',
    'y': '\u2264',
    'z': '\u2265',
    '{': '\u03c0',
    '|': '\u2260',
    '}': '\u00a3',
    '~': '\u00b7'
};
exports.CHARSETS['A'] = {
    '#': '£'
};
exports.CHARSETS['B'] = null;
exports.CHARSETS['4'] = {
    '#': '£',
    '@': '¾',
    '[': 'ij',
    '\\': '½',
    ']': '|',
    '{': '¨',
    '|': 'f',
    '}': '¼',
    '~': '´'
};
exports.CHARSETS['C'] =
    exports.CHARSETS['5'] = {
        '[': 'Ä',
        '\\': 'Ö',
        ']': 'Å',
        '^': 'Ü',
        '`': 'é',
        '{': 'ä',
        '|': 'ö',
        '}': 'å',
        '~': 'ü'
    };
exports.CHARSETS['R'] = {
    '#': '£',
    '@': 'à',
    '[': '°',
    '\\': 'ç',
    ']': '§',
    '{': 'é',
    '|': 'ù',
    '}': 'è',
    '~': '¨'
};
exports.CHARSETS['Q'] = {
    '@': 'à',
    '[': 'â',
    '\\': 'ç',
    ']': 'ê',
    '^': 'î',
    '`': 'ô',
    '{': 'é',
    '|': 'ù',
    '}': 'è',
    '~': 'û'
};
exports.CHARSETS['K'] = {
    '@': '§',
    '[': 'Ä',
    '\\': 'Ö',
    ']': 'Ü',
    '{': 'ä',
    '|': 'ö',
    '}': 'ü',
    '~': 'ß'
};
exports.CHARSETS['Y'] = {
    '#': '£',
    '@': '§',
    '[': '°',
    '\\': 'ç',
    ']': 'é',
    '`': 'ù',
    '{': 'à',
    '|': 'ò',
    '}': 'è',
    '~': 'ì'
};
exports.CHARSETS['E'] =
    exports.CHARSETS['6'] = {
        '@': 'Ä',
        '[': 'Æ',
        '\\': 'Ø',
        ']': 'Å',
        '^': 'Ü',
        '`': 'ä',
        '{': 'æ',
        '|': 'ø',
        '}': 'å',
        '~': 'ü'
    };
exports.CHARSETS['Z'] = {
    '#': '£',
    '@': '§',
    '[': '¡',
    '\\': 'Ñ',
    ']': '¿',
    '{': '°',
    '|': 'ñ',
    '}': 'ç'
};
exports.CHARSETS['H'] =
    exports.CHARSETS['7'] = {
        '@': 'É',
        '[': 'Ä',
        '\\': 'Ö',
        ']': 'Å',
        '^': 'Ü',
        '`': 'é',
        '{': 'ä',
        '|': 'ö',
        '}': 'å',
        '~': 'ü'
    };
exports.CHARSETS['='] = {
    '#': 'ù',
    '@': 'à',
    '[': 'é',
    '\\': 'ç',
    ']': 'ê',
    '^': 'î',
    '_': 'è',
    '`': 'ô',
    '{': 'ä',
    '|': 'ö',
    '}': 'ü',
    '~': 'û'
};
//# sourceMappingURL=Charsets.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/core/input/Keyboard.js":
/*!*******************************************************!*\
  !*** ./node_modules/xterm/lib/core/input/Keyboard.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var EscapeSequences_1 = __webpack_require__(/*! ../../common/data/EscapeSequences */ "./node_modules/xterm/lib/common/data/EscapeSequences.js");
var KEYCODE_KEY_MAPPINGS = {
    48: ['0', ')'],
    49: ['1', '!'],
    50: ['2', '@'],
    51: ['3', '#'],
    52: ['4', '$'],
    53: ['5', '%'],
    54: ['6', '^'],
    55: ['7', '&'],
    56: ['8', '*'],
    57: ['9', '('],
    186: [';', ':'],
    187: ['=', '+'],
    188: [',', '<'],
    189: ['-', '_'],
    190: ['.', '>'],
    191: ['/', '?'],
    192: ['`', '~'],
    219: ['[', '{'],
    220: ['\\', '|'],
    221: [']', '}'],
    222: ['\'', '"']
};
function evaluateKeyboardEvent(ev, applicationCursorMode, isMac, macOptionIsMeta) {
    var result = {
        type: 0,
        cancel: false,
        key: undefined
    };
    var modifiers = (ev.shiftKey ? 1 : 0) | (ev.altKey ? 2 : 0) | (ev.ctrlKey ? 4 : 0) | (ev.metaKey ? 8 : 0);
    switch (ev.keyCode) {
        case 0:
            if (ev.key === 'UIKeyInputUpArrow') {
                if (applicationCursorMode) {
                    result.key = EscapeSequences_1.C0.ESC + 'OA';
                }
                else {
                    result.key = EscapeSequences_1.C0.ESC + '[A';
                }
            }
            else if (ev.key === 'UIKeyInputLeftArrow') {
                if (applicationCursorMode) {
                    result.key = EscapeSequences_1.C0.ESC + 'OD';
                }
                else {
                    result.key = EscapeSequences_1.C0.ESC + '[D';
                }
            }
            else if (ev.key === 'UIKeyInputRightArrow') {
                if (applicationCursorMode) {
                    result.key = EscapeSequences_1.C0.ESC + 'OC';
                }
                else {
                    result.key = EscapeSequences_1.C0.ESC + '[C';
                }
            }
            else if (ev.key === 'UIKeyInputDownArrow') {
                if (applicationCursorMode) {
                    result.key = EscapeSequences_1.C0.ESC + 'OB';
                }
                else {
                    result.key = EscapeSequences_1.C0.ESC + '[B';
                }
            }
            break;
        case 8:
            if (ev.shiftKey) {
                result.key = EscapeSequences_1.C0.BS;
                break;
            }
            else if (ev.altKey) {
                result.key = EscapeSequences_1.C0.ESC + EscapeSequences_1.C0.DEL;
                break;
            }
            result.key = EscapeSequences_1.C0.DEL;
            break;
        case 9:
            if (ev.shiftKey) {
                result.key = EscapeSequences_1.C0.ESC + '[Z';
                break;
            }
            result.key = EscapeSequences_1.C0.HT;
            result.cancel = true;
            break;
        case 13:
            result.key = EscapeSequences_1.C0.CR;
            result.cancel = true;
            break;
        case 27:
            result.key = EscapeSequences_1.C0.ESC;
            result.cancel = true;
            break;
        case 37:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[1;' + (modifiers + 1) + 'D';
                if (result.key === EscapeSequences_1.C0.ESC + '[1;3D') {
                    result.key = isMac ? EscapeSequences_1.C0.ESC + 'b' : EscapeSequences_1.C0.ESC + '[1;5D';
                }
            }
            else if (applicationCursorMode) {
                result.key = EscapeSequences_1.C0.ESC + 'OD';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[D';
            }
            break;
        case 39:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[1;' + (modifiers + 1) + 'C';
                if (result.key === EscapeSequences_1.C0.ESC + '[1;3C') {
                    result.key = isMac ? EscapeSequences_1.C0.ESC + 'f' : EscapeSequences_1.C0.ESC + '[1;5C';
                }
            }
            else if (applicationCursorMode) {
                result.key = EscapeSequences_1.C0.ESC + 'OC';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[C';
            }
            break;
        case 38:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[1;' + (modifiers + 1) + 'A';
                if (result.key === EscapeSequences_1.C0.ESC + '[1;3A') {
                    result.key = EscapeSequences_1.C0.ESC + '[1;5A';
                }
            }
            else if (applicationCursorMode) {
                result.key = EscapeSequences_1.C0.ESC + 'OA';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[A';
            }
            break;
        case 40:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[1;' + (modifiers + 1) + 'B';
                if (result.key === EscapeSequences_1.C0.ESC + '[1;3B') {
                    result.key = EscapeSequences_1.C0.ESC + '[1;5B';
                }
            }
            else if (applicationCursorMode) {
                result.key = EscapeSequences_1.C0.ESC + 'OB';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[B';
            }
            break;
        case 45:
            if (!ev.shiftKey && !ev.ctrlKey) {
                result.key = EscapeSequences_1.C0.ESC + '[2~';
            }
            break;
        case 46:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[3;' + (modifiers + 1) + '~';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[3~';
            }
            break;
        case 36:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[1;' + (modifiers + 1) + 'H';
            }
            else if (applicationCursorMode) {
                result.key = EscapeSequences_1.C0.ESC + 'OH';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[H';
            }
            break;
        case 35:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[1;' + (modifiers + 1) + 'F';
            }
            else if (applicationCursorMode) {
                result.key = EscapeSequences_1.C0.ESC + 'OF';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[F';
            }
            break;
        case 33:
            if (ev.shiftKey) {
                result.type = 2;
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[5~';
            }
            break;
        case 34:
            if (ev.shiftKey) {
                result.type = 3;
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[6~';
            }
            break;
        case 112:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[1;' + (modifiers + 1) + 'P';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + 'OP';
            }
            break;
        case 113:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[1;' + (modifiers + 1) + 'Q';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + 'OQ';
            }
            break;
        case 114:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[1;' + (modifiers + 1) + 'R';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + 'OR';
            }
            break;
        case 115:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[1;' + (modifiers + 1) + 'S';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + 'OS';
            }
            break;
        case 116:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[15;' + (modifiers + 1) + '~';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[15~';
            }
            break;
        case 117:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[17;' + (modifiers + 1) + '~';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[17~';
            }
            break;
        case 118:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[18;' + (modifiers + 1) + '~';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[18~';
            }
            break;
        case 119:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[19;' + (modifiers + 1) + '~';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[19~';
            }
            break;
        case 120:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[20;' + (modifiers + 1) + '~';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[20~';
            }
            break;
        case 121:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[21;' + (modifiers + 1) + '~';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[21~';
            }
            break;
        case 122:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[23;' + (modifiers + 1) + '~';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[23~';
            }
            break;
        case 123:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[24;' + (modifiers + 1) + '~';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[24~';
            }
            break;
        default:
            if (ev.ctrlKey && !ev.shiftKey && !ev.altKey && !ev.metaKey) {
                if (ev.keyCode >= 65 && ev.keyCode <= 90) {
                    result.key = String.fromCharCode(ev.keyCode - 64);
                }
                else if (ev.keyCode === 32) {
                    result.key = String.fromCharCode(0);
                }
                else if (ev.keyCode >= 51 && ev.keyCode <= 55) {
                    result.key = String.fromCharCode(ev.keyCode - 51 + 27);
                }
                else if (ev.keyCode === 56) {
                    result.key = String.fromCharCode(127);
                }
                else if (ev.keyCode === 219) {
                    result.key = String.fromCharCode(27);
                }
                else if (ev.keyCode === 220) {
                    result.key = String.fromCharCode(28);
                }
                else if (ev.keyCode === 221) {
                    result.key = String.fromCharCode(29);
                }
            }
            else if ((!isMac || macOptionIsMeta) && ev.altKey && !ev.metaKey) {
                var keyMapping = KEYCODE_KEY_MAPPINGS[ev.keyCode];
                var key = keyMapping && keyMapping[!ev.shiftKey ? 0 : 1];
                if (key) {
                    result.key = EscapeSequences_1.C0.ESC + key;
                }
                else if (ev.keyCode >= 65 && ev.keyCode <= 90) {
                    var keyCode = ev.ctrlKey ? ev.keyCode - 64 : ev.keyCode + 32;
                    result.key = EscapeSequences_1.C0.ESC + String.fromCharCode(keyCode);
                }
            }
            else if (isMac && !ev.altKey && !ev.ctrlKey && ev.metaKey) {
                if (ev.keyCode === 65) {
                    result.type = 1;
                }
            }
            break;
    }
    return result;
}
exports.evaluateKeyboardEvent = evaluateKeyboardEvent;
//# sourceMappingURL=Keyboard.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/handlers/AltClickHandler.js":
/*!************************************************************!*\
  !*** ./node_modules/xterm/lib/handlers/AltClickHandler.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var EscapeSequences_1 = __webpack_require__(/*! ../common/data/EscapeSequences */ "./node_modules/xterm/lib/common/data/EscapeSequences.js");
var AltClickHandler = (function () {
    function AltClickHandler(_mouseEvent, _terminal) {
        var _a;
        this._mouseEvent = _mouseEvent;
        this._terminal = _terminal;
        this._lines = this._terminal.buffer.lines;
        this._startCol = this._terminal.buffer.x;
        this._startRow = this._terminal.buffer.y;
        var coordinates = this._terminal.mouseHelper.getCoords(this._mouseEvent, this._terminal.element, this._terminal.charMeasure, this._terminal.options.lineHeight, this._terminal.cols, this._terminal.rows, false);
        if (coordinates) {
            _a = coordinates.map(function (coordinate) {
                return coordinate - 1;
            }), this._endCol = _a[0], this._endRow = _a[1];
        }
    }
    AltClickHandler.prototype.move = function () {
        if (this._mouseEvent.altKey && this._endCol !== undefined && this._endRow !== undefined) {
            this._terminal.handler(this._arrowSequences());
        }
    };
    AltClickHandler.prototype._arrowSequences = function () {
        if (!this._terminal.buffer.hasScrollback) {
            return this._resetStartingRow() + this._moveToRequestedRow() + this._moveToRequestedCol();
        }
        return this._moveHorizontallyOnly();
    };
    AltClickHandler.prototype._resetStartingRow = function () {
        if (this._moveToRequestedRow().length === 0) {
            return '';
        }
        return repeat(this._bufferLine(this._startCol, this._startRow, this._startCol, this._startRow - this._wrappedRowsForRow(this._startRow), false).length, this._sequence("D"));
    };
    AltClickHandler.prototype._moveToRequestedRow = function () {
        var startRow = this._startRow - this._wrappedRowsForRow(this._startRow);
        var endRow = this._endRow - this._wrappedRowsForRow(this._endRow);
        var rowsToMove = Math.abs(startRow - endRow) - this._wrappedRowsCount();
        return repeat(rowsToMove, this._sequence(this._verticalDirection()));
    };
    AltClickHandler.prototype._moveToRequestedCol = function () {
        var startRow;
        if (this._moveToRequestedRow().length > 0) {
            startRow = this._endRow - this._wrappedRowsForRow(this._endRow);
        }
        else {
            startRow = this._startRow;
        }
        var endRow = this._endRow;
        var direction = this._horizontalDirection();
        return repeat(this._bufferLine(this._startCol, startRow, this._endCol, endRow, direction === "C").length, this._sequence(direction));
    };
    AltClickHandler.prototype._moveHorizontallyOnly = function () {
        var direction = this._horizontalDirection();
        return repeat(Math.abs(this._startCol - this._endCol), this._sequence(direction));
    };
    AltClickHandler.prototype._wrappedRowsCount = function () {
        var wrappedRows = 0;
        var startRow = this._startRow - this._wrappedRowsForRow(this._startRow);
        var endRow = this._endRow - this._wrappedRowsForRow(this._endRow);
        for (var i = 0; i < Math.abs(startRow - endRow); i++) {
            var direction = this._verticalDirection() === "A" ? -1 : 1;
            if (this._lines.get(startRow + (direction * i)).isWrapped) {
                wrappedRows++;
            }
        }
        return wrappedRows;
    };
    AltClickHandler.prototype._wrappedRowsForRow = function (currentRow) {
        var rowCount = 0;
        var lineWraps = this._lines.get(currentRow).isWrapped;
        while (lineWraps && currentRow >= 0 && currentRow < this._terminal.rows) {
            rowCount++;
            currentRow--;
            lineWraps = this._lines.get(currentRow).isWrapped;
        }
        return rowCount;
    };
    AltClickHandler.prototype._horizontalDirection = function () {
        var startRow;
        if (this._moveToRequestedRow().length > 0) {
            startRow = this._endRow - this._wrappedRowsForRow(this._endRow);
        }
        else {
            startRow = this._startRow;
        }
        if ((this._startCol < this._endCol &&
            startRow <= this._endRow) ||
            (this._startCol >= this._endCol &&
                startRow < this._endRow)) {
            return "C";
        }
        return "D";
    };
    AltClickHandler.prototype._verticalDirection = function () {
        if (this._startRow > this._endRow) {
            return "A";
        }
        return "B";
    };
    AltClickHandler.prototype._bufferLine = function (startCol, startRow, endCol, endRow, forward) {
        var currentCol = startCol;
        var currentRow = startRow;
        var bufferStr = '';
        while (currentCol !== endCol || currentRow !== endRow) {
            currentCol += forward ? 1 : -1;
            if (forward && currentCol > this._terminal.cols - 1) {
                bufferStr += this._terminal.buffer.translateBufferLineToString(currentRow, false, startCol, currentCol);
                currentCol = 0;
                startCol = 0;
                currentRow++;
            }
            else if (!forward && currentCol < 0) {
                bufferStr += this._terminal.buffer.translateBufferLineToString(currentRow, false, 0, startCol + 1);
                currentCol = this._terminal.cols - 1;
                startCol = currentCol;
                currentRow--;
            }
        }
        return bufferStr + this._terminal.buffer.translateBufferLineToString(currentRow, false, startCol, currentCol);
    };
    AltClickHandler.prototype._sequence = function (direction) {
        var mod = this._terminal.applicationCursor ? 'O' : '[';
        return EscapeSequences_1.C0.ESC + mod + direction;
    };
    return AltClickHandler;
}());
exports.AltClickHandler = AltClickHandler;
function repeat(count, str) {
    count = Math.floor(count);
    var rpt = '';
    for (var i = 0; i < count; i++) {
        rpt += str;
    }
    return rpt;
}
//# sourceMappingURL=AltClickHandler.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/handlers/Clipboard.js":
/*!******************************************************!*\
  !*** ./node_modules/xterm/lib/handlers/Clipboard.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function prepareTextForTerminal(text) {
    return text.replace(/\r?\n/g, '\r');
}
exports.prepareTextForTerminal = prepareTextForTerminal;
function bracketTextForPaste(text, bracketedPasteMode) {
    if (bracketedPasteMode) {
        return '\x1b[200~' + text + '\x1b[201~';
    }
    return text;
}
exports.bracketTextForPaste = bracketTextForPaste;
function copyHandler(ev, term, selectionManager) {
    if (term.browser.isMSIE) {
        window.clipboardData.setData('Text', selectionManager.selectionText);
    }
    else {
        ev.clipboardData.setData('text/plain', selectionManager.selectionText);
    }
    ev.preventDefault();
}
exports.copyHandler = copyHandler;
function pasteHandler(ev, term) {
    ev.stopPropagation();
    var text;
    var dispatchPaste = function (text) {
        text = prepareTextForTerminal(text);
        text = bracketTextForPaste(text, term.bracketedPasteMode);
        term.handler(text);
        term.textarea.value = '';
        term.emit('paste', text);
        term.cancel(ev);
    };
    if (term.browser.isMSIE) {
        if (window.clipboardData) {
            text = window.clipboardData.getData('Text');
            dispatchPaste(text);
        }
    }
    else {
        if (ev.clipboardData) {
            text = ev.clipboardData.getData('text/plain');
            dispatchPaste(text);
        }
    }
}
exports.pasteHandler = pasteHandler;
function moveTextAreaUnderMouseCursor(ev, textarea) {
    textarea.style.position = 'fixed';
    textarea.style.width = '20px';
    textarea.style.height = '20px';
    textarea.style.left = (ev.clientX - 10) + 'px';
    textarea.style.top = (ev.clientY - 10) + 'px';
    textarea.style.zIndex = '1000';
    textarea.focus();
    setTimeout(function () {
        textarea.style.position = null;
        textarea.style.width = null;
        textarea.style.height = null;
        textarea.style.left = null;
        textarea.style.top = null;
        textarea.style.zIndex = null;
    }, 200);
}
exports.moveTextAreaUnderMouseCursor = moveTextAreaUnderMouseCursor;
function rightClickHandler(ev, textarea, selectionManager, shouldSelectWord) {
    moveTextAreaUnderMouseCursor(ev, textarea);
    if (shouldSelectWord && !selectionManager.isClickInSelection(ev)) {
        selectionManager.selectWordAtCursor(ev);
    }
    textarea.value = selectionManager.selectionText;
    textarea.select();
}
exports.rightClickHandler = rightClickHandler;
//# sourceMappingURL=Clipboard.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/public/Terminal.js":
/*!***************************************************!*\
  !*** ./node_modules/xterm/lib/public/Terminal.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Terminal_1 = __webpack_require__(/*! ../Terminal */ "./node_modules/xterm/lib/Terminal.js");
var Strings = __webpack_require__(/*! ../Strings */ "./node_modules/xterm/lib/Strings.js");
var Terminal = (function () {
    function Terminal(options) {
        this._core = new Terminal_1.Terminal(options);
    }
    Object.defineProperty(Terminal.prototype, "element", {
        get: function () { return this._core.element; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Terminal.prototype, "textarea", {
        get: function () { return this._core.textarea; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Terminal.prototype, "rows", {
        get: function () { return this._core.rows; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Terminal.prototype, "cols", {
        get: function () { return this._core.cols; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Terminal.prototype, "markers", {
        get: function () { return this._core.markers; },
        enumerable: true,
        configurable: true
    });
    Terminal.prototype.blur = function () {
        this._core.blur();
    };
    Terminal.prototype.focus = function () {
        this._core.focus();
    };
    Terminal.prototype.on = function (type, listener) {
        this._core.on(type, listener);
    };
    Terminal.prototype.off = function (type, listener) {
        this._core.off(type, listener);
    };
    Terminal.prototype.emit = function (type, data) {
        this._core.emit(type, data);
    };
    Terminal.prototype.addDisposableListener = function (type, handler) {
        return this._core.addDisposableListener(type, handler);
    };
    Terminal.prototype.resize = function (columns, rows) {
        this._core.resize(columns, rows);
    };
    Terminal.prototype.writeln = function (data) {
        this._core.writeln(data);
    };
    Terminal.prototype.open = function (parent) {
        this._core.open(parent);
    };
    Terminal.prototype.attachCustomKeyEventHandler = function (customKeyEventHandler) {
        this._core.attachCustomKeyEventHandler(customKeyEventHandler);
    };
    Terminal.prototype.registerLinkMatcher = function (regex, handler, options) {
        return this._core.registerLinkMatcher(regex, handler, options);
    };
    Terminal.prototype.deregisterLinkMatcher = function (matcherId) {
        this._core.deregisterLinkMatcher(matcherId);
    };
    Terminal.prototype.registerCharacterJoiner = function (handler) {
        return this._core.registerCharacterJoiner(handler);
    };
    Terminal.prototype.deregisterCharacterJoiner = function (joinerId) {
        this._core.deregisterCharacterJoiner(joinerId);
    };
    Terminal.prototype.addMarker = function (cursorYOffset) {
        return this._core.addMarker(cursorYOffset);
    };
    Terminal.prototype.hasSelection = function () {
        return this._core.hasSelection();
    };
    Terminal.prototype.getSelection = function () {
        return this._core.getSelection();
    };
    Terminal.prototype.clearSelection = function () {
        this._core.clearSelection();
    };
    Terminal.prototype.selectAll = function () {
        this._core.selectAll();
    };
    Terminal.prototype.selectLines = function (start, end) {
        this._core.selectLines(start, end);
    };
    Terminal.prototype.dispose = function () {
        this._core.dispose();
    };
    Terminal.prototype.destroy = function () {
        this._core.destroy();
    };
    Terminal.prototype.scrollLines = function (amount) {
        this._core.scrollLines(amount);
    };
    Terminal.prototype.scrollPages = function (pageCount) {
        this._core.scrollPages(pageCount);
    };
    Terminal.prototype.scrollToTop = function () {
        this._core.scrollToTop();
    };
    Terminal.prototype.scrollToBottom = function () {
        this._core.scrollToBottom();
    };
    Terminal.prototype.scrollToLine = function (line) {
        this._core.scrollToLine(line);
    };
    Terminal.prototype.clear = function () {
        this._core.clear();
    };
    Terminal.prototype.write = function (data) {
        this._core.write(data);
    };
    Terminal.prototype.getOption = function (key) {
        return this._core.getOption(key);
    };
    Terminal.prototype.setOption = function (key, value) {
        this._core.setOption(key, value);
    };
    Terminal.prototype.refresh = function (start, end) {
        this._core.refresh(start, end);
    };
    Terminal.prototype.reset = function () {
        this._core.reset();
    };
    Terminal.applyAddon = function (addon) {
        addon.apply(Terminal);
    };
    Object.defineProperty(Terminal, "strings", {
        get: function () {
            return Strings;
        },
        enumerable: true,
        configurable: true
    });
    return Terminal;
}());
exports.Terminal = Terminal;
//# sourceMappingURL=Terminal.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/renderer/BaseRenderLayer.js":
/*!************************************************************!*\
  !*** ./node_modules/xterm/lib/renderer/BaseRenderLayer.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Types_1 = __webpack_require__(/*! ./atlas/Types */ "./node_modules/xterm/lib/renderer/atlas/Types.js");
var CharAtlasCache_1 = __webpack_require__(/*! ./atlas/CharAtlasCache */ "./node_modules/xterm/lib/renderer/atlas/CharAtlasCache.js");
var Buffer_1 = __webpack_require__(/*! ../Buffer */ "./node_modules/xterm/lib/Buffer.js");
var BaseRenderLayer = (function () {
    function BaseRenderLayer(_container, id, zIndex, _alpha, _colors) {
        this._container = _container;
        this._alpha = _alpha;
        this._colors = _colors;
        this._scaledCharWidth = 0;
        this._scaledCharHeight = 0;
        this._scaledCellWidth = 0;
        this._scaledCellHeight = 0;
        this._scaledCharLeft = 0;
        this._scaledCharTop = 0;
        this._currentGlyphIdentifier = {
            chars: '',
            code: 0,
            bg: 0,
            fg: 0,
            bold: false,
            dim: false,
            italic: false
        };
        this._canvas = document.createElement('canvas');
        this._canvas.classList.add("xterm-" + id + "-layer");
        this._canvas.style.zIndex = zIndex.toString();
        this._initCanvas();
        this._container.appendChild(this._canvas);
    }
    BaseRenderLayer.prototype.dispose = function () {
        this._container.removeChild(this._canvas);
        if (this._charAtlas) {
            this._charAtlas.dispose();
        }
    };
    BaseRenderLayer.prototype._initCanvas = function () {
        this._ctx = this._canvas.getContext('2d', { alpha: this._alpha });
        if (!this._alpha) {
            this.clearAll();
        }
    };
    BaseRenderLayer.prototype.onOptionsChanged = function (terminal) { };
    BaseRenderLayer.prototype.onBlur = function (terminal) { };
    BaseRenderLayer.prototype.onFocus = function (terminal) { };
    BaseRenderLayer.prototype.onCursorMove = function (terminal) { };
    BaseRenderLayer.prototype.onGridChanged = function (terminal, startRow, endRow) { };
    BaseRenderLayer.prototype.onSelectionChanged = function (terminal, start, end, columnSelectMode) {
        if (columnSelectMode === void 0) { columnSelectMode = false; }
    };
    BaseRenderLayer.prototype.onThemeChanged = function (terminal, colorSet) {
        this._refreshCharAtlas(terminal, colorSet);
    };
    BaseRenderLayer.prototype.setTransparency = function (terminal, alpha) {
        if (alpha === this._alpha) {
            return;
        }
        var oldCanvas = this._canvas;
        this._alpha = alpha;
        this._canvas = this._canvas.cloneNode();
        this._initCanvas();
        this._container.replaceChild(this._canvas, oldCanvas);
        this._refreshCharAtlas(terminal, this._colors);
        this.onGridChanged(terminal, 0, terminal.rows - 1);
    };
    BaseRenderLayer.prototype._refreshCharAtlas = function (terminal, colorSet) {
        if (this._scaledCharWidth <= 0 && this._scaledCharHeight <= 0) {
            return;
        }
        this._charAtlas = CharAtlasCache_1.acquireCharAtlas(terminal, colorSet, this._scaledCharWidth, this._scaledCharHeight);
        this._charAtlas.warmUp();
    };
    BaseRenderLayer.prototype.resize = function (terminal, dim) {
        this._scaledCellWidth = dim.scaledCellWidth;
        this._scaledCellHeight = dim.scaledCellHeight;
        this._scaledCharWidth = dim.scaledCharWidth;
        this._scaledCharHeight = dim.scaledCharHeight;
        this._scaledCharLeft = dim.scaledCharLeft;
        this._scaledCharTop = dim.scaledCharTop;
        this._canvas.width = dim.scaledCanvasWidth;
        this._canvas.height = dim.scaledCanvasHeight;
        this._canvas.style.width = dim.canvasWidth + "px";
        this._canvas.style.height = dim.canvasHeight + "px";
        if (!this._alpha) {
            this.clearAll();
        }
        this._refreshCharAtlas(terminal, this._colors);
    };
    BaseRenderLayer.prototype.fillCells = function (x, y, width, height) {
        this._ctx.fillRect(x * this._scaledCellWidth, y * this._scaledCellHeight, width * this._scaledCellWidth, height * this._scaledCellHeight);
    };
    BaseRenderLayer.prototype.fillBottomLineAtCells = function (x, y, width) {
        if (width === void 0) { width = 1; }
        this._ctx.fillRect(x * this._scaledCellWidth, (y + 1) * this._scaledCellHeight - window.devicePixelRatio - 1, width * this._scaledCellWidth, window.devicePixelRatio);
    };
    BaseRenderLayer.prototype.fillLeftLineAtCell = function (x, y) {
        this._ctx.fillRect(x * this._scaledCellWidth, y * this._scaledCellHeight, window.devicePixelRatio, this._scaledCellHeight);
    };
    BaseRenderLayer.prototype.strokeRectAtCell = function (x, y, width, height) {
        this._ctx.lineWidth = window.devicePixelRatio;
        this._ctx.strokeRect(x * this._scaledCellWidth + window.devicePixelRatio / 2, y * this._scaledCellHeight + (window.devicePixelRatio / 2), width * this._scaledCellWidth - window.devicePixelRatio, (height * this._scaledCellHeight) - window.devicePixelRatio);
    };
    BaseRenderLayer.prototype.clearAll = function () {
        if (this._alpha) {
            this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
        }
        else {
            this._ctx.fillStyle = this._colors.background.css;
            this._ctx.fillRect(0, 0, this._canvas.width, this._canvas.height);
        }
    };
    BaseRenderLayer.prototype.clearCells = function (x, y, width, height) {
        if (this._alpha) {
            this._ctx.clearRect(x * this._scaledCellWidth, y * this._scaledCellHeight, width * this._scaledCellWidth, height * this._scaledCellHeight);
        }
        else {
            this._ctx.fillStyle = this._colors.background.css;
            this._ctx.fillRect(x * this._scaledCellWidth, y * this._scaledCellHeight, width * this._scaledCellWidth, height * this._scaledCellHeight);
        }
    };
    BaseRenderLayer.prototype.fillCharTrueColor = function (terminal, charData, x, y) {
        this._ctx.font = this._getFont(terminal, false, false);
        this._ctx.textBaseline = 'top';
        this._clipRow(terminal, y);
        this._ctx.fillText(charData[Buffer_1.CHAR_DATA_CHAR_INDEX], x * this._scaledCellWidth + this._scaledCharLeft, y * this._scaledCellHeight + this._scaledCharTop);
    };
    BaseRenderLayer.prototype.drawChars = function (terminal, chars, code, width, x, y, fg, bg, bold, dim, italic) {
        var drawInBrightColor = terminal.options.drawBoldTextInBrightColors && bold && fg < 8 && fg !== Types_1.INVERTED_DEFAULT_COLOR;
        fg += drawInBrightColor ? 8 : 0;
        this._currentGlyphIdentifier.chars = chars;
        this._currentGlyphIdentifier.code = code;
        this._currentGlyphIdentifier.bg = bg;
        this._currentGlyphIdentifier.fg = fg;
        this._currentGlyphIdentifier.bold = bold && terminal.options.enableBold;
        this._currentGlyphIdentifier.dim = dim;
        this._currentGlyphIdentifier.italic = italic;
        var atlasDidDraw = this._charAtlas && this._charAtlas.draw(this._ctx, this._currentGlyphIdentifier, x * this._scaledCellWidth + this._scaledCharLeft, y * this._scaledCellHeight + this._scaledCharTop);
        if (!atlasDidDraw) {
            this._drawUncachedChars(terminal, chars, width, fg, x, y, bold && terminal.options.enableBold, dim, italic);
        }
    };
    BaseRenderLayer.prototype._drawUncachedChars = function (terminal, chars, width, fg, x, y, bold, dim, italic) {
        this._ctx.save();
        this._ctx.font = this._getFont(terminal, bold, italic);
        this._ctx.textBaseline = 'top';
        if (fg === Types_1.INVERTED_DEFAULT_COLOR) {
            this._ctx.fillStyle = this._colors.background.css;
        }
        else if (fg < 256) {
            this._ctx.fillStyle = this._colors.ansi[fg].css;
        }
        else {
            this._ctx.fillStyle = this._colors.foreground.css;
        }
        this._clipRow(terminal, y);
        if (dim) {
            this._ctx.globalAlpha = Types_1.DIM_OPACITY;
        }
        this._ctx.fillText(chars, x * this._scaledCellWidth + this._scaledCharLeft, y * this._scaledCellHeight + this._scaledCharTop);
        this._ctx.restore();
    };
    BaseRenderLayer.prototype._clipRow = function (terminal, y) {
        this._ctx.beginPath();
        this._ctx.rect(0, y * this._scaledCellHeight, terminal.cols * this._scaledCellWidth, this._scaledCellHeight);
        this._ctx.clip();
    };
    BaseRenderLayer.prototype._getFont = function (terminal, isBold, isItalic) {
        var fontWeight = isBold ? terminal.options.fontWeightBold : terminal.options.fontWeight;
        var fontStyle = isItalic ? 'italic' : '';
        return fontStyle + " " + fontWeight + " " + terminal.options.fontSize * window.devicePixelRatio + "px " + terminal.options.fontFamily;
    };
    return BaseRenderLayer;
}());
exports.BaseRenderLayer = BaseRenderLayer;
//# sourceMappingURL=BaseRenderLayer.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/renderer/CharacterJoinerRegistry.js":
/*!********************************************************************!*\
  !*** ./node_modules/xterm/lib/renderer/CharacterJoinerRegistry.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Buffer_1 = __webpack_require__(/*! ../Buffer */ "./node_modules/xterm/lib/Buffer.js");
var CharacterJoinerRegistry = (function () {
    function CharacterJoinerRegistry(_terminal) {
        this._terminal = _terminal;
        this._characterJoiners = [];
        this._nextCharacterJoinerId = 0;
    }
    CharacterJoinerRegistry.prototype.registerCharacterJoiner = function (handler) {
        var joiner = {
            id: this._nextCharacterJoinerId++,
            handler: handler
        };
        this._characterJoiners.push(joiner);
        return joiner.id;
    };
    CharacterJoinerRegistry.prototype.deregisterCharacterJoiner = function (joinerId) {
        for (var i = 0; i < this._characterJoiners.length; i++) {
            if (this._characterJoiners[i].id === joinerId) {
                this._characterJoiners.splice(i, 1);
                return true;
            }
        }
        return false;
    };
    CharacterJoinerRegistry.prototype.getJoinedCharacters = function (row) {
        if (this._characterJoiners.length === 0) {
            return [];
        }
        var line = this._terminal.buffer.lines.get(row);
        if (line.length === 0) {
            return [];
        }
        var ranges = [];
        var lineStr = this._terminal.buffer.translateBufferLineToString(row, true);
        var rangeStartColumn = 0;
        var currentStringIndex = 0;
        var rangeStartStringIndex = 0;
        var rangeAttr = line.get(0)[Buffer_1.CHAR_DATA_ATTR_INDEX] >> 9;
        for (var x = 0; x < this._terminal.cols; x++) {
            var charData = line.get(x);
            var chars = charData[Buffer_1.CHAR_DATA_CHAR_INDEX];
            var width = charData[Buffer_1.CHAR_DATA_WIDTH_INDEX];
            var attr = charData[Buffer_1.CHAR_DATA_ATTR_INDEX] >> 9;
            if (width === 0) {
                continue;
            }
            if (attr !== rangeAttr) {
                if (x - rangeStartColumn > 1) {
                    var joinedRanges = this._getJoinedRanges(lineStr, rangeStartStringIndex, currentStringIndex, line, rangeStartColumn);
                    for (var i = 0; i < joinedRanges.length; i++) {
                        ranges.push(joinedRanges[i]);
                    }
                }
                rangeStartColumn = x;
                rangeStartStringIndex = currentStringIndex;
                rangeAttr = attr;
            }
            currentStringIndex += chars.length;
        }
        if (this._terminal.cols - rangeStartColumn > 1) {
            var joinedRanges = this._getJoinedRanges(lineStr, rangeStartStringIndex, currentStringIndex, line, rangeStartColumn);
            for (var i = 0; i < joinedRanges.length; i++) {
                ranges.push(joinedRanges[i]);
            }
        }
        return ranges;
    };
    CharacterJoinerRegistry.prototype._getJoinedRanges = function (line, startIndex, endIndex, lineData, startCol) {
        var text = line.substring(startIndex, endIndex);
        var joinedRanges = this._characterJoiners[0].handler(text);
        for (var i = 1; i < this._characterJoiners.length; i++) {
            var joinerRanges = this._characterJoiners[i].handler(text);
            for (var j = 0; j < joinerRanges.length; j++) {
                CharacterJoinerRegistry._mergeRanges(joinedRanges, joinerRanges[j]);
            }
        }
        this._stringRangesToCellRanges(joinedRanges, lineData, startCol);
        return joinedRanges;
    };
    CharacterJoinerRegistry.prototype._stringRangesToCellRanges = function (ranges, line, startCol) {
        var currentRangeIndex = 0;
        var currentRangeStarted = false;
        var currentStringIndex = 0;
        var currentRange = ranges[currentRangeIndex];
        if (!currentRange) {
            return;
        }
        for (var x = startCol; x < this._terminal.cols; x++) {
            var charData = line.get(x);
            var width = charData[Buffer_1.CHAR_DATA_WIDTH_INDEX];
            var length_1 = charData[Buffer_1.CHAR_DATA_CHAR_INDEX].length;
            if (width === 0) {
                continue;
            }
            if (!currentRangeStarted && currentRange[0] <= currentStringIndex) {
                currentRange[0] = x;
                currentRangeStarted = true;
            }
            if (currentRange[1] <= currentStringIndex) {
                currentRange[1] = x;
                currentRange = ranges[++currentRangeIndex];
                if (!currentRange) {
                    break;
                }
                if (currentRange[0] <= currentStringIndex) {
                    currentRange[0] = x;
                    currentRangeStarted = true;
                }
                else {
                    currentRangeStarted = false;
                }
            }
            currentStringIndex += length_1;
        }
        if (currentRange) {
            currentRange[1] = this._terminal.cols;
        }
    };
    CharacterJoinerRegistry._mergeRanges = function (ranges, newRange) {
        var inRange = false;
        for (var i = 0; i < ranges.length; i++) {
            var range = ranges[i];
            if (!inRange) {
                if (newRange[1] <= range[0]) {
                    ranges.splice(i, 0, newRange);
                    return ranges;
                }
                if (newRange[1] <= range[1]) {
                    range[0] = Math.min(newRange[0], range[0]);
                    return ranges;
                }
                if (newRange[0] < range[1]) {
                    range[0] = Math.min(newRange[0], range[0]);
                    inRange = true;
                }
                continue;
            }
            else {
                if (newRange[1] <= range[0]) {
                    ranges[i - 1][1] = newRange[1];
                    return ranges;
                }
                if (newRange[1] <= range[1]) {
                    ranges[i - 1][1] = Math.max(newRange[1], range[1]);
                    ranges.splice(i, 1);
                    inRange = false;
                    return ranges;
                }
                ranges.splice(i, 1);
                i--;
            }
        }
        if (inRange) {
            ranges[ranges.length - 1][1] = newRange[1];
        }
        else {
            ranges.push(newRange);
        }
        return ranges;
    };
    return CharacterJoinerRegistry;
}());
exports.CharacterJoinerRegistry = CharacterJoinerRegistry;
//# sourceMappingURL=CharacterJoinerRegistry.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/renderer/ColorManager.js":
/*!*********************************************************!*\
  !*** ./node_modules/xterm/lib/renderer/ColorManager.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DEFAULT_FOREGROUND = fromHex('#ffffff');
var DEFAULT_BACKGROUND = fromHex('#000000');
var DEFAULT_CURSOR = fromHex('#ffffff');
var DEFAULT_CURSOR_ACCENT = fromHex('#000000');
var DEFAULT_SELECTION = {
    css: 'rgba(255, 255, 255, 0.3)',
    rgba: 0xFFFFFF77
};
exports.DEFAULT_ANSI_COLORS = (function () {
    var colors = [
        fromHex('#2e3436'),
        fromHex('#cc0000'),
        fromHex('#4e9a06'),
        fromHex('#c4a000'),
        fromHex('#3465a4'),
        fromHex('#75507b'),
        fromHex('#06989a'),
        fromHex('#d3d7cf'),
        fromHex('#555753'),
        fromHex('#ef2929'),
        fromHex('#8ae234'),
        fromHex('#fce94f'),
        fromHex('#729fcf'),
        fromHex('#ad7fa8'),
        fromHex('#34e2e2'),
        fromHex('#eeeeec')
    ];
    var v = [0x00, 0x5f, 0x87, 0xaf, 0xd7, 0xff];
    for (var i = 0; i < 216; i++) {
        var r = v[(i / 36) % 6 | 0];
        var g = v[(i / 6) % 6 | 0];
        var b = v[i % 6];
        colors.push({
            css: "#" + toPaddedHex(r) + toPaddedHex(g) + toPaddedHex(b),
            rgba: ((r << 24) | (g << 16) | (b << 8) | 0xFF) >>> 0
        });
    }
    for (var i = 0; i < 24; i++) {
        var c = 8 + i * 10;
        var ch = toPaddedHex(c);
        colors.push({
            css: "#" + ch + ch + ch,
            rgba: ((c << 24) | (c << 16) | (c << 8) | 0xFF) >>> 0
        });
    }
    return colors;
})();
function fromHex(css) {
    return {
        css: css,
        rgba: parseInt(css.slice(1), 16) << 8 | 0xFF
    };
}
function toPaddedHex(c) {
    var s = c.toString(16);
    return s.length < 2 ? '0' + s : s;
}
var ColorManager = (function () {
    function ColorManager(document, allowTransparency) {
        this.allowTransparency = allowTransparency;
        var canvas = document.createElement('canvas');
        canvas.width = 1;
        canvas.height = 1;
        this._ctx = canvas.getContext('2d');
        this._ctx.globalCompositeOperation = 'copy';
        this._litmusColor = this._ctx.createLinearGradient(0, 0, 1, 1);
        this.colors = {
            foreground: DEFAULT_FOREGROUND,
            background: DEFAULT_BACKGROUND,
            cursor: DEFAULT_CURSOR,
            cursorAccent: DEFAULT_CURSOR_ACCENT,
            selection: DEFAULT_SELECTION,
            ansi: exports.DEFAULT_ANSI_COLORS.slice()
        };
    }
    ColorManager.prototype.setTheme = function (theme) {
        this.colors.foreground = this._parseColor(theme.foreground, DEFAULT_FOREGROUND);
        this.colors.background = this._parseColor(theme.background, DEFAULT_BACKGROUND);
        this.colors.cursor = this._parseColor(theme.cursor, DEFAULT_CURSOR, true);
        this.colors.cursorAccent = this._parseColor(theme.cursorAccent, DEFAULT_CURSOR_ACCENT, true);
        this.colors.selection = this._parseColor(theme.selection, DEFAULT_SELECTION, true);
        this.colors.ansi[0] = this._parseColor(theme.black, exports.DEFAULT_ANSI_COLORS[0]);
        this.colors.ansi[1] = this._parseColor(theme.red, exports.DEFAULT_ANSI_COLORS[1]);
        this.colors.ansi[2] = this._parseColor(theme.green, exports.DEFAULT_ANSI_COLORS[2]);
        this.colors.ansi[3] = this._parseColor(theme.yellow, exports.DEFAULT_ANSI_COLORS[3]);
        this.colors.ansi[4] = this._parseColor(theme.blue, exports.DEFAULT_ANSI_COLORS[4]);
        this.colors.ansi[5] = this._parseColor(theme.magenta, exports.DEFAULT_ANSI_COLORS[5]);
        this.colors.ansi[6] = this._parseColor(theme.cyan, exports.DEFAULT_ANSI_COLORS[6]);
        this.colors.ansi[7] = this._parseColor(theme.white, exports.DEFAULT_ANSI_COLORS[7]);
        this.colors.ansi[8] = this._parseColor(theme.brightBlack, exports.DEFAULT_ANSI_COLORS[8]);
        this.colors.ansi[9] = this._parseColor(theme.brightRed, exports.DEFAULT_ANSI_COLORS[9]);
        this.colors.ansi[10] = this._parseColor(theme.brightGreen, exports.DEFAULT_ANSI_COLORS[10]);
        this.colors.ansi[11] = this._parseColor(theme.brightYellow, exports.DEFAULT_ANSI_COLORS[11]);
        this.colors.ansi[12] = this._parseColor(theme.brightBlue, exports.DEFAULT_ANSI_COLORS[12]);
        this.colors.ansi[13] = this._parseColor(theme.brightMagenta, exports.DEFAULT_ANSI_COLORS[13]);
        this.colors.ansi[14] = this._parseColor(theme.brightCyan, exports.DEFAULT_ANSI_COLORS[14]);
        this.colors.ansi[15] = this._parseColor(theme.brightWhite, exports.DEFAULT_ANSI_COLORS[15]);
    };
    ColorManager.prototype._parseColor = function (css, fallback, allowTransparency) {
        if (allowTransparency === void 0) { allowTransparency = this.allowTransparency; }
        if (!css) {
            return fallback;
        }
        this._ctx.fillStyle = this._litmusColor;
        this._ctx.fillStyle = css;
        if (typeof this._ctx.fillStyle !== 'string') {
            console.warn("Color: " + css + " is invalid using fallback " + fallback.css);
            return fallback;
        }
        this._ctx.fillRect(0, 0, 1, 1);
        var data = this._ctx.getImageData(0, 0, 1, 1).data;
        if (!allowTransparency && data[3] !== 0xFF) {
            console.warn("Color: " + css + " is using transparency, but allowTransparency is false. " +
                ("Using fallback " + fallback.css + "."));
            return fallback;
        }
        return {
            css: css,
            rgba: (data[0] << 24 | data[1] << 16 | data[2] << 8 | data[3]) >>> 0
        };
    };
    return ColorManager;
}());
exports.ColorManager = ColorManager;
//# sourceMappingURL=ColorManager.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/renderer/CursorRenderLayer.js":
/*!**************************************************************!*\
  !*** ./node_modules/xterm/lib/renderer/CursorRenderLayer.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Buffer_1 = __webpack_require__(/*! ../Buffer */ "./node_modules/xterm/lib/Buffer.js");
var BaseRenderLayer_1 = __webpack_require__(/*! ./BaseRenderLayer */ "./node_modules/xterm/lib/renderer/BaseRenderLayer.js");
var BLINK_INTERVAL = 600;
var CursorRenderLayer = (function (_super) {
    __extends(CursorRenderLayer, _super);
    function CursorRenderLayer(container, zIndex, colors) {
        var _this = _super.call(this, container, 'cursor', zIndex, true, colors) || this;
        _this._state = {
            x: null,
            y: null,
            isFocused: null,
            style: null,
            width: null
        };
        _this._cursorRenderers = {
            'bar': _this._renderBarCursor.bind(_this),
            'block': _this._renderBlockCursor.bind(_this),
            'underline': _this._renderUnderlineCursor.bind(_this)
        };
        return _this;
    }
    CursorRenderLayer.prototype.resize = function (terminal, dim) {
        _super.prototype.resize.call(this, terminal, dim);
        this._state = {
            x: null,
            y: null,
            isFocused: null,
            style: null,
            width: null
        };
    };
    CursorRenderLayer.prototype.reset = function (terminal) {
        this._clearCursor();
        if (this._cursorBlinkStateManager) {
            this._cursorBlinkStateManager.dispose();
            this._cursorBlinkStateManager = null;
            this.onOptionsChanged(terminal);
        }
    };
    CursorRenderLayer.prototype.onBlur = function (terminal) {
        if (this._cursorBlinkStateManager) {
            this._cursorBlinkStateManager.pause();
        }
        terminal.refresh(terminal.buffer.y, terminal.buffer.y);
    };
    CursorRenderLayer.prototype.onFocus = function (terminal) {
        if (this._cursorBlinkStateManager) {
            this._cursorBlinkStateManager.resume(terminal);
        }
        else {
            terminal.refresh(terminal.buffer.y, terminal.buffer.y);
        }
    };
    CursorRenderLayer.prototype.onOptionsChanged = function (terminal) {
        var _this = this;
        if (terminal.options.cursorBlink) {
            if (!this._cursorBlinkStateManager) {
                this._cursorBlinkStateManager = new CursorBlinkStateManager(terminal, function () {
                    _this._render(terminal, true);
                });
            }
        }
        else {
            if (this._cursorBlinkStateManager) {
                this._cursorBlinkStateManager.dispose();
                this._cursorBlinkStateManager = null;
            }
            terminal.refresh(terminal.buffer.y, terminal.buffer.y);
        }
    };
    CursorRenderLayer.prototype.onCursorMove = function (terminal) {
        if (this._cursorBlinkStateManager) {
            this._cursorBlinkStateManager.restartBlinkAnimation(terminal);
        }
    };
    CursorRenderLayer.prototype.onGridChanged = function (terminal, startRow, endRow) {
        if (!this._cursorBlinkStateManager || this._cursorBlinkStateManager.isPaused) {
            this._render(terminal, false);
        }
        else {
            this._cursorBlinkStateManager.restartBlinkAnimation(terminal);
        }
    };
    CursorRenderLayer.prototype._render = function (terminal, triggeredByAnimationFrame) {
        if (!terminal.cursorState || terminal.cursorHidden) {
            this._clearCursor();
            return;
        }
        var cursorY = terminal.buffer.ybase + terminal.buffer.y;
        var viewportRelativeCursorY = cursorY - terminal.buffer.ydisp;
        if (viewportRelativeCursorY < 0 || viewportRelativeCursorY >= terminal.rows) {
            this._clearCursor();
            return;
        }
        var charData = terminal.buffer.lines.get(cursorY).get(terminal.buffer.x);
        if (!charData) {
            return;
        }
        if (!terminal.isFocused) {
            this._clearCursor();
            this._ctx.save();
            this._ctx.fillStyle = this._colors.cursor.css;
            this._renderBlurCursor(terminal, terminal.buffer.x, viewportRelativeCursorY, charData);
            this._ctx.restore();
            this._state.x = terminal.buffer.x;
            this._state.y = viewportRelativeCursorY;
            this._state.isFocused = false;
            this._state.style = terminal.options.cursorStyle;
            this._state.width = charData[Buffer_1.CHAR_DATA_WIDTH_INDEX];
            return;
        }
        if (this._cursorBlinkStateManager && !this._cursorBlinkStateManager.isCursorVisible) {
            this._clearCursor();
            return;
        }
        if (this._state) {
            if (this._state.x === terminal.buffer.x &&
                this._state.y === viewportRelativeCursorY &&
                this._state.isFocused === terminal.isFocused &&
                this._state.style === terminal.options.cursorStyle &&
                this._state.width === charData[Buffer_1.CHAR_DATA_WIDTH_INDEX]) {
                return;
            }
            this._clearCursor();
        }
        this._ctx.save();
        this._cursorRenderers[terminal.options.cursorStyle || 'block'](terminal, terminal.buffer.x, viewportRelativeCursorY, charData);
        this._ctx.restore();
        this._state.x = terminal.buffer.x;
        this._state.y = viewportRelativeCursorY;
        this._state.isFocused = false;
        this._state.style = terminal.options.cursorStyle;
        this._state.width = charData[Buffer_1.CHAR_DATA_WIDTH_INDEX];
    };
    CursorRenderLayer.prototype._clearCursor = function () {
        if (this._state) {
            this.clearCells(this._state.x, this._state.y, this._state.width, 1);
            this._state = {
                x: null,
                y: null,
                isFocused: null,
                style: null,
                width: null
            };
        }
    };
    CursorRenderLayer.prototype._renderBarCursor = function (terminal, x, y, charData) {
        this._ctx.save();
        this._ctx.fillStyle = this._colors.cursor.css;
        this.fillLeftLineAtCell(x, y);
        this._ctx.restore();
    };
    CursorRenderLayer.prototype._renderBlockCursor = function (terminal, x, y, charData) {
        this._ctx.save();
        this._ctx.fillStyle = this._colors.cursor.css;
        this.fillCells(x, y, charData[Buffer_1.CHAR_DATA_WIDTH_INDEX], 1);
        this._ctx.fillStyle = this._colors.cursorAccent.css;
        this.fillCharTrueColor(terminal, charData, x, y);
        this._ctx.restore();
    };
    CursorRenderLayer.prototype._renderUnderlineCursor = function (terminal, x, y, charData) {
        this._ctx.save();
        this._ctx.fillStyle = this._colors.cursor.css;
        this.fillBottomLineAtCells(x, y);
        this._ctx.restore();
    };
    CursorRenderLayer.prototype._renderBlurCursor = function (terminal, x, y, charData) {
        this._ctx.save();
        this._ctx.strokeStyle = this._colors.cursor.css;
        this.strokeRectAtCell(x, y, charData[Buffer_1.CHAR_DATA_WIDTH_INDEX], 1);
        this._ctx.restore();
    };
    return CursorRenderLayer;
}(BaseRenderLayer_1.BaseRenderLayer));
exports.CursorRenderLayer = CursorRenderLayer;
var CursorBlinkStateManager = (function () {
    function CursorBlinkStateManager(terminal, _renderCallback) {
        this._renderCallback = _renderCallback;
        this.isCursorVisible = true;
        if (terminal.isFocused) {
            this._restartInterval();
        }
    }
    Object.defineProperty(CursorBlinkStateManager.prototype, "isPaused", {
        get: function () { return !(this._blinkStartTimeout || this._blinkInterval); },
        enumerable: true,
        configurable: true
    });
    CursorBlinkStateManager.prototype.dispose = function () {
        if (this._blinkInterval) {
            window.clearInterval(this._blinkInterval);
            this._blinkInterval = null;
        }
        if (this._blinkStartTimeout) {
            window.clearTimeout(this._blinkStartTimeout);
            this._blinkStartTimeout = null;
        }
        if (this._animationFrame) {
            window.cancelAnimationFrame(this._animationFrame);
            this._animationFrame = null;
        }
    };
    CursorBlinkStateManager.prototype.restartBlinkAnimation = function (terminal) {
        var _this = this;
        if (this.isPaused) {
            return;
        }
        this._animationTimeRestarted = Date.now();
        this.isCursorVisible = true;
        if (!this._animationFrame) {
            this._animationFrame = window.requestAnimationFrame(function () {
                _this._renderCallback();
                _this._animationFrame = null;
            });
        }
    };
    CursorBlinkStateManager.prototype._restartInterval = function (timeToStart) {
        var _this = this;
        if (timeToStart === void 0) { timeToStart = BLINK_INTERVAL; }
        if (this._blinkInterval) {
            window.clearInterval(this._blinkInterval);
        }
        this._blinkStartTimeout = setTimeout(function () {
            if (_this._animationTimeRestarted) {
                var time = BLINK_INTERVAL - (Date.now() - _this._animationTimeRestarted);
                _this._animationTimeRestarted = null;
                if (time > 0) {
                    _this._restartInterval(time);
                    return;
                }
            }
            _this.isCursorVisible = false;
            _this._animationFrame = window.requestAnimationFrame(function () {
                _this._renderCallback();
                _this._animationFrame = null;
            });
            _this._blinkInterval = setInterval(function () {
                if (_this._animationTimeRestarted) {
                    var time = BLINK_INTERVAL - (Date.now() - _this._animationTimeRestarted);
                    _this._animationTimeRestarted = null;
                    _this._restartInterval(time);
                    return;
                }
                _this.isCursorVisible = !_this.isCursorVisible;
                _this._animationFrame = window.requestAnimationFrame(function () {
                    _this._renderCallback();
                    _this._animationFrame = null;
                });
            }, BLINK_INTERVAL);
        }, timeToStart);
    };
    CursorBlinkStateManager.prototype.pause = function () {
        this.isCursorVisible = true;
        if (this._blinkInterval) {
            window.clearInterval(this._blinkInterval);
            this._blinkInterval = null;
        }
        if (this._blinkStartTimeout) {
            window.clearTimeout(this._blinkStartTimeout);
            this._blinkStartTimeout = null;
        }
        if (this._animationFrame) {
            window.cancelAnimationFrame(this._animationFrame);
            this._animationFrame = null;
        }
    };
    CursorBlinkStateManager.prototype.resume = function (terminal) {
        this._animationTimeRestarted = null;
        this._restartInterval();
        this.restartBlinkAnimation(terminal);
    };
    return CursorBlinkStateManager;
}());
//# sourceMappingURL=CursorRenderLayer.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/renderer/GridCache.js":
/*!******************************************************!*\
  !*** ./node_modules/xterm/lib/renderer/GridCache.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var GridCache = (function () {
    function GridCache() {
        this.cache = [];
    }
    GridCache.prototype.resize = function (width, height) {
        for (var x = 0; x < width; x++) {
            if (this.cache.length <= x) {
                this.cache.push([]);
            }
            for (var y = this.cache[x].length; y < height; y++) {
                this.cache[x].push(null);
            }
            this.cache[x].length = height;
        }
        this.cache.length = width;
    };
    GridCache.prototype.clear = function () {
        for (var x = 0; x < this.cache.length; x++) {
            for (var y = 0; y < this.cache[x].length; y++) {
                this.cache[x][y] = null;
            }
        }
    };
    return GridCache;
}());
exports.GridCache = GridCache;
//# sourceMappingURL=GridCache.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/renderer/LinkRenderLayer.js":
/*!************************************************************!*\
  !*** ./node_modules/xterm/lib/renderer/LinkRenderLayer.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BaseRenderLayer_1 = __webpack_require__(/*! ./BaseRenderLayer */ "./node_modules/xterm/lib/renderer/BaseRenderLayer.js");
var Types_1 = __webpack_require__(/*! ./atlas/Types */ "./node_modules/xterm/lib/renderer/atlas/Types.js");
var LinkRenderLayer = (function (_super) {
    __extends(LinkRenderLayer, _super);
    function LinkRenderLayer(container, zIndex, colors, terminal) {
        var _this = _super.call(this, container, 'link', zIndex, true, colors) || this;
        _this._state = null;
        terminal.linkifier.on("linkhover", function (e) { return _this._onLinkHover(e); });
        terminal.linkifier.on("linkleave", function (e) { return _this._onLinkLeave(e); });
        return _this;
    }
    LinkRenderLayer.prototype.resize = function (terminal, dim) {
        _super.prototype.resize.call(this, terminal, dim);
        this._state = null;
    };
    LinkRenderLayer.prototype.reset = function (terminal) {
        this._clearCurrentLink();
    };
    LinkRenderLayer.prototype._clearCurrentLink = function () {
        if (this._state) {
            this.clearCells(this._state.x1, this._state.y1, this._state.cols - this._state.x1, 1);
            var middleRowCount = this._state.y2 - this._state.y1 - 1;
            if (middleRowCount > 0) {
                this.clearCells(0, this._state.y1 + 1, this._state.cols, middleRowCount);
            }
            this.clearCells(0, this._state.y2, this._state.x2, 1);
            this._state = null;
        }
    };
    LinkRenderLayer.prototype._onLinkHover = function (e) {
        if (e.fg === Types_1.INVERTED_DEFAULT_COLOR) {
            this._ctx.fillStyle = this._colors.background.css;
        }
        else if (e.fg < 256) {
            this._ctx.fillStyle = this._colors.ansi[e.fg].css;
        }
        else {
            this._ctx.fillStyle = this._colors.foreground.css;
        }
        if (e.y1 === e.y2) {
            this.fillBottomLineAtCells(e.x1, e.y1, e.x2 - e.x1);
        }
        else {
            this.fillBottomLineAtCells(e.x1, e.y1, e.cols - e.x1);
            for (var y = e.y1 + 1; y < e.y2; y++) {
                this.fillBottomLineAtCells(0, y, e.cols);
            }
            this.fillBottomLineAtCells(0, e.y2, e.x2);
        }
        this._state = e;
    };
    LinkRenderLayer.prototype._onLinkLeave = function (e) {
        this._clearCurrentLink();
    };
    return LinkRenderLayer;
}(BaseRenderLayer_1.BaseRenderLayer));
exports.LinkRenderLayer = LinkRenderLayer;
//# sourceMappingURL=LinkRenderLayer.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/renderer/Renderer.js":
/*!*****************************************************!*\
  !*** ./node_modules/xterm/lib/renderer/Renderer.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var TextRenderLayer_1 = __webpack_require__(/*! ./TextRenderLayer */ "./node_modules/xterm/lib/renderer/TextRenderLayer.js");
var SelectionRenderLayer_1 = __webpack_require__(/*! ./SelectionRenderLayer */ "./node_modules/xterm/lib/renderer/SelectionRenderLayer.js");
var CursorRenderLayer_1 = __webpack_require__(/*! ./CursorRenderLayer */ "./node_modules/xterm/lib/renderer/CursorRenderLayer.js");
var ColorManager_1 = __webpack_require__(/*! ./ColorManager */ "./node_modules/xterm/lib/renderer/ColorManager.js");
var LinkRenderLayer_1 = __webpack_require__(/*! ./LinkRenderLayer */ "./node_modules/xterm/lib/renderer/LinkRenderLayer.js");
var EventEmitter_1 = __webpack_require__(/*! ../common/EventEmitter */ "./node_modules/xterm/lib/common/EventEmitter.js");
var RenderDebouncer_1 = __webpack_require__(/*! ../ui/RenderDebouncer */ "./node_modules/xterm/lib/ui/RenderDebouncer.js");
var ScreenDprMonitor_1 = __webpack_require__(/*! ../ui/ScreenDprMonitor */ "./node_modules/xterm/lib/ui/ScreenDprMonitor.js");
var CharacterJoinerRegistry_1 = __webpack_require__(/*! ../renderer/CharacterJoinerRegistry */ "./node_modules/xterm/lib/renderer/CharacterJoinerRegistry.js");
var Renderer = (function (_super) {
    __extends(Renderer, _super);
    function Renderer(_terminal, theme) {
        var _this = _super.call(this) || this;
        _this._terminal = _terminal;
        _this._isPaused = false;
        _this._needsFullRefresh = false;
        var allowTransparency = _this._terminal.options.allowTransparency;
        _this.colorManager = new ColorManager_1.ColorManager(document, allowTransparency);
        _this._characterJoinerRegistry = new CharacterJoinerRegistry_1.CharacterJoinerRegistry(_terminal);
        if (theme) {
            _this.colorManager.setTheme(theme);
        }
        _this._renderLayers = [
            new TextRenderLayer_1.TextRenderLayer(_this._terminal.screenElement, 0, _this.colorManager.colors, _this._characterJoinerRegistry, allowTransparency),
            new SelectionRenderLayer_1.SelectionRenderLayer(_this._terminal.screenElement, 1, _this.colorManager.colors),
            new LinkRenderLayer_1.LinkRenderLayer(_this._terminal.screenElement, 2, _this.colorManager.colors, _this._terminal),
            new CursorRenderLayer_1.CursorRenderLayer(_this._terminal.screenElement, 3, _this.colorManager.colors)
        ];
        _this.dimensions = {
            scaledCharWidth: null,
            scaledCharHeight: null,
            scaledCellWidth: null,
            scaledCellHeight: null,
            scaledCharLeft: null,
            scaledCharTop: null,
            scaledCanvasWidth: null,
            scaledCanvasHeight: null,
            canvasWidth: null,
            canvasHeight: null,
            actualCellWidth: null,
            actualCellHeight: null
        };
        _this._devicePixelRatio = window.devicePixelRatio;
        _this._updateDimensions();
        _this.onOptionsChanged();
        _this._renderDebouncer = new RenderDebouncer_1.RenderDebouncer(_this._terminal, _this._renderRows.bind(_this));
        _this._screenDprMonitor = new ScreenDprMonitor_1.ScreenDprMonitor();
        _this._screenDprMonitor.setListener(function () { return _this.onWindowResize(window.devicePixelRatio); });
        _this.register(_this._screenDprMonitor);
        if ('IntersectionObserver' in window) {
            var observer_1 = new IntersectionObserver(function (e) { return _this.onIntersectionChange(e[0]); }, { threshold: 0 });
            observer_1.observe(_this._terminal.element);
            _this.register({ dispose: function () { return observer_1.disconnect(); } });
        }
        return _this;
    }
    Renderer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._renderLayers.forEach(function (l) { return l.dispose(); });
    };
    Renderer.prototype.onIntersectionChange = function (entry) {
        this._isPaused = entry.intersectionRatio === 0;
        if (!this._isPaused && this._needsFullRefresh) {
            this._terminal.refresh(0, this._terminal.rows - 1);
        }
    };
    Renderer.prototype.onWindowResize = function (devicePixelRatio) {
        if (this._devicePixelRatio !== devicePixelRatio) {
            this._devicePixelRatio = devicePixelRatio;
            this.onResize(this._terminal.cols, this._terminal.rows);
        }
    };
    Renderer.prototype.setTheme = function (theme) {
        var _this = this;
        this.colorManager.setTheme(theme);
        this._renderLayers.forEach(function (l) {
            l.onThemeChanged(_this._terminal, _this.colorManager.colors);
            l.reset(_this._terminal);
        });
        if (this._isPaused) {
            this._needsFullRefresh = true;
        }
        else {
            this._terminal.refresh(0, this._terminal.rows - 1);
        }
        return this.colorManager.colors;
    };
    Renderer.prototype.onResize = function (cols, rows) {
        var _this = this;
        this._updateDimensions();
        this._renderLayers.forEach(function (l) { return l.resize(_this._terminal, _this.dimensions); });
        if (this._isPaused) {
            this._needsFullRefresh = true;
        }
        else {
            this._terminal.refresh(0, this._terminal.rows - 1);
        }
        this._terminal.screenElement.style.width = this.dimensions.canvasWidth + "px";
        this._terminal.screenElement.style.height = this.dimensions.canvasHeight + "px";
        this.emit('resize', {
            width: this.dimensions.canvasWidth,
            height: this.dimensions.canvasHeight
        });
    };
    Renderer.prototype.onCharSizeChanged = function () {
        this.onResize(this._terminal.cols, this._terminal.rows);
    };
    Renderer.prototype.onBlur = function () {
        var _this = this;
        this._runOperation(function (l) { return l.onBlur(_this._terminal); });
    };
    Renderer.prototype.onFocus = function () {
        var _this = this;
        this._runOperation(function (l) { return l.onFocus(_this._terminal); });
    };
    Renderer.prototype.onSelectionChanged = function (start, end, columnSelectMode) {
        var _this = this;
        if (columnSelectMode === void 0) { columnSelectMode = false; }
        this._runOperation(function (l) { return l.onSelectionChanged(_this._terminal, start, end, columnSelectMode); });
    };
    Renderer.prototype.onCursorMove = function () {
        var _this = this;
        this._runOperation(function (l) { return l.onCursorMove(_this._terminal); });
    };
    Renderer.prototype.onOptionsChanged = function () {
        var _this = this;
        this.colorManager.allowTransparency = this._terminal.options.allowTransparency;
        this._runOperation(function (l) { return l.onOptionsChanged(_this._terminal); });
    };
    Renderer.prototype.clear = function () {
        var _this = this;
        this._runOperation(function (l) { return l.reset(_this._terminal); });
    };
    Renderer.prototype._runOperation = function (operation) {
        if (this._isPaused) {
            this._needsFullRefresh = true;
        }
        else {
            this._renderLayers.forEach(function (l) { return operation(l); });
        }
    };
    Renderer.prototype.refreshRows = function (start, end) {
        if (this._isPaused) {
            this._needsFullRefresh = true;
            return;
        }
        this._renderDebouncer.refresh(start, end);
    };
    Renderer.prototype._renderRows = function (start, end) {
        var _this = this;
        this._renderLayers.forEach(function (l) { return l.onGridChanged(_this._terminal, start, end); });
        this._terminal.emit('refresh', { start: start, end: end });
    };
    Renderer.prototype._updateDimensions = function () {
        if (!this._terminal.charMeasure.width || !this._terminal.charMeasure.height) {
            return;
        }
        this.dimensions.scaledCharWidth = Math.floor(this._terminal.charMeasure.width * window.devicePixelRatio);
        this.dimensions.scaledCharHeight = Math.ceil(this._terminal.charMeasure.height * window.devicePixelRatio);
        this.dimensions.scaledCellHeight = Math.floor(this.dimensions.scaledCharHeight * this._terminal.options.lineHeight);
        this.dimensions.scaledCharTop = this._terminal.options.lineHeight === 1 ? 0 : Math.round((this.dimensions.scaledCellHeight - this.dimensions.scaledCharHeight) / 2);
        this.dimensions.scaledCellWidth = this.dimensions.scaledCharWidth + Math.round(this._terminal.options.letterSpacing);
        this.dimensions.scaledCharLeft = Math.floor(this._terminal.options.letterSpacing / 2);
        this.dimensions.scaledCanvasHeight = this._terminal.rows * this.dimensions.scaledCellHeight;
        this.dimensions.scaledCanvasWidth = this._terminal.cols * this.dimensions.scaledCellWidth;
        this.dimensions.canvasHeight = Math.round(this.dimensions.scaledCanvasHeight / window.devicePixelRatio);
        this.dimensions.canvasWidth = Math.round(this.dimensions.scaledCanvasWidth / window.devicePixelRatio);
        this.dimensions.actualCellHeight = this.dimensions.canvasHeight / this._terminal.rows;
        this.dimensions.actualCellWidth = this.dimensions.canvasWidth / this._terminal.cols;
    };
    Renderer.prototype.registerCharacterJoiner = function (handler) {
        return this._characterJoinerRegistry.registerCharacterJoiner(handler);
    };
    Renderer.prototype.deregisterCharacterJoiner = function (joinerId) {
        return this._characterJoinerRegistry.deregisterCharacterJoiner(joinerId);
    };
    return Renderer;
}(EventEmitter_1.EventEmitter));
exports.Renderer = Renderer;
//# sourceMappingURL=Renderer.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/renderer/SelectionRenderLayer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/xterm/lib/renderer/SelectionRenderLayer.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BaseRenderLayer_1 = __webpack_require__(/*! ./BaseRenderLayer */ "./node_modules/xterm/lib/renderer/BaseRenderLayer.js");
var SelectionRenderLayer = (function (_super) {
    __extends(SelectionRenderLayer, _super);
    function SelectionRenderLayer(container, zIndex, colors) {
        var _this = _super.call(this, container, 'selection', zIndex, true, colors) || this;
        _this._clearState();
        return _this;
    }
    SelectionRenderLayer.prototype._clearState = function () {
        this._state = {
            start: null,
            end: null,
            columnSelectMode: null,
            ydisp: null
        };
    };
    SelectionRenderLayer.prototype.resize = function (terminal, dim) {
        _super.prototype.resize.call(this, terminal, dim);
        this._clearState();
    };
    SelectionRenderLayer.prototype.reset = function (terminal) {
        if (this._state.start && this._state.end) {
            this._clearState();
            this.clearAll();
        }
    };
    SelectionRenderLayer.prototype.onSelectionChanged = function (terminal, start, end, columnSelectMode) {
        if (!this._didStateChange(start, end, columnSelectMode, terminal.buffer.ydisp)) {
            return;
        }
        this.clearAll();
        if (!start || !end) {
            return;
        }
        var viewportStartRow = start[1] - terminal.buffer.ydisp;
        var viewportEndRow = end[1] - terminal.buffer.ydisp;
        var viewportCappedStartRow = Math.max(viewportStartRow, 0);
        var viewportCappedEndRow = Math.min(viewportEndRow, terminal.rows - 1);
        if (viewportCappedStartRow >= terminal.rows || viewportCappedEndRow < 0) {
            return;
        }
        this._ctx.fillStyle = this._colors.selection.css;
        if (columnSelectMode) {
            var startCol = start[0];
            var width = end[0] - startCol;
            var height = viewportCappedEndRow - viewportCappedStartRow + 1;
            this.fillCells(startCol, viewportCappedStartRow, width, height);
        }
        else {
            var startCol = viewportStartRow === viewportCappedStartRow ? start[0] : 0;
            var startRowEndCol = viewportCappedStartRow === viewportCappedEndRow ? end[0] : terminal.cols;
            this.fillCells(startCol, viewportCappedStartRow, startRowEndCol - startCol, 1);
            var middleRowsCount = Math.max(viewportCappedEndRow - viewportCappedStartRow - 1, 0);
            this.fillCells(0, viewportCappedStartRow + 1, terminal.cols, middleRowsCount);
            if (viewportCappedStartRow !== viewportCappedEndRow) {
                var endCol = viewportEndRow === viewportCappedEndRow ? end[0] : terminal.cols;
                this.fillCells(0, viewportCappedEndRow, endCol, 1);
            }
        }
        this._state.start = [start[0], start[1]];
        this._state.end = [end[0], end[1]];
        this._state.columnSelectMode = columnSelectMode;
        this._state.ydisp = terminal.buffer.ydisp;
    };
    SelectionRenderLayer.prototype._didStateChange = function (start, end, columnSelectMode, ydisp) {
        return !this._areCoordinatesEqual(start, this._state.start) ||
            !this._areCoordinatesEqual(end, this._state.end) ||
            columnSelectMode !== this._state.columnSelectMode ||
            ydisp !== this._state.ydisp;
    };
    SelectionRenderLayer.prototype._areCoordinatesEqual = function (coord1, coord2) {
        if (!coord1 || !coord2) {
            return false;
        }
        return coord1[0] === coord2[0] && coord1[1] === coord2[1];
    };
    return SelectionRenderLayer;
}(BaseRenderLayer_1.BaseRenderLayer));
exports.SelectionRenderLayer = SelectionRenderLayer;
//# sourceMappingURL=SelectionRenderLayer.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/renderer/TextRenderLayer.js":
/*!************************************************************!*\
  !*** ./node_modules/xterm/lib/renderer/TextRenderLayer.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Buffer_1 = __webpack_require__(/*! ../Buffer */ "./node_modules/xterm/lib/Buffer.js");
var Types_1 = __webpack_require__(/*! ./atlas/Types */ "./node_modules/xterm/lib/renderer/atlas/Types.js");
var GridCache_1 = __webpack_require__(/*! ./GridCache */ "./node_modules/xterm/lib/renderer/GridCache.js");
var BaseRenderLayer_1 = __webpack_require__(/*! ./BaseRenderLayer */ "./node_modules/xterm/lib/renderer/BaseRenderLayer.js");
var TextRenderLayer = (function (_super) {
    __extends(TextRenderLayer, _super);
    function TextRenderLayer(container, zIndex, colors, characterJoinerRegistry, alpha) {
        var _this = _super.call(this, container, 'text', zIndex, alpha, colors) || this;
        _this._characterOverlapCache = {};
        _this._state = new GridCache_1.GridCache();
        _this._characterJoinerRegistry = characterJoinerRegistry;
        return _this;
    }
    TextRenderLayer.prototype.resize = function (terminal, dim) {
        _super.prototype.resize.call(this, terminal, dim);
        var terminalFont = this._getFont(terminal, false, false);
        if (this._characterWidth !== dim.scaledCharWidth || this._characterFont !== terminalFont) {
            this._characterWidth = dim.scaledCharWidth;
            this._characterFont = terminalFont;
            this._characterOverlapCache = {};
        }
        this._state.clear();
        this._state.resize(terminal.cols, terminal.rows);
    };
    TextRenderLayer.prototype.reset = function (terminal) {
        this._state.clear();
        this.clearAll();
    };
    TextRenderLayer.prototype._forEachCell = function (terminal, firstRow, lastRow, joinerRegistry, callback) {
        for (var y = firstRow; y <= lastRow; y++) {
            var row = y + terminal.buffer.ydisp;
            var line = terminal.buffer.lines.get(row);
            var joinedRanges = joinerRegistry ? joinerRegistry.getJoinedCharacters(row) : [];
            for (var x = 0; x < terminal.cols; x++) {
                var charData = line.get(x);
                var code = charData[Buffer_1.CHAR_DATA_CODE_INDEX];
                var chars = charData[Buffer_1.CHAR_DATA_CHAR_INDEX];
                var attr = charData[Buffer_1.CHAR_DATA_ATTR_INDEX];
                var width = charData[Buffer_1.CHAR_DATA_WIDTH_INDEX];
                var isJoined = false;
                var lastCharX = x;
                if (width === 0) {
                    continue;
                }
                if (joinedRanges.length > 0 && x === joinedRanges[0][0]) {
                    isJoined = true;
                    var range = joinedRanges.shift();
                    chars = terminal.buffer.translateBufferLineToString(row, true, range[0], range[1]);
                    width = range[1] - range[0];
                    code = Infinity;
                    lastCharX = range[1] - 1;
                }
                if (!isJoined && this._isOverlapping(charData)) {
                    if (lastCharX < line.length - 1 && line.get(lastCharX + 1)[Buffer_1.CHAR_DATA_CODE_INDEX] === Buffer_1.NULL_CELL_CODE) {
                        width = 2;
                    }
                }
                var flags = attr >> 18;
                var bg = attr & 0x1ff;
                var fg = (attr >> 9) & 0x1ff;
                if (flags & 8) {
                    var temp = bg;
                    bg = fg;
                    fg = temp;
                    if (fg === 256) {
                        fg = Types_1.INVERTED_DEFAULT_COLOR;
                    }
                    if (bg === 257) {
                        bg = Types_1.INVERTED_DEFAULT_COLOR;
                    }
                }
                callback(code, chars, width, x, y, fg, bg, flags);
                x = lastCharX;
            }
        }
    };
    TextRenderLayer.prototype._drawBackground = function (terminal, firstRow, lastRow) {
        var _this = this;
        var ctx = this._ctx;
        var cols = terminal.cols;
        var startX = 0;
        var startY = 0;
        var prevFillStyle = null;
        ctx.save();
        this._forEachCell(terminal, firstRow, lastRow, null, function (code, chars, width, x, y, fg, bg, flags) {
            var nextFillStyle = null;
            if (bg === Types_1.INVERTED_DEFAULT_COLOR) {
                nextFillStyle = _this._colors.foreground.css;
            }
            else if (bg < 256) {
                nextFillStyle = _this._colors.ansi[bg].css;
            }
            if (prevFillStyle === null) {
                startX = x;
                startY = y;
            }
            if (y !== startY) {
                ctx.fillStyle = prevFillStyle;
                _this.fillCells(startX, startY, cols - startX, 1);
                startX = x;
                startY = y;
            }
            else if (prevFillStyle !== nextFillStyle) {
                ctx.fillStyle = prevFillStyle;
                _this.fillCells(startX, startY, x - startX, 1);
                startX = x;
                startY = y;
            }
            prevFillStyle = nextFillStyle;
        });
        if (prevFillStyle !== null) {
            ctx.fillStyle = prevFillStyle;
            this.fillCells(startX, startY, cols - startX, 1);
        }
        ctx.restore();
    };
    TextRenderLayer.prototype._drawForeground = function (terminal, firstRow, lastRow) {
        var _this = this;
        this._forEachCell(terminal, firstRow, lastRow, this._characterJoinerRegistry, function (code, chars, width, x, y, fg, bg, flags) {
            if (flags & 16) {
                return;
            }
            if (flags & 2) {
                _this._ctx.save();
                if (fg === Types_1.INVERTED_DEFAULT_COLOR) {
                    _this._ctx.fillStyle = _this._colors.background.css;
                }
                else if (fg < 256) {
                    _this._ctx.fillStyle = _this._colors.ansi[fg].css;
                }
                else {
                    _this._ctx.fillStyle = _this._colors.foreground.css;
                }
                _this.fillBottomLineAtCells(x, y, width);
                _this._ctx.restore();
            }
            _this.drawChars(terminal, chars, code, width, x, y, fg, bg, !!(flags & 1), !!(flags & 32), !!(flags & 64));
        });
    };
    TextRenderLayer.prototype.onGridChanged = function (terminal, firstRow, lastRow) {
        if (this._state.cache.length === 0) {
            return;
        }
        if (this._charAtlas) {
            this._charAtlas.beginFrame();
        }
        this.clearCells(0, firstRow, terminal.cols, lastRow - firstRow + 1);
        this._drawBackground(terminal, firstRow, lastRow);
        this._drawForeground(terminal, firstRow, lastRow);
    };
    TextRenderLayer.prototype.onOptionsChanged = function (terminal) {
        this.setTransparency(terminal, terminal.options.allowTransparency);
    };
    TextRenderLayer.prototype._isOverlapping = function (charData) {
        if (charData[Buffer_1.CHAR_DATA_WIDTH_INDEX] !== 1) {
            return false;
        }
        var code = charData[Buffer_1.CHAR_DATA_CODE_INDEX];
        if (code < 256) {
            return false;
        }
        var char = charData[Buffer_1.CHAR_DATA_CHAR_INDEX];
        if (this._characterOverlapCache.hasOwnProperty(char)) {
            return this._characterOverlapCache[char];
        }
        this._ctx.save();
        this._ctx.font = this._characterFont;
        var overlaps = Math.floor(this._ctx.measureText(char).width) > this._characterWidth;
        this._ctx.restore();
        this._characterOverlapCache[char] = overlaps;
        return overlaps;
    };
    return TextRenderLayer;
}(BaseRenderLayer_1.BaseRenderLayer));
exports.TextRenderLayer = TextRenderLayer;
//# sourceMappingURL=TextRenderLayer.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/renderer/atlas/BaseCharAtlas.js":
/*!****************************************************************!*\
  !*** ./node_modules/xterm/lib/renderer/atlas/BaseCharAtlas.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var BaseCharAtlas = (function () {
    function BaseCharAtlas() {
        this._didWarmUp = false;
    }
    BaseCharAtlas.prototype.dispose = function () { };
    BaseCharAtlas.prototype.warmUp = function () {
        if (!this._didWarmUp) {
            this._doWarmUp();
            this._didWarmUp = true;
        }
    };
    BaseCharAtlas.prototype._doWarmUp = function () { };
    BaseCharAtlas.prototype.beginFrame = function () { };
    return BaseCharAtlas;
}());
exports.default = BaseCharAtlas;
//# sourceMappingURL=BaseCharAtlas.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/renderer/atlas/CharAtlasCache.js":
/*!*****************************************************************!*\
  !*** ./node_modules/xterm/lib/renderer/atlas/CharAtlasCache.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var CharAtlasUtils_1 = __webpack_require__(/*! ./CharAtlasUtils */ "./node_modules/xterm/lib/renderer/atlas/CharAtlasUtils.js");
var DynamicCharAtlas_1 = __webpack_require__(/*! ./DynamicCharAtlas */ "./node_modules/xterm/lib/renderer/atlas/DynamicCharAtlas.js");
var NoneCharAtlas_1 = __webpack_require__(/*! ./NoneCharAtlas */ "./node_modules/xterm/lib/renderer/atlas/NoneCharAtlas.js");
var StaticCharAtlas_1 = __webpack_require__(/*! ./StaticCharAtlas */ "./node_modules/xterm/lib/renderer/atlas/StaticCharAtlas.js");
var charAtlasImplementations = {
    'none': NoneCharAtlas_1.default,
    'static': StaticCharAtlas_1.default,
    'dynamic': DynamicCharAtlas_1.default
};
var charAtlasCache = [];
function acquireCharAtlas(terminal, colors, scaledCharWidth, scaledCharHeight) {
    var newConfig = CharAtlasUtils_1.generateConfig(scaledCharWidth, scaledCharHeight, terminal, colors);
    for (var i = 0; i < charAtlasCache.length; i++) {
        var entry = charAtlasCache[i];
        var ownedByIndex = entry.ownedBy.indexOf(terminal);
        if (ownedByIndex >= 0) {
            if (CharAtlasUtils_1.configEquals(entry.config, newConfig)) {
                return entry.atlas;
            }
            if (entry.ownedBy.length === 1) {
                charAtlasCache.splice(i, 1);
            }
            else {
                entry.ownedBy.splice(ownedByIndex, 1);
            }
            break;
        }
    }
    for (var i = 0; i < charAtlasCache.length; i++) {
        var entry = charAtlasCache[i];
        if (CharAtlasUtils_1.configEquals(entry.config, newConfig)) {
            entry.ownedBy.push(terminal);
            return entry.atlas;
        }
    }
    var newEntry = {
        atlas: new charAtlasImplementations[terminal.options.experimentalCharAtlas](document, newConfig),
        config: newConfig,
        ownedBy: [terminal]
    };
    charAtlasCache.push(newEntry);
    return newEntry.atlas;
}
exports.acquireCharAtlas = acquireCharAtlas;
function removeTerminalFromCache(terminal) {
    for (var i = 0; i < charAtlasCache.length; i++) {
        var index = charAtlasCache[i].ownedBy.indexOf(terminal);
        if (index !== -1) {
            if (charAtlasCache[i].ownedBy.length === 1) {
                charAtlasCache.splice(i, 1);
            }
            else {
                charAtlasCache[i].ownedBy.splice(index, 1);
            }
            break;
        }
    }
}
exports.removeTerminalFromCache = removeTerminalFromCache;
//# sourceMappingURL=CharAtlasCache.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/renderer/atlas/CharAtlasUtils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/xterm/lib/renderer/atlas/CharAtlasUtils.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function generateConfig(scaledCharWidth, scaledCharHeight, terminal, colors) {
    var clonedColors = {
        foreground: colors.foreground,
        background: colors.background,
        cursor: null,
        cursorAccent: null,
        selection: null,
        ansi: colors.ansi.slice(0, 16)
    };
    return {
        type: terminal.options.experimentalCharAtlas,
        devicePixelRatio: window.devicePixelRatio,
        scaledCharWidth: scaledCharWidth,
        scaledCharHeight: scaledCharHeight,
        fontFamily: terminal.options.fontFamily,
        fontSize: terminal.options.fontSize,
        fontWeight: terminal.options.fontWeight,
        fontWeightBold: terminal.options.fontWeightBold,
        allowTransparency: terminal.options.allowTransparency,
        colors: clonedColors
    };
}
exports.generateConfig = generateConfig;
function configEquals(a, b) {
    for (var i = 0; i < a.colors.ansi.length; i++) {
        if (a.colors.ansi[i].rgba !== b.colors.ansi[i].rgba) {
            return false;
        }
    }
    return a.type === b.type &&
        a.devicePixelRatio === b.devicePixelRatio &&
        a.fontFamily === b.fontFamily &&
        a.fontSize === b.fontSize &&
        a.fontWeight === b.fontWeight &&
        a.fontWeightBold === b.fontWeightBold &&
        a.allowTransparency === b.allowTransparency &&
        a.scaledCharWidth === b.scaledCharWidth &&
        a.scaledCharHeight === b.scaledCharHeight &&
        a.colors.foreground === b.colors.foreground &&
        a.colors.background === b.colors.background;
}
exports.configEquals = configEquals;
//# sourceMappingURL=CharAtlasUtils.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/renderer/atlas/DynamicCharAtlas.js":
/*!*******************************************************************!*\
  !*** ./node_modules/xterm/lib/renderer/atlas/DynamicCharAtlas.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Types_1 = __webpack_require__(/*! ./Types */ "./node_modules/xterm/lib/renderer/atlas/Types.js");
var BaseCharAtlas_1 = __webpack_require__(/*! ./BaseCharAtlas */ "./node_modules/xterm/lib/renderer/atlas/BaseCharAtlas.js");
var ColorManager_1 = __webpack_require__(/*! ../ColorManager */ "./node_modules/xterm/lib/renderer/ColorManager.js");
var CharAtlasGenerator_1 = __webpack_require__(/*! ../../shared/atlas/CharAtlasGenerator */ "./node_modules/xterm/lib/shared/atlas/CharAtlasGenerator.js");
var LRUMap_1 = __webpack_require__(/*! ./LRUMap */ "./node_modules/xterm/lib/renderer/atlas/LRUMap.js");
var Browser_1 = __webpack_require__(/*! ../../shared/utils/Browser */ "./node_modules/xterm/lib/shared/utils/Browser.js");
var TEXTURE_WIDTH = 1024;
var TEXTURE_HEIGHT = 1024;
var TRANSPARENT_COLOR = {
    css: 'rgba(0, 0, 0, 0)',
    rgba: 0
};
var FRAME_CACHE_DRAW_LIMIT = 100;
var GLYPH_BITMAP_COMMIT_DELAY = 100;
function getGlyphCacheKey(glyph) {
    return glyph.code << 21 | glyph.bg << 12 | glyph.fg << 3 | (glyph.bold ? 0 : 4) + (glyph.dim ? 0 : 2) + (glyph.italic ? 0 : 1);
}
var DynamicCharAtlas = (function (_super) {
    __extends(DynamicCharAtlas, _super);
    function DynamicCharAtlas(document, _config) {
        var _this = _super.call(this) || this;
        _this._config = _config;
        _this._drawToCacheCount = 0;
        _this._glyphsWaitingOnBitmap = [];
        _this._bitmapCommitTimeout = null;
        _this._bitmap = null;
        _this._cacheCanvas = document.createElement('canvas');
        _this._cacheCanvas.width = TEXTURE_WIDTH;
        _this._cacheCanvas.height = TEXTURE_HEIGHT;
        _this._cacheCtx = _this._cacheCanvas.getContext('2d', { alpha: true });
        var tmpCanvas = document.createElement('canvas');
        tmpCanvas.width = _this._config.scaledCharWidth;
        tmpCanvas.height = _this._config.scaledCharHeight;
        _this._tmpCtx = tmpCanvas.getContext('2d', { alpha: _this._config.allowTransparency });
        _this._width = Math.floor(TEXTURE_WIDTH / _this._config.scaledCharWidth);
        _this._height = Math.floor(TEXTURE_HEIGHT / _this._config.scaledCharHeight);
        var capacity = _this._width * _this._height;
        _this._cacheMap = new LRUMap_1.default(capacity);
        _this._cacheMap.prealloc(capacity);
        return _this;
    }
    DynamicCharAtlas.prototype.dispose = function () {
        if (this._bitmapCommitTimeout !== null) {
            window.clearTimeout(this._bitmapCommitTimeout);
            this._bitmapCommitTimeout = null;
        }
    };
    DynamicCharAtlas.prototype.beginFrame = function () {
        this._drawToCacheCount = 0;
    };
    DynamicCharAtlas.prototype.draw = function (ctx, glyph, x, y) {
        if (glyph.code === 32) {
            return true;
        }
        var glyphKey = getGlyphCacheKey(glyph);
        var cacheValue = this._cacheMap.get(glyphKey);
        if (cacheValue !== null && cacheValue !== undefined) {
            this._drawFromCache(ctx, cacheValue, x, y);
            return true;
        }
        else if (this._canCache(glyph) && this._drawToCacheCount < FRAME_CACHE_DRAW_LIMIT) {
            var index = void 0;
            if (this._cacheMap.size < this._cacheMap.capacity) {
                index = this._cacheMap.size;
            }
            else {
                index = this._cacheMap.peek().index;
            }
            var cacheValue_1 = this._drawToCache(glyph, index);
            this._cacheMap.set(glyphKey, cacheValue_1);
            this._drawFromCache(ctx, cacheValue_1, x, y);
            return true;
        }
        return false;
    };
    DynamicCharAtlas.prototype._canCache = function (glyph) {
        return glyph.code < 256;
    };
    DynamicCharAtlas.prototype._toCoordinateX = function (index) {
        return (index % this._width) * this._config.scaledCharWidth;
    };
    DynamicCharAtlas.prototype._toCoordinateY = function (index) {
        return Math.floor(index / this._width) * this._config.scaledCharHeight;
    };
    DynamicCharAtlas.prototype._drawFromCache = function (ctx, cacheValue, x, y) {
        if (cacheValue.isEmpty) {
            return;
        }
        var cacheX = this._toCoordinateX(cacheValue.index);
        var cacheY = this._toCoordinateY(cacheValue.index);
        ctx.drawImage(cacheValue.inBitmap ? this._bitmap : this._cacheCanvas, cacheX, cacheY, this._config.scaledCharWidth, this._config.scaledCharHeight, x, y, this._config.scaledCharWidth, this._config.scaledCharHeight);
    };
    DynamicCharAtlas.prototype._getColorFromAnsiIndex = function (idx) {
        if (idx < this._config.colors.ansi.length) {
            return this._config.colors.ansi[idx];
        }
        return ColorManager_1.DEFAULT_ANSI_COLORS[idx];
    };
    DynamicCharAtlas.prototype._getBackgroundColor = function (glyph) {
        if (this._config.allowTransparency) {
            return TRANSPARENT_COLOR;
        }
        else if (glyph.bg === Types_1.INVERTED_DEFAULT_COLOR) {
            return this._config.colors.foreground;
        }
        else if (glyph.bg < 256) {
            return this._getColorFromAnsiIndex(glyph.bg);
        }
        return this._config.colors.background;
    };
    DynamicCharAtlas.prototype._getForegroundColor = function (glyph) {
        if (glyph.fg === Types_1.INVERTED_DEFAULT_COLOR) {
            return this._config.colors.background;
        }
        else if (glyph.fg < 256) {
            return this._getColorFromAnsiIndex(glyph.fg);
        }
        return this._config.colors.foreground;
    };
    DynamicCharAtlas.prototype._drawToCache = function (glyph, index) {
        this._drawToCacheCount++;
        this._tmpCtx.save();
        var backgroundColor = this._getBackgroundColor(glyph);
        this._tmpCtx.globalCompositeOperation = 'copy';
        this._tmpCtx.fillStyle = backgroundColor.css;
        this._tmpCtx.fillRect(0, 0, this._config.scaledCharWidth, this._config.scaledCharHeight);
        this._tmpCtx.globalCompositeOperation = 'source-over';
        var fontWeight = glyph.bold ? this._config.fontWeightBold : this._config.fontWeight;
        var fontStyle = glyph.italic ? 'italic' : '';
        this._tmpCtx.font =
            fontStyle + " " + fontWeight + " " + this._config.fontSize * this._config.devicePixelRatio + "px " + this._config.fontFamily;
        this._tmpCtx.textBaseline = 'top';
        this._tmpCtx.fillStyle = this._getForegroundColor(glyph).css;
        if (glyph.dim) {
            this._tmpCtx.globalAlpha = Types_1.DIM_OPACITY;
        }
        this._tmpCtx.fillText(glyph.chars, 0, 0);
        this._tmpCtx.restore();
        var imageData = this._tmpCtx.getImageData(0, 0, this._config.scaledCharWidth, this._config.scaledCharHeight);
        var isEmpty = false;
        if (!this._config.allowTransparency) {
            isEmpty = CharAtlasGenerator_1.clearColor(imageData, backgroundColor);
        }
        var x = this._toCoordinateX(index);
        var y = this._toCoordinateY(index);
        this._cacheCtx.putImageData(imageData, x, y);
        var cacheValue = {
            index: index,
            isEmpty: isEmpty,
            inBitmap: false
        };
        this._addGlyphToBitmap(cacheValue);
        return cacheValue;
    };
    DynamicCharAtlas.prototype._addGlyphToBitmap = function (cacheValue) {
        var _this = this;
        if (!('createImageBitmap' in window) || Browser_1.isFirefox || Browser_1.isSafari) {
            return;
        }
        this._glyphsWaitingOnBitmap.push(cacheValue);
        if (this._bitmapCommitTimeout !== null) {
            return;
        }
        this._bitmapCommitTimeout = window.setTimeout(function () { return _this._generateBitmap(); }, GLYPH_BITMAP_COMMIT_DELAY);
    };
    DynamicCharAtlas.prototype._generateBitmap = function () {
        var _this = this;
        var glyphsMovingToBitmap = this._glyphsWaitingOnBitmap;
        this._glyphsWaitingOnBitmap = [];
        window.createImageBitmap(this._cacheCanvas).then(function (bitmap) {
            _this._bitmap = bitmap;
            for (var i = 0; i < glyphsMovingToBitmap.length; i++) {
                var value = glyphsMovingToBitmap[i];
                value.inBitmap = true;
            }
        });
        this._bitmapCommitTimeout = null;
    };
    return DynamicCharAtlas;
}(BaseCharAtlas_1.default));
exports.default = DynamicCharAtlas;
//# sourceMappingURL=DynamicCharAtlas.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/renderer/atlas/LRUMap.js":
/*!*********************************************************!*\
  !*** ./node_modules/xterm/lib/renderer/atlas/LRUMap.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var LRUMap = (function () {
    function LRUMap(capacity) {
        this.capacity = capacity;
        this._map = {};
        this._head = null;
        this._tail = null;
        this._nodePool = [];
        this.size = 0;
    }
    LRUMap.prototype._unlinkNode = function (node) {
        var prev = node.prev;
        var next = node.next;
        if (node === this._head) {
            this._head = next;
        }
        if (node === this._tail) {
            this._tail = prev;
        }
        if (prev !== null) {
            prev.next = next;
        }
        if (next !== null) {
            next.prev = prev;
        }
    };
    LRUMap.prototype._appendNode = function (node) {
        var tail = this._tail;
        if (tail !== null) {
            tail.next = node;
        }
        node.prev = tail;
        node.next = null;
        this._tail = node;
        if (this._head === null) {
            this._head = node;
        }
    };
    LRUMap.prototype.prealloc = function (count) {
        var nodePool = this._nodePool;
        for (var i = 0; i < count; i++) {
            nodePool.push({
                prev: null,
                next: null,
                key: null,
                value: null
            });
        }
    };
    LRUMap.prototype.get = function (key) {
        var node = this._map[key];
        if (node !== undefined) {
            this._unlinkNode(node);
            this._appendNode(node);
            return node.value;
        }
        return null;
    };
    LRUMap.prototype.peekValue = function (key) {
        var node = this._map[key];
        if (node !== undefined) {
            return node.value;
        }
        return null;
    };
    LRUMap.prototype.peek = function () {
        var head = this._head;
        return head === null ? null : head.value;
    };
    LRUMap.prototype.set = function (key, value) {
        var node = this._map[key];
        if (node !== undefined) {
            node = this._map[key];
            this._unlinkNode(node);
            node.value = value;
        }
        else if (this.size >= this.capacity) {
            node = this._head;
            this._unlinkNode(node);
            delete this._map[node.key];
            node.key = key;
            node.value = value;
            this._map[key] = node;
        }
        else {
            var nodePool = this._nodePool;
            if (nodePool.length > 0) {
                node = nodePool.pop();
                node.key = key;
                node.value = value;
            }
            else {
                node = {
                    prev: null,
                    next: null,
                    key: key,
                    value: value
                };
            }
            this._map[key] = node;
            this.size++;
        }
        this._appendNode(node);
    };
    return LRUMap;
}());
exports.default = LRUMap;
//# sourceMappingURL=LRUMap.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/renderer/atlas/NoneCharAtlas.js":
/*!****************************************************************!*\
  !*** ./node_modules/xterm/lib/renderer/atlas/NoneCharAtlas.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BaseCharAtlas_1 = __webpack_require__(/*! ./BaseCharAtlas */ "./node_modules/xterm/lib/renderer/atlas/BaseCharAtlas.js");
var NoneCharAtlas = (function (_super) {
    __extends(NoneCharAtlas, _super);
    function NoneCharAtlas(document, config) {
        return _super.call(this) || this;
    }
    NoneCharAtlas.prototype.draw = function (ctx, glyph, x, y) {
        return false;
    };
    return NoneCharAtlas;
}(BaseCharAtlas_1.default));
exports.default = NoneCharAtlas;
//# sourceMappingURL=NoneCharAtlas.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/renderer/atlas/StaticCharAtlas.js":
/*!******************************************************************!*\
  !*** ./node_modules/xterm/lib/renderer/atlas/StaticCharAtlas.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Types_1 = __webpack_require__(/*! ./Types */ "./node_modules/xterm/lib/renderer/atlas/Types.js");
var Types_2 = __webpack_require__(/*! ../../shared/atlas/Types */ "./node_modules/xterm/lib/shared/atlas/Types.js");
var CharAtlasGenerator_1 = __webpack_require__(/*! ../../shared/atlas/CharAtlasGenerator */ "./node_modules/xterm/lib/shared/atlas/CharAtlasGenerator.js");
var BaseCharAtlas_1 = __webpack_require__(/*! ./BaseCharAtlas */ "./node_modules/xterm/lib/renderer/atlas/BaseCharAtlas.js");
var StaticCharAtlas = (function (_super) {
    __extends(StaticCharAtlas, _super);
    function StaticCharAtlas(_document, _config) {
        var _this = _super.call(this) || this;
        _this._document = _document;
        _this._config = _config;
        _this._canvasFactory = function (width, height) {
            var canvas = _this._document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            return canvas;
        };
        return _this;
    }
    StaticCharAtlas.prototype._doWarmUp = function () {
        var _this = this;
        var result = CharAtlasGenerator_1.generateStaticCharAtlasTexture(window, this._canvasFactory, this._config);
        if (result instanceof HTMLCanvasElement) {
            this._texture = result;
        }
        else {
            result.then(function (texture) {
                _this._texture = texture;
            });
        }
    };
    StaticCharAtlas.prototype._isCached = function (glyph, colorIndex) {
        var isAscii = glyph.code < 256;
        var isBasicColor = glyph.fg < 16;
        var isDefaultColor = glyph.fg >= 256;
        var isDefaultBackground = glyph.bg >= 256;
        return isAscii && (isBasicColor || isDefaultColor) && isDefaultBackground && !glyph.italic;
    };
    StaticCharAtlas.prototype.draw = function (ctx, glyph, x, y) {
        if (this._texture === null || this._texture === undefined) {
            return false;
        }
        var colorIndex = 0;
        if (glyph.fg < 256) {
            colorIndex = 2 + glyph.fg + (glyph.bold ? 16 : 0);
        }
        else {
            if (glyph.bold) {
                colorIndex = 1;
            }
        }
        if (!this._isCached(glyph, colorIndex)) {
            return false;
        }
        ctx.save();
        var charAtlasCellWidth = this._config.scaledCharWidth + Types_2.CHAR_ATLAS_CELL_SPACING;
        var charAtlasCellHeight = this._config.scaledCharHeight + Types_2.CHAR_ATLAS_CELL_SPACING;
        if (glyph.dim) {
            ctx.globalAlpha = Types_1.DIM_OPACITY;
        }
        ctx.drawImage(this._texture, glyph.code * charAtlasCellWidth, colorIndex * charAtlasCellHeight, charAtlasCellWidth, this._config.scaledCharHeight, x, y, charAtlasCellWidth, this._config.scaledCharHeight);
        ctx.restore();
        return true;
    };
    return StaticCharAtlas;
}(BaseCharAtlas_1.default));
exports.default = StaticCharAtlas;
//# sourceMappingURL=StaticCharAtlas.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/renderer/atlas/Types.js":
/*!********************************************************!*\
  !*** ./node_modules/xterm/lib/renderer/atlas/Types.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.INVERTED_DEFAULT_COLOR = -1;
exports.DIM_OPACITY = 0.5;
//# sourceMappingURL=Types.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/renderer/dom/DomRenderer.js":
/*!************************************************************!*\
  !*** ./node_modules/xterm/lib/renderer/dom/DomRenderer.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var EventEmitter_1 = __webpack_require__(/*! ../../common/EventEmitter */ "./node_modules/xterm/lib/common/EventEmitter.js");
var ColorManager_1 = __webpack_require__(/*! ../ColorManager */ "./node_modules/xterm/lib/renderer/ColorManager.js");
var RenderDebouncer_1 = __webpack_require__(/*! ../../ui/RenderDebouncer */ "./node_modules/xterm/lib/ui/RenderDebouncer.js");
var DomRendererRowFactory_1 = __webpack_require__(/*! ./DomRendererRowFactory */ "./node_modules/xterm/lib/renderer/dom/DomRendererRowFactory.js");
var TERMINAL_CLASS_PREFIX = 'xterm-dom-renderer-owner-';
var ROW_CONTAINER_CLASS = 'xterm-rows';
var FG_CLASS_PREFIX = 'xterm-fg-';
var BG_CLASS_PREFIX = 'xterm-bg-';
var FOCUS_CLASS = 'xterm-focus';
var SELECTION_CLASS = 'xterm-selection';
var nextTerminalId = 1;
var DomRenderer = (function (_super) {
    __extends(DomRenderer, _super);
    function DomRenderer(_terminal, theme) {
        var _this = _super.call(this) || this;
        _this._terminal = _terminal;
        _this._terminalClass = nextTerminalId++;
        _this._rowElements = [];
        var allowTransparency = _this._terminal.options.allowTransparency;
        _this.colorManager = new ColorManager_1.ColorManager(document, allowTransparency);
        _this.setTheme(theme);
        _this._rowContainer = document.createElement('div');
        _this._rowContainer.classList.add(ROW_CONTAINER_CLASS);
        _this._rowContainer.style.lineHeight = 'normal';
        _this._rowContainer.setAttribute('aria-hidden', 'true');
        _this._refreshRowElements(_this._terminal.cols, _this._terminal.rows);
        _this._selectionContainer = document.createElement('div');
        _this._selectionContainer.classList.add(SELECTION_CLASS);
        _this._selectionContainer.setAttribute('aria-hidden', 'true');
        _this.dimensions = {
            scaledCharWidth: null,
            scaledCharHeight: null,
            scaledCellWidth: null,
            scaledCellHeight: null,
            scaledCharLeft: null,
            scaledCharTop: null,
            scaledCanvasWidth: null,
            scaledCanvasHeight: null,
            canvasWidth: null,
            canvasHeight: null,
            actualCellWidth: null,
            actualCellHeight: null
        };
        _this._updateDimensions();
        _this._renderDebouncer = new RenderDebouncer_1.RenderDebouncer(_this._terminal, _this._renderRows.bind(_this));
        _this._rowFactory = new DomRendererRowFactory_1.DomRendererRowFactory(document);
        _this._terminal.element.classList.add(TERMINAL_CLASS_PREFIX + _this._terminalClass);
        _this._terminal.screenElement.appendChild(_this._rowContainer);
        _this._terminal.screenElement.appendChild(_this._selectionContainer);
        _this._terminal.linkifier.on("linkhover", function (e) { return _this._onLinkHover(e); });
        _this._terminal.linkifier.on("linkleave", function (e) { return _this._onLinkLeave(e); });
        return _this;
    }
    DomRenderer.prototype.dispose = function () {
        this._terminal.element.classList.remove(TERMINAL_CLASS_PREFIX + this._terminalClass);
        this._terminal.screenElement.removeChild(this._rowContainer);
        this._terminal.screenElement.removeChild(this._selectionContainer);
        this._terminal.screenElement.removeChild(this._themeStyleElement);
        this._terminal.screenElement.removeChild(this._dimensionsStyleElement);
        _super.prototype.dispose.call(this);
    };
    DomRenderer.prototype._updateDimensions = function () {
        var _this = this;
        this.dimensions.scaledCharWidth = this._terminal.charMeasure.width * window.devicePixelRatio;
        this.dimensions.scaledCharHeight = this._terminal.charMeasure.height * window.devicePixelRatio;
        this.dimensions.scaledCellWidth = this.dimensions.scaledCharWidth;
        this.dimensions.scaledCellHeight = this.dimensions.scaledCharHeight;
        this.dimensions.scaledCharLeft = 0;
        this.dimensions.scaledCharTop = 0;
        this.dimensions.scaledCanvasWidth = this.dimensions.scaledCellWidth * this._terminal.cols;
        this.dimensions.scaledCanvasHeight = this.dimensions.scaledCellHeight * this._terminal.rows;
        this.dimensions.canvasWidth = this._terminal.charMeasure.width * this._terminal.cols;
        this.dimensions.canvasHeight = this._terminal.charMeasure.height * this._terminal.rows;
        this.dimensions.actualCellWidth = this._terminal.charMeasure.width;
        this.dimensions.actualCellHeight = this._terminal.charMeasure.height;
        this._rowElements.forEach(function (element) {
            element.style.width = _this.dimensions.canvasWidth + "px";
            element.style.height = _this._terminal.charMeasure.height + "px";
        });
        if (!this._dimensionsStyleElement) {
            this._dimensionsStyleElement = document.createElement('style');
            this._terminal.screenElement.appendChild(this._dimensionsStyleElement);
        }
        var styles = this._terminalSelector + " ." + ROW_CONTAINER_CLASS + " span {" +
            " display: inline-block;" +
            " height: 100%;" +
            " vertical-align: top;" +
            (" width: " + this._terminal.charMeasure.width + "px") +
            "}";
        this._dimensionsStyleElement.innerHTML = styles;
        this._selectionContainer.style.height = this._terminal._viewportElement.style.height;
        this._rowContainer.style.width = this.dimensions.canvasWidth + "px";
        this._rowContainer.style.height = this.dimensions.canvasHeight + "px";
    };
    DomRenderer.prototype.setTheme = function (theme) {
        var _this = this;
        if (theme) {
            this.colorManager.setTheme(theme);
        }
        if (!this._themeStyleElement) {
            this._themeStyleElement = document.createElement('style');
            this._terminal.screenElement.appendChild(this._themeStyleElement);
        }
        var styles = this._terminalSelector + " ." + ROW_CONTAINER_CLASS + " {" +
            (" color: " + this.colorManager.colors.foreground.css + ";") +
            (" background-color: " + this.colorManager.colors.background.css + ";") +
            (" font-family: " + this._terminal.getOption('fontFamily') + ";") +
            (" font-size: " + this._terminal.getOption('fontSize') + "px;") +
            "}";
        styles +=
            this._terminalSelector + " span:not(." + DomRendererRowFactory_1.BOLD_CLASS + ") {" +
                (" font-weight: " + this._terminal.options.fontWeight + ";") +
                "}" +
                (this._terminalSelector + " span." + DomRendererRowFactory_1.BOLD_CLASS + " {") +
                (" font-weight: " + this._terminal.options.fontWeightBold + ";") +
                "}" +
                (this._terminalSelector + " span." + DomRendererRowFactory_1.ITALIC_CLASS + " {") +
                " font-style: italic;" +
                "}";
        styles +=
            this._terminalSelector + " ." + ROW_CONTAINER_CLASS + ":not(." + FOCUS_CLASS + ") ." + DomRendererRowFactory_1.CURSOR_CLASS + " {" +
                (" outline: 1px solid " + this.colorManager.colors.cursor.css + ";") +
                " outline-offset: -1px;" +
                "}" +
                (this._terminalSelector + " ." + ROW_CONTAINER_CLASS + "." + FOCUS_CLASS + " ." + DomRendererRowFactory_1.CURSOR_CLASS + "." + DomRendererRowFactory_1.CURSOR_STYLE_BLOCK_CLASS + " {") +
                (" background-color: " + this.colorManager.colors.cursor.css + ";") +
                (" color: " + this.colorManager.colors.cursorAccent.css + ";") +
                "}" +
                (this._terminalSelector + " ." + ROW_CONTAINER_CLASS + "." + FOCUS_CLASS + " ." + DomRendererRowFactory_1.CURSOR_CLASS + "." + DomRendererRowFactory_1.CURSOR_STYLE_BAR_CLASS + " {") +
                (" box-shadow: 1px 0 0 " + this.colorManager.colors.cursor.css + " inset;") +
                "}" +
                (this._terminalSelector + " ." + ROW_CONTAINER_CLASS + "." + FOCUS_CLASS + " ." + DomRendererRowFactory_1.CURSOR_CLASS + "." + DomRendererRowFactory_1.CURSOR_STYLE_UNDERLINE_CLASS + " {") +
                (" box-shadow: 0 -1px 0 " + this.colorManager.colors.cursor.css + " inset;") +
                "}";
        styles +=
            this._terminalSelector + " ." + SELECTION_CLASS + " {" +
                " position: absolute;" +
                " top: 0;" +
                " left: 0;" +
                " z-index: 1;" +
                " pointer-events: none;" +
                "}" +
                (this._terminalSelector + " ." + SELECTION_CLASS + " div {") +
                " position: absolute;" +
                (" background-color: " + this.colorManager.colors.selection.css + ";") +
                "}";
        this.colorManager.colors.ansi.forEach(function (c, i) {
            styles +=
                _this._terminalSelector + " ." + FG_CLASS_PREFIX + i + " { color: " + c.css + "; }" +
                    (_this._terminalSelector + " ." + BG_CLASS_PREFIX + i + " { background-color: " + c.css + "; }");
        });
        this._themeStyleElement.innerHTML = styles;
        return this.colorManager.colors;
    };
    DomRenderer.prototype.onWindowResize = function (devicePixelRatio) {
        this._updateDimensions();
    };
    DomRenderer.prototype._refreshRowElements = function (cols, rows) {
        for (var i = this._rowElements.length; i <= rows; i++) {
            var row = document.createElement('div');
            this._rowContainer.appendChild(row);
            this._rowElements.push(row);
        }
        while (this._rowElements.length > rows) {
            this._rowContainer.removeChild(this._rowElements.pop());
        }
    };
    DomRenderer.prototype.onResize = function (cols, rows) {
        this._refreshRowElements(cols, rows);
        this._updateDimensions();
    };
    DomRenderer.prototype.onCharSizeChanged = function () {
        this._updateDimensions();
    };
    DomRenderer.prototype.onBlur = function () {
        this._rowContainer.classList.remove(FOCUS_CLASS);
    };
    DomRenderer.prototype.onFocus = function () {
        this._rowContainer.classList.add(FOCUS_CLASS);
    };
    DomRenderer.prototype.onSelectionChanged = function (start, end, columnSelectMode) {
        while (this._selectionContainer.children.length) {
            this._selectionContainer.removeChild(this._selectionContainer.children[0]);
        }
        if (!start || !end) {
            return;
        }
        var viewportStartRow = start[1] - this._terminal.buffer.ydisp;
        var viewportEndRow = end[1] - this._terminal.buffer.ydisp;
        var viewportCappedStartRow = Math.max(viewportStartRow, 0);
        var viewportCappedEndRow = Math.min(viewportEndRow, this._terminal.rows - 1);
        if (viewportCappedStartRow >= this._terminal.rows || viewportCappedEndRow < 0) {
            return;
        }
        var documentFragment = document.createDocumentFragment();
        if (columnSelectMode) {
            documentFragment.appendChild(this._createSelectionElement(viewportCappedStartRow, start[0], end[0], viewportCappedEndRow - viewportCappedStartRow + 1));
        }
        else {
            var startCol = viewportStartRow === viewportCappedStartRow ? start[0] : 0;
            var endCol = viewportCappedStartRow === viewportCappedEndRow ? end[0] : this._terminal.cols;
            documentFragment.appendChild(this._createSelectionElement(viewportCappedStartRow, startCol, endCol));
            var middleRowsCount = viewportCappedEndRow - viewportCappedStartRow - 1;
            documentFragment.appendChild(this._createSelectionElement(viewportCappedStartRow + 1, 0, this._terminal.cols, middleRowsCount));
            if (viewportCappedStartRow !== viewportCappedEndRow) {
                var endCol_1 = viewportEndRow === viewportCappedEndRow ? end[0] : this._terminal.cols;
                documentFragment.appendChild(this._createSelectionElement(viewportCappedEndRow, 0, endCol_1));
            }
        }
        this._selectionContainer.appendChild(documentFragment);
    };
    DomRenderer.prototype._createSelectionElement = function (row, colStart, colEnd, rowCount) {
        if (rowCount === void 0) { rowCount = 1; }
        var element = document.createElement('div');
        element.style.height = rowCount * this._terminal.charMeasure.height + "px";
        element.style.top = row * this._terminal.charMeasure.height + "px";
        element.style.left = colStart * this._terminal.charMeasure.width + "px";
        element.style.width = this._terminal.charMeasure.width * (colEnd - colStart) + "px";
        return element;
    };
    DomRenderer.prototype.onCursorMove = function () {
    };
    DomRenderer.prototype.onOptionsChanged = function () {
        this._updateDimensions();
        this.setTheme(undefined);
        this._terminal.refresh(0, this._terminal.rows - 1);
    };
    DomRenderer.prototype.clear = function () {
        this._rowElements.forEach(function (e) { return e.innerHTML = ''; });
    };
    DomRenderer.prototype.refreshRows = function (start, end) {
        this._renderDebouncer.refresh(start, end);
    };
    DomRenderer.prototype._renderRows = function (start, end) {
        var terminal = this._terminal;
        var cursorAbsoluteY = terminal.buffer.ybase + terminal.buffer.y;
        var cursorX = this._terminal.buffer.x;
        for (var y = start; y <= end; y++) {
            var rowElement = this._rowElements[y];
            rowElement.innerHTML = '';
            var row = y + terminal.buffer.ydisp;
            var lineData = terminal.buffer.lines.get(row);
            var cursorStyle = terminal.options.cursorStyle;
            rowElement.appendChild(this._rowFactory.createRow(lineData, row === cursorAbsoluteY, cursorStyle, cursorX, terminal.charMeasure.width, terminal.cols));
        }
        this._terminal.emit('refresh', { start: start, end: end });
    };
    Object.defineProperty(DomRenderer.prototype, "_terminalSelector", {
        get: function () {
            return "." + TERMINAL_CLASS_PREFIX + this._terminalClass;
        },
        enumerable: true,
        configurable: true
    });
    DomRenderer.prototype.registerCharacterJoiner = function (handler) { return -1; };
    DomRenderer.prototype.deregisterCharacterJoiner = function (joinerId) { return false; };
    DomRenderer.prototype._onLinkHover = function (e) {
        this._setCellUnderline(e.x1, e.x2, e.y1, e.y2, e.cols, true);
    };
    DomRenderer.prototype._onLinkLeave = function (e) {
        this._setCellUnderline(e.x1, e.x2, e.y1, e.y2, e.cols, false);
    };
    DomRenderer.prototype._setCellUnderline = function (x, x2, y, y2, cols, enabled) {
        while (x !== x2 || y !== y2) {
            var span = this._rowElements[y].children[x];
            span.style.textDecoration = enabled ? 'underline' : 'none';
            x = (x + 1) % cols;
            if (x === 0) {
                y++;
            }
        }
    };
    return DomRenderer;
}(EventEmitter_1.EventEmitter));
exports.DomRenderer = DomRenderer;
//# sourceMappingURL=DomRenderer.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/renderer/dom/DomRendererRowFactory.js":
/*!**********************************************************************!*\
  !*** ./node_modules/xterm/lib/renderer/dom/DomRendererRowFactory.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Buffer_1 = __webpack_require__(/*! ../../Buffer */ "./node_modules/xterm/lib/Buffer.js");
exports.BOLD_CLASS = 'xterm-bold';
exports.ITALIC_CLASS = 'xterm-italic';
exports.CURSOR_CLASS = 'xterm-cursor';
exports.CURSOR_STYLE_BLOCK_CLASS = 'xterm-cursor-block';
exports.CURSOR_STYLE_BAR_CLASS = 'xterm-cursor-bar';
exports.CURSOR_STYLE_UNDERLINE_CLASS = 'xterm-cursor-underline';
var DomRendererRowFactory = (function () {
    function DomRendererRowFactory(_document) {
        this._document = _document;
    }
    DomRendererRowFactory.prototype.createRow = function (lineData, isCursorRow, cursorStyle, cursorX, cellWidth, cols) {
        var fragment = this._document.createDocumentFragment();
        var colCount = 0;
        for (var x = 0; x < lineData.length; x++) {
            if (colCount >= cols) {
                continue;
            }
            var charData = lineData.get(x);
            var char = charData[Buffer_1.CHAR_DATA_CHAR_INDEX];
            var attr = charData[Buffer_1.CHAR_DATA_ATTR_INDEX];
            var width = charData[Buffer_1.CHAR_DATA_WIDTH_INDEX];
            if (width === 0) {
                continue;
            }
            var charElement = this._document.createElement('span');
            if (width > 1) {
                charElement.style.width = cellWidth * width + "px";
            }
            var flags = attr >> 18;
            var bg = attr & 0x1ff;
            var fg = (attr >> 9) & 0x1ff;
            if (isCursorRow && x === cursorX) {
                charElement.classList.add(exports.CURSOR_CLASS);
                switch (cursorStyle) {
                    case 'bar':
                        charElement.classList.add(exports.CURSOR_STYLE_BAR_CLASS);
                        break;
                    case 'underline':
                        charElement.classList.add(exports.CURSOR_STYLE_UNDERLINE_CLASS);
                        break;
                    default:
                        charElement.classList.add(exports.CURSOR_STYLE_BLOCK_CLASS);
                        break;
                }
            }
            if (flags & 8) {
                var temp = bg;
                bg = fg;
                fg = temp;
                if (fg === 256) {
                    fg = 0;
                }
                if (bg === 257) {
                    bg = 15;
                }
            }
            if (flags & 1) {
                if (fg < 8) {
                    fg += 8;
                }
                charElement.classList.add(exports.BOLD_CLASS);
            }
            if (flags & 64) {
                charElement.classList.add(exports.ITALIC_CLASS);
            }
            charElement.textContent = char;
            if (fg !== 257) {
                charElement.classList.add("xterm-fg-" + fg);
            }
            if (bg !== 256) {
                charElement.classList.add("xterm-bg-" + bg);
            }
            fragment.appendChild(charElement);
            colCount += width;
        }
        return fragment;
    };
    return DomRendererRowFactory;
}());
exports.DomRendererRowFactory = DomRendererRowFactory;
//# sourceMappingURL=DomRendererRowFactory.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/shared/atlas/CharAtlasGenerator.js":
/*!*******************************************************************!*\
  !*** ./node_modules/xterm/lib/shared/atlas/CharAtlasGenerator.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Types_1 = __webpack_require__(/*! ./Types */ "./node_modules/xterm/lib/shared/atlas/Types.js");
var Browser_1 = __webpack_require__(/*! ../utils/Browser */ "./node_modules/xterm/lib/shared/utils/Browser.js");
function generateStaticCharAtlasTexture(context, canvasFactory, config) {
    var cellWidth = config.scaledCharWidth + Types_1.CHAR_ATLAS_CELL_SPACING;
    var cellHeight = config.scaledCharHeight + Types_1.CHAR_ATLAS_CELL_SPACING;
    var canvas = canvasFactory(255 * cellWidth, (2 + 16 + 16) * cellHeight);
    var ctx = canvas.getContext('2d', { alpha: config.allowTransparency });
    ctx.fillStyle = config.colors.background.css;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.fillStyle = config.colors.foreground.css;
    ctx.font = getFont(config.fontWeight, config);
    ctx.textBaseline = 'top';
    for (var i = 0; i < 256; i++) {
        ctx.save();
        ctx.beginPath();
        ctx.rect(i * cellWidth, 0, cellWidth, cellHeight);
        ctx.clip();
        ctx.fillText(String.fromCharCode(i), i * cellWidth, 0);
        ctx.restore();
    }
    ctx.save();
    ctx.font = getFont(config.fontWeightBold, config);
    for (var i = 0; i < 256; i++) {
        ctx.save();
        ctx.beginPath();
        ctx.rect(i * cellWidth, cellHeight, cellWidth, cellHeight);
        ctx.clip();
        ctx.fillText(String.fromCharCode(i), i * cellWidth, cellHeight);
        ctx.restore();
    }
    ctx.restore();
    ctx.font = getFont(config.fontWeight, config);
    for (var colorIndex = 0; colorIndex < 16; colorIndex++) {
        var y = (colorIndex + 2) * cellHeight;
        for (var i = 0; i < 256; i++) {
            ctx.save();
            ctx.beginPath();
            ctx.rect(i * cellWidth, y, cellWidth, cellHeight);
            ctx.clip();
            ctx.fillStyle = config.colors.ansi[colorIndex].css;
            ctx.fillText(String.fromCharCode(i), i * cellWidth, y);
            ctx.restore();
        }
    }
    ctx.font = getFont(config.fontWeightBold, config);
    for (var colorIndex = 0; colorIndex < 16; colorIndex++) {
        var y = (colorIndex + 2 + 16) * cellHeight;
        for (var i = 0; i < 256; i++) {
            ctx.save();
            ctx.beginPath();
            ctx.rect(i * cellWidth, y, cellWidth, cellHeight);
            ctx.clip();
            ctx.fillStyle = config.colors.ansi[colorIndex].css;
            ctx.fillText(String.fromCharCode(i), i * cellWidth, y);
            ctx.restore();
        }
    }
    ctx.restore();
    if (!('createImageBitmap' in context) || Browser_1.isFirefox || Browser_1.isSafari) {
        if (canvas instanceof HTMLCanvasElement) {
            return canvas;
        }
        return new Promise(function (r) { return r(canvas.transferToImageBitmap()); });
    }
    var charAtlasImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    clearColor(charAtlasImageData, config.colors.background);
    return context.createImageBitmap(charAtlasImageData);
}
exports.generateStaticCharAtlasTexture = generateStaticCharAtlasTexture;
function clearColor(imageData, color) {
    var isEmpty = true;
    var r = color.rgba >>> 24;
    var g = color.rgba >>> 16 & 0xFF;
    var b = color.rgba >>> 8 & 0xFF;
    for (var offset = 0; offset < imageData.data.length; offset += 4) {
        if (imageData.data[offset] === r &&
            imageData.data[offset + 1] === g &&
            imageData.data[offset + 2] === b) {
            imageData.data[offset + 3] = 0;
        }
        else {
            isEmpty = false;
        }
    }
    return isEmpty;
}
exports.clearColor = clearColor;
function getFont(fontWeight, config) {
    return fontWeight + " " + config.fontSize * config.devicePixelRatio + "px " + config.fontFamily;
}
//# sourceMappingURL=CharAtlasGenerator.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/shared/atlas/Types.js":
/*!******************************************************!*\
  !*** ./node_modules/xterm/lib/shared/atlas/Types.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CHAR_ATLAS_CELL_SPACING = 1;
//# sourceMappingURL=Types.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/shared/utils/Browser.js":
/*!********************************************************!*\
  !*** ./node_modules/xterm/lib/shared/utils/Browser.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var isNode = (typeof navigator === 'undefined') ? true : false;
var userAgent = (isNode) ? 'node' : navigator.userAgent;
var platform = (isNode) ? 'node' : navigator.platform;
exports.isFirefox = !!~userAgent.indexOf('Firefox');
exports.isSafari = /^((?!chrome|android).)*safari/i.test(userAgent);
exports.isMSIE = !!~userAgent.indexOf('MSIE') || !!~userAgent.indexOf('Trident');
exports.isMac = contains(['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'], platform);
exports.isIpad = platform === 'iPad';
exports.isIphone = platform === 'iPhone';
exports.isMSWindows = contains(['Windows', 'Win16', 'Win32', 'WinCE'], platform);
exports.isLinux = platform.indexOf('Linux') >= 0;
function contains(arr, el) {
    return arr.indexOf(el) >= 0;
}
//# sourceMappingURL=Browser.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/ui/CharMeasure.js":
/*!**************************************************!*\
  !*** ./node_modules/xterm/lib/ui/CharMeasure.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var EventEmitter_1 = __webpack_require__(/*! ../common/EventEmitter */ "./node_modules/xterm/lib/common/EventEmitter.js");
var CharMeasure = (function (_super) {
    __extends(CharMeasure, _super);
    function CharMeasure(document, parentElement) {
        var _this = _super.call(this) || this;
        _this._document = document;
        _this._parentElement = parentElement;
        _this._measureElement = _this._document.createElement('span');
        _this._measureElement.classList.add('xterm-char-measure-element');
        _this._measureElement.textContent = 'W';
        _this._measureElement.setAttribute('aria-hidden', 'true');
        _this._parentElement.appendChild(_this._measureElement);
        return _this;
    }
    Object.defineProperty(CharMeasure.prototype, "width", {
        get: function () {
            return this._width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CharMeasure.prototype, "height", {
        get: function () {
            return this._height;
        },
        enumerable: true,
        configurable: true
    });
    CharMeasure.prototype.measure = function (options) {
        this._measureElement.style.fontFamily = options.fontFamily;
        this._measureElement.style.fontSize = options.fontSize + "px";
        var geometry = this._measureElement.getBoundingClientRect();
        if (geometry.width === 0 || geometry.height === 0) {
            return;
        }
        if (this._width !== geometry.width || this._height !== geometry.height) {
            this._width = geometry.width;
            this._height = Math.ceil(geometry.height);
            this.emit('charsizechanged');
        }
    };
    return CharMeasure;
}(EventEmitter_1.EventEmitter));
exports.CharMeasure = CharMeasure;
//# sourceMappingURL=CharMeasure.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/ui/Lifecycle.js":
/*!************************************************!*\
  !*** ./node_modules/xterm/lib/ui/Lifecycle.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function addDisposableDomListener(node, type, handler, useCapture) {
    node.addEventListener(type, handler, useCapture);
    return {
        dispose: function () {
            if (!handler) {
                return;
            }
            node.removeEventListener(type, handler, useCapture);
            node = null;
            handler = null;
        }
    };
}
exports.addDisposableDomListener = addDisposableDomListener;
//# sourceMappingURL=Lifecycle.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/ui/MouseZoneManager.js":
/*!*******************************************************!*\
  !*** ./node_modules/xterm/lib/ui/MouseZoneManager.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Lifecycle_1 = __webpack_require__(/*! ../common/Lifecycle */ "./node_modules/xterm/lib/common/Lifecycle.js");
var Lifecycle_2 = __webpack_require__(/*! ./Lifecycle */ "./node_modules/xterm/lib/ui/Lifecycle.js");
var HOVER_DURATION = 500;
var MouseZoneManager = (function (_super) {
    __extends(MouseZoneManager, _super);
    function MouseZoneManager(_terminal) {
        var _this = _super.call(this) || this;
        _this._terminal = _terminal;
        _this._zones = [];
        _this._areZonesActive = false;
        _this._tooltipTimeout = null;
        _this._currentZone = null;
        _this._lastHoverCoords = [null, null];
        _this.register(Lifecycle_2.addDisposableDomListener(_this._terminal.element, 'mousedown', function (e) { return _this._onMouseDown(e); }));
        _this._mouseMoveListener = function (e) { return _this._onMouseMove(e); };
        _this._clickListener = function (e) { return _this._onClick(e); };
        return _this;
    }
    MouseZoneManager.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._deactivate();
    };
    MouseZoneManager.prototype.add = function (zone) {
        this._zones.push(zone);
        if (this._zones.length === 1) {
            this._activate();
        }
    };
    MouseZoneManager.prototype.clearAll = function (start, end) {
        if (this._zones.length === 0) {
            return;
        }
        if (!end) {
            start = 0;
            end = this._terminal.rows - 1;
        }
        for (var i = 0; i < this._zones.length; i++) {
            var zone = this._zones[i];
            if ((zone.y1 > start && zone.y1 <= end + 1) ||
                (zone.y2 > start && zone.y2 <= end + 1) ||
                (zone.y1 < start && zone.y2 > end + 1)) {
                if (this._currentZone && this._currentZone === zone) {
                    this._currentZone.leaveCallback();
                    this._currentZone = null;
                }
                this._zones.splice(i--, 1);
            }
        }
        if (this._zones.length === 0) {
            this._deactivate();
        }
    };
    MouseZoneManager.prototype._activate = function () {
        if (!this._areZonesActive) {
            this._areZonesActive = true;
            this._terminal.element.addEventListener('mousemove', this._mouseMoveListener);
            this._terminal.element.addEventListener('click', this._clickListener);
        }
    };
    MouseZoneManager.prototype._deactivate = function () {
        if (this._areZonesActive) {
            this._areZonesActive = false;
            this._terminal.element.removeEventListener('mousemove', this._mouseMoveListener);
            this._terminal.element.removeEventListener('click', this._clickListener);
        }
    };
    MouseZoneManager.prototype._onMouseMove = function (e) {
        if (this._lastHoverCoords[0] !== e.pageX || this._lastHoverCoords[1] !== e.pageY) {
            this._onHover(e);
            this._lastHoverCoords = [e.pageX, e.pageY];
        }
    };
    MouseZoneManager.prototype._onHover = function (e) {
        var _this = this;
        var zone = this._findZoneEventAt(e);
        if (zone === this._currentZone) {
            return;
        }
        if (this._currentZone) {
            this._currentZone.leaveCallback();
            this._currentZone = null;
            if (this._tooltipTimeout) {
                clearTimeout(this._tooltipTimeout);
            }
        }
        if (!zone) {
            return;
        }
        this._currentZone = zone;
        if (zone.hoverCallback) {
            zone.hoverCallback(e);
        }
        this._tooltipTimeout = setTimeout(function () { return _this._onTooltip(e); }, HOVER_DURATION);
    };
    MouseZoneManager.prototype._onTooltip = function (e) {
        this._tooltipTimeout = null;
        var zone = this._findZoneEventAt(e);
        if (zone && zone.tooltipCallback) {
            zone.tooltipCallback(e);
        }
    };
    MouseZoneManager.prototype._onMouseDown = function (e) {
        if (!this._areZonesActive) {
            return;
        }
        var zone = this._findZoneEventAt(e);
        if (zone) {
            if (zone.willLinkActivate(e)) {
                e.preventDefault();
                e.stopImmediatePropagation();
            }
        }
    };
    MouseZoneManager.prototype._onClick = function (e) {
        var zone = this._findZoneEventAt(e);
        if (zone) {
            zone.clickCallback(e);
            e.preventDefault();
            e.stopImmediatePropagation();
        }
    };
    MouseZoneManager.prototype._findZoneEventAt = function (e) {
        var coords = this._terminal.mouseHelper.getCoords(e, this._terminal.screenElement, this._terminal.charMeasure, this._terminal.options.lineHeight, this._terminal.cols, this._terminal.rows);
        if (!coords) {
            return null;
        }
        var x = coords[0];
        var y = coords[1];
        for (var i = 0; i < this._zones.length; i++) {
            var zone = this._zones[i];
            if (zone.y1 === zone.y2) {
                if (y === zone.y1 && x >= zone.x1 && x < zone.x2) {
                    return zone;
                }
            }
            else {
                if ((y === zone.y1 && x >= zone.x1) ||
                    (y === zone.y2 && x < zone.x2) ||
                    (y > zone.y1 && y < zone.y2)) {
                    return zone;
                }
            }
        }
        return null;
    };
    return MouseZoneManager;
}(Lifecycle_1.Disposable));
exports.MouseZoneManager = MouseZoneManager;
var MouseZone = (function () {
    function MouseZone(x1, y1, x2, y2, clickCallback, hoverCallback, tooltipCallback, leaveCallback, willLinkActivate) {
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
        this.clickCallback = clickCallback;
        this.hoverCallback = hoverCallback;
        this.tooltipCallback = tooltipCallback;
        this.leaveCallback = leaveCallback;
        this.willLinkActivate = willLinkActivate;
    }
    return MouseZone;
}());
exports.MouseZone = MouseZone;
//# sourceMappingURL=MouseZoneManager.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/ui/RenderDebouncer.js":
/*!******************************************************!*\
  !*** ./node_modules/xterm/lib/ui/RenderDebouncer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var RenderDebouncer = (function () {
    function RenderDebouncer(_terminal, _callback) {
        this._terminal = _terminal;
        this._callback = _callback;
        this._animationFrame = null;
    }
    RenderDebouncer.prototype.dispose = function () {
        if (this._animationFrame) {
            window.cancelAnimationFrame(this._animationFrame);
            this._animationFrame = null;
        }
    };
    RenderDebouncer.prototype.refresh = function (rowStart, rowEnd) {
        var _this = this;
        rowStart = rowStart !== null && rowStart !== undefined ? rowStart : 0;
        rowEnd = rowEnd !== null && rowEnd !== undefined ? rowEnd : this._terminal.rows - 1;
        var isRowStartSet = this._rowStart !== undefined && this._rowStart !== null;
        var isRowEndSet = this._rowEnd !== undefined && this._rowEnd !== null;
        this._rowStart = isRowStartSet ? Math.min(this._rowStart, rowStart) : rowStart;
        this._rowEnd = isRowEndSet ? Math.max(this._rowEnd, rowEnd) : rowEnd;
        if (this._animationFrame) {
            return;
        }
        this._animationFrame = window.requestAnimationFrame(function () { return _this._innerRefresh(); });
    };
    RenderDebouncer.prototype._innerRefresh = function () {
        this._rowStart = Math.max(this._rowStart, 0);
        this._rowEnd = Math.min(this._rowEnd, this._terminal.rows - 1);
        this._callback(this._rowStart, this._rowEnd);
        this._rowStart = null;
        this._rowEnd = null;
        this._animationFrame = null;
    };
    return RenderDebouncer;
}());
exports.RenderDebouncer = RenderDebouncer;
//# sourceMappingURL=RenderDebouncer.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/ui/ScreenDprMonitor.js":
/*!*******************************************************!*\
  !*** ./node_modules/xterm/lib/ui/ScreenDprMonitor.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Lifecycle_1 = __webpack_require__(/*! ../common/Lifecycle */ "./node_modules/xterm/lib/common/Lifecycle.js");
var ScreenDprMonitor = (function (_super) {
    __extends(ScreenDprMonitor, _super);
    function ScreenDprMonitor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ScreenDprMonitor.prototype.setListener = function (listener) {
        var _this = this;
        if (this._listener) {
            this.clearListener();
        }
        this._listener = listener;
        this._outerListener = function () {
            _this._listener(window.devicePixelRatio, _this._currentDevicePixelRatio);
            _this._updateDpr();
        };
        this._updateDpr();
    };
    ScreenDprMonitor.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.clearListener();
    };
    ScreenDprMonitor.prototype._updateDpr = function () {
        if (this._resolutionMediaMatchList) {
            this._resolutionMediaMatchList.removeListener(this._outerListener);
        }
        this._currentDevicePixelRatio = window.devicePixelRatio;
        this._resolutionMediaMatchList = window.matchMedia("screen and (resolution: " + window.devicePixelRatio + "dppx)");
        this._resolutionMediaMatchList.addListener(this._outerListener);
    };
    ScreenDprMonitor.prototype.clearListener = function () {
        if (!this._listener) {
            return;
        }
        this._resolutionMediaMatchList.removeListener(this._outerListener);
        this._listener = null;
        this._outerListener = null;
    };
    return ScreenDprMonitor;
}(Lifecycle_1.Disposable));
exports.ScreenDprMonitor = ScreenDprMonitor;
//# sourceMappingURL=ScreenDprMonitor.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/utils/Clone.js":
/*!***********************************************!*\
  !*** ./node_modules/xterm/lib/utils/Clone.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.clone = function (val, depth) {
    if (depth === void 0) { depth = 5; }
    if (typeof val !== 'object') {
        return val;
    }
    if (val === null) {
        return null;
    }
    var clonedObject = Array.isArray(val) ? [] : {};
    for (var key in val) {
        clonedObject[key] = depth <= 1 ? val[key] : exports.clone(val[key], depth - 1);
    }
    return clonedObject;
};
//# sourceMappingURL=Clone.js.map

/***/ }),

/***/ "./node_modules/xterm/lib/utils/MouseHelper.js":
/*!*****************************************************!*\
  !*** ./node_modules/xterm/lib/utils/MouseHelper.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var MouseHelper = (function () {
    function MouseHelper(_renderer) {
        this._renderer = _renderer;
    }
    MouseHelper.getCoordsRelativeToElement = function (event, element) {
        if (event.pageX === null || event.pageX === undefined) {
            return null;
        }
        var originalElement = element;
        var x = event.pageX;
        var y = event.pageY;
        while (element) {
            x -= element.offsetLeft;
            y -= element.offsetTop;
            element = element.offsetParent;
        }
        element = originalElement;
        while (element && element !== element.ownerDocument.body) {
            x += element.scrollLeft;
            y += element.scrollTop;
            element = element.parentElement;
        }
        return [x, y];
    };
    MouseHelper.prototype.getCoords = function (event, element, charMeasure, lineHeight, colCount, rowCount, isSelection) {
        if (!charMeasure.width || !charMeasure.height) {
            return null;
        }
        var coords = MouseHelper.getCoordsRelativeToElement(event, element);
        if (!coords) {
            return null;
        }
        coords[0] = Math.ceil((coords[0] + (isSelection ? this._renderer.dimensions.actualCellWidth / 2 : 0)) / this._renderer.dimensions.actualCellWidth);
        coords[1] = Math.ceil(coords[1] / this._renderer.dimensions.actualCellHeight);
        coords[0] = Math.min(Math.max(coords[0], 1), colCount + (isSelection ? 1 : 0));
        coords[1] = Math.min(Math.max(coords[1], 1), rowCount);
        return coords;
    };
    MouseHelper.prototype.getRawByteCoords = function (event, element, charMeasure, lineHeight, colCount, rowCount) {
        var coords = this.getCoords(event, element, charMeasure, lineHeight, colCount, rowCount);
        var x = coords[0];
        var y = coords[1];
        x += 32;
        y += 32;
        return { x: x, y: y };
    };
    return MouseHelper;
}());
exports.MouseHelper = MouseHelper;
//# sourceMappingURL=MouseHelper.js.map

/***/ }),

/***/ "./node_modules/yeast/index.js":
/*!*************************************!*\
  !*** ./node_modules/yeast/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
  , length = 64
  , map = {}
  , seed = 0
  , i = 0
  , prev;

/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}

/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}

/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode(+new Date());

  if (now !== prev) return seed = 0, prev = now;
  return now +'.'+ encode(seed++);
}

//
// Map each character to its index.
//
for (; i < length; i++) map[alphabet[i]] = i;

//
// Expose the `yeast`, `encode` and `decode` functions.
//
yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;


/***/ }),

/***/ 0:
/*!********************!*\
  !*** ws (ignored) ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50LnRzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hZnRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXJyYXlidWZmZXIuc2xpY2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhY2tvMi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFzZTY0LWFycmF5YnVmZmVyL2xpYi9iYXNlNjQtYXJyYXlidWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmxvYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb21wb25lbnQtYmluZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1pbmhlcml0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvc29ja2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy1qc29ucC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLXhoci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3dlYnNvY2tldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIveG1saHR0cHJlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvZGVidWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbGliL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbGliL2tleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbGliL3V0ZjguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhcy1iaW5hcnkyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXMtYmluYXJ5Mi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzLWNvcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2luZGV4b2YvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYXJzZXFzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYXJzZXVyaS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvbWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL3NvY2tldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvdXJsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2RlYnVnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2JpbmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9pcy1idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvZGVidWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RvLWFycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3h0ZXJtL2xpYi9BY2Nlc3NpYmlsaXR5TWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveHRlcm0vbGliL0J1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveHRlcm0vbGliL0J1ZmZlckxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3h0ZXJtL2xpYi9CdWZmZXJTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3h0ZXJtL2xpYi9DaGFyV2lkdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3h0ZXJtL2xpYi9Db21wb3NpdGlvbkhlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveHRlcm0vbGliL0VzY2FwZVNlcXVlbmNlUGFyc2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy94dGVybS9saWIvSW5wdXRIYW5kbGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy94dGVybS9saWIvTGlua2lmaWVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy94dGVybS9saWIvU2VsZWN0aW9uTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveHRlcm0vbGliL1NlbGVjdGlvbk1vZGVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy94dGVybS9saWIvU291bmRNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy94dGVybS9saWIvU3RyaW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveHRlcm0vbGliL1Rlcm1pbmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy94dGVybS9saWIvVmlld3BvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3h0ZXJtL2xpYi9hZGRvbnMvYXR0YWNoL2F0dGFjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveHRlcm0vbGliL2FkZG9ucy9maXQvZml0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy94dGVybS9saWIvYWRkb25zL2Z1bGxzY3JlZW4vZnVsbHNjcmVlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveHRlcm0vbGliL2FkZG9ucy9zZWFyY2gvU2VhcmNoSGVscGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy94dGVybS9saWIvYWRkb25zL3NlYXJjaC9zZWFyY2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3h0ZXJtL2xpYi9hZGRvbnMvd2ViTGlua3Mvd2ViTGlua3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3h0ZXJtL2xpYi9hZGRvbnMvd2lucHR5Q29tcGF0L3dpbnB0eUNvbXBhdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveHRlcm0vbGliL2NvbW1vbi9DaXJjdWxhckxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3h0ZXJtL2xpYi9jb21tb24vRXZlbnRFbWl0dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy94dGVybS9saWIvY29tbW9uL0xpZmVjeWNsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveHRlcm0vbGliL2NvbW1vbi9kYXRhL0VzY2FwZVNlcXVlbmNlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveHRlcm0vbGliL2NvcmUvZGF0YS9DaGFyc2V0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveHRlcm0vbGliL2NvcmUvaW5wdXQvS2V5Ym9hcmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3h0ZXJtL2xpYi9oYW5kbGVycy9BbHRDbGlja0hhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3h0ZXJtL2xpYi9oYW5kbGVycy9DbGlwYm9hcmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3h0ZXJtL2xpYi9wdWJsaWMvVGVybWluYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3h0ZXJtL2xpYi9yZW5kZXJlci9CYXNlUmVuZGVyTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3h0ZXJtL2xpYi9yZW5kZXJlci9DaGFyYWN0ZXJKb2luZXJSZWdpc3RyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveHRlcm0vbGliL3JlbmRlcmVyL0NvbG9yTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveHRlcm0vbGliL3JlbmRlcmVyL0N1cnNvclJlbmRlckxheWVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy94dGVybS9saWIvcmVuZGVyZXIvR3JpZENhY2hlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy94dGVybS9saWIvcmVuZGVyZXIvTGlua1JlbmRlckxheWVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy94dGVybS9saWIvcmVuZGVyZXIvUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3h0ZXJtL2xpYi9yZW5kZXJlci9TZWxlY3Rpb25SZW5kZXJMYXllci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveHRlcm0vbGliL3JlbmRlcmVyL1RleHRSZW5kZXJMYXllci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveHRlcm0vbGliL3JlbmRlcmVyL2F0bGFzL0Jhc2VDaGFyQXRsYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3h0ZXJtL2xpYi9yZW5kZXJlci9hdGxhcy9DaGFyQXRsYXNDYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveHRlcm0vbGliL3JlbmRlcmVyL2F0bGFzL0NoYXJBdGxhc1V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy94dGVybS9saWIvcmVuZGVyZXIvYXRsYXMvRHluYW1pY0NoYXJBdGxhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveHRlcm0vbGliL3JlbmRlcmVyL2F0bGFzL0xSVU1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveHRlcm0vbGliL3JlbmRlcmVyL2F0bGFzL05vbmVDaGFyQXRsYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3h0ZXJtL2xpYi9yZW5kZXJlci9hdGxhcy9TdGF0aWNDaGFyQXRsYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3h0ZXJtL2xpYi9yZW5kZXJlci9hdGxhcy9UeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveHRlcm0vbGliL3JlbmRlcmVyL2RvbS9Eb21SZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveHRlcm0vbGliL3JlbmRlcmVyL2RvbS9Eb21SZW5kZXJlclJvd0ZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3h0ZXJtL2xpYi9zaGFyZWQvYXRsYXMvQ2hhckF0bGFzR2VuZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy94dGVybS9saWIvc2hhcmVkL2F0bGFzL1R5cGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy94dGVybS9saWIvc2hhcmVkL3V0aWxzL0Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3h0ZXJtL2xpYi91aS9DaGFyTWVhc3VyZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveHRlcm0vbGliL3VpL0xpZmVjeWNsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveHRlcm0vbGliL3VpL01vdXNlWm9uZU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3h0ZXJtL2xpYi91aS9SZW5kZXJEZWJvdW5jZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3h0ZXJtL2xpYi91aS9TY3JlZW5EcHJNb25pdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy94dGVybS9saWIvdXRpbHMvQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3h0ZXJtL2xpYi91dGlscy9Nb3VzZUhlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveWVhc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3dzIChpZ25vcmVkKSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBMEMsZ0NBQWdDO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0VBQXdELGtCQUFrQjtBQUMxRTtBQUNBLHlEQUFpRCxjQUFjO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBeUMsaUNBQWlDO0FBQzFFLHdIQUFnSCxtQkFBbUIsRUFBRTtBQUNySTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNB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QUFDQTs7Ozs7Ozs7Ozs7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7O0FDbEVXOztBQUVaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLFVBQVU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3RKQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQ7QUFDekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7O0FDbkdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVZOztBQUVaLGFBQWEsbUJBQU8sQ0FBQyxvREFBVztBQUNoQyxjQUFjLG1CQUFPLENBQUMsZ0RBQVM7QUFDL0IsY0FBYyxtQkFBTyxDQUFDLGdEQUFTOztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1EQUFtRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxFQUFFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsWUFBWTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNM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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdHVC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Ozs7Ozs7Ozs7OztBQzdSQTs7QUFFQSxjQUFjLG1CQUFPLENBQUMsa0RBQVU7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxZQUFZOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxZQUFZOztBQUVmO0FBQ0E7QUFDQTtBQUNBLEtBQUssWUFBWTtBQUNqQjtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLG1CQUFPLENBQUMsZ0ZBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNs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OztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNqTkE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsbUJBQU8sQ0FBQyx5RUFBUzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7OztBQy9EQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFD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d0U7QUFDeEUsa0ZBQWtGO0FBQ2xGO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7O0FDdENBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7Ozs7Ozs7Ozs7Ozs7QUN0THRDO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLG1CQUFPLENBQUMseURBQU87QUFDekIsYUFBYSxtQkFBTyxDQUFDLGtFQUFrQjtBQUN2QyxjQUFjLG1CQUFPLENBQUMsaUVBQVc7QUFDakMsWUFBWSxtQkFBTyxDQUFDLGdGQUFPOztBQUUzQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG1CQUFPLENBQUMsaUVBQVc7QUFDckMsaUJBQWlCLG1CQUFPLENBQUMsK0RBQVU7Ozs7Ozs7Ozs7Ozs7QUM1Rm5DO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLG1CQUFPLENBQUMsc0VBQWtCO0FBQ3BDLGFBQWEsbUJBQU8sQ0FBQywrREFBVTtBQUMvQixjQUFjLG1CQUFPLENBQUMsb0VBQW1CO0FBQ3pDLGFBQWEsbUJBQU8sQ0FBQyxrRUFBa0I7QUFDdkMsU0FBUyxtQkFBTyxDQUFDLHVEQUFNO0FBQ3ZCLFdBQVcsbUJBQU8sQ0FBQyw4REFBZ0I7QUFDbkMsWUFBWSxtQkFBTyxDQUFDLGdGQUFPO0FBQzNCLGNBQWMsbUJBQU8sQ0FBQyxnREFBUztBQUMvQixjQUFjLG1CQUFPLENBQUMsOENBQVE7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztB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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxPQUFPO0FBQ1o7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLG9CQUFvQjtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQy9aQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCwyQkFBMkIsaURBQWlEO0FBQzVFO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLG1CQUFPLENBQUMsZ0ZBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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TDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxxQzs7Ozs7Ozs7Ozs7O0FDbkZhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUM1RyxrRUFBa0Usd0NBQXdDLEVBQUU7QUFDNUcsa0VBQWtFLHdDQUF3QyxFQUFFO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHNCQUFzQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGlCQUFpQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxJQUFJO0FBQzNFO0FBQ0E7QUFDQSx3RUFBd0UsR0FBRztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLE1BQU07QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLHlCQUF5QixFQUFFO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsNEJBQTRCLEVBQUU7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxnQ0FBZ0M7QUFDakYsaURBQWlELGdDQUFnQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw0Qzs7Ozs7Ozs7Ozs7O0FDempCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxjQUFjO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHNCQUFzQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw0QkFBNEIsRUFBRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0NBQStDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0M7Ozs7Ozs7Ozs7OztBQzdzQ2E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFDQUFxQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUNBQXFDO0FBQ3RDLDJDOzs7Ozs7Ozs7Ozs7QUMxRWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esb0M7Ozs7Ozs7Ozs7OztBQy9KYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVELHdCQUF3QixtQkFBTyxDQUFDLGtHQUFtQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RCxrRUFBa0U7QUFDbEUseUdBQXlHO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQsa0VBQWtFO0FBQ2xFLHlHQUF5RztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVELGtFQUFrRTtBQUNsRSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RCxrRUFBa0U7QUFDbEUsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG1EOzs7Ozs7Ozs7Ozs7QUNyS2E7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw0Q0FBNEM7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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YSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sWUFBWTs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNuRUEsZSIsImZpbGUiOiJjbGllbnQtYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9jbGllbnQudHNcIik7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxOCBUaGUgeHRlcm0uanMgYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBsaWNlbnNlIE1JVFxuICpcbiAqIFRoaXMgZmlsZSBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIGJyb3dzZXJpZnkuXG4gKi9cblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vbm9kZV9tb2R1bGVzL3h0ZXJtL3R5cGluZ3MveHRlcm0uZC50c1wiLz5cblxuaW1wb3J0IHsgVGVybWluYWwgfSBmcm9tICcuL25vZGVfbW9kdWxlcy94dGVybS9saWIvcHVibGljL1Rlcm1pbmFsJztcbmltcG9ydCAqIGFzIGF0dGFjaCBmcm9tICcuL25vZGVfbW9kdWxlcy94dGVybS9saWIvYWRkb25zL2F0dGFjaC9hdHRhY2gnO1xuaW1wb3J0ICogYXMgZml0IGZyb20gJy4vbm9kZV9tb2R1bGVzL3h0ZXJtL2xpYi9hZGRvbnMvZml0L2ZpdCc7XG5pbXBvcnQgKiBhcyBmdWxsc2NyZWVuIGZyb20gJy4vbm9kZV9tb2R1bGVzL3h0ZXJtL2xpYi9hZGRvbnMvZnVsbHNjcmVlbi9mdWxsc2NyZWVuJztcbmltcG9ydCAqIGFzIHNlYXJjaCBmcm9tICcuL25vZGVfbW9kdWxlcy94dGVybS9saWIvYWRkb25zL3NlYXJjaC9zZWFyY2gnO1xuaW1wb3J0ICogYXMgd2ViTGlua3MgZnJvbSAnLi9ub2RlX21vZHVsZXMveHRlcm0vbGliL2FkZG9ucy93ZWJMaW5rcy93ZWJMaW5rcyc7XG5pbXBvcnQgKiBhcyB3aW5wdHlDb21wYXQgZnJvbSAnLi9ub2RlX21vZHVsZXMveHRlcm0vbGliL2FkZG9ucy93aW5wdHlDb21wYXQvd2lucHR5Q29tcGF0JztcbmltcG9ydCAqIGFzIHNvY2tldElvIGZyb20gJ3NvY2tldC5pby1jbGllbnQnO1xuXG4vLyBQdWxsaW5nIGluIHRoZSBtb2R1bGUncyB0eXBlcyByZWxpZXMgb24gdGhlIDxyZWZlcmVuY2U+IGFib3ZlLCBpdCdzIGxvb2tzIGFcbi8vIGxpdHRsZSB3ZWlyZCBoZXJlIGFzIHdlJ3JlIGltcG9ydGluZyBcInRoaXNcIiBtb2R1bGVcbmltcG9ydCB7IFRlcm1pbmFsIGFzIFRlcm1pbmFsVHlwZSB9IGZyb20gJ3h0ZXJtJztcblxuZXhwb3J0IGludGVyZmFjZSBJV2luZG93V2l0aFRlcm1pbmFsIGV4dGVuZHMgV2luZG93IHtcbiAgdGVybTogVGVybWluYWxUeXBlO1xufVxuZGVjbGFyZSBsZXQgd2luZG93OiBJV2luZG93V2l0aFRlcm1pbmFsO1xuXG5UZXJtaW5hbC5hcHBseUFkZG9uKGF0dGFjaCk7XG5UZXJtaW5hbC5hcHBseUFkZG9uKGZpdCk7XG5UZXJtaW5hbC5hcHBseUFkZG9uKGZ1bGxzY3JlZW4pO1xuVGVybWluYWwuYXBwbHlBZGRvbihzZWFyY2gpO1xuVGVybWluYWwuYXBwbHlBZGRvbih3ZWJMaW5rcyk7XG5UZXJtaW5hbC5hcHBseUFkZG9uKHdpbnB0eUNvbXBhdCk7XG5cblxubGV0IHRlcm07XG5sZXQgcHJvdG9jb2w7XG5sZXQgc29ja2V0VVJMO1xubGV0IHNvY2tldDtcbmxldCBwaWQ7XG5cbmNvbnN0IHRlcm1pbmFsQ29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Rlcm1pbmFsLWNvbnRhaW5lcicpO1xuXG5jcmVhdGVUZXJtaW5hbCgpO1xuXG5mdW5jdGlvbiBjcmVhdGVUZXJtaW5hbCgpOiB2b2lkIHtcbiAgLy8gQ2xlYW4gdGVybWluYWxcbiAgd2hpbGUgKHRlcm1pbmFsQ29udGFpbmVyLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHRlcm1pbmFsQ29udGFpbmVyLnJlbW92ZUNoaWxkKHRlcm1pbmFsQ29udGFpbmVyLmNoaWxkcmVuWzBdKTtcbiAgfVxuICB0ZXJtID0gbmV3IFRlcm1pbmFsKHt9KTtcbiAgdGVybS5vbigncmVzaXplJywgKHNpemU6IHsgY29sczogbnVtYmVyLCByb3dzOiBudW1iZXIgfSkgPT4ge1xuICAgIGlmICghcGlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbHMgPSBzaXplLmNvbHM7XG4gICAgY29uc3Qgcm93cyA9IHNpemUucm93cztcbiAgICBjb25zdCB1cmwgPSAnL2NvbnNvbGUvdGVybWluYWxzLycgKyBwaWQgKyAnL3NpemU/Y29scz0nICsgY29scyArICcmcm93cz0nICsgcm93cztcblxuICAgIGZldGNoKHVybCwge21ldGhvZDogJ1BPU1QnfSk7XG4gIH0pO1xuICBzb2NrZXRVUkwgPSBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3RuYW1lICsgKChsb2NhdGlvbi5wb3J0KSA/ICgnOicgKyBsb2NhdGlvbi5wb3J0KSA6ICcnKSArICcvY29uc29sZS90ZXJtaW5hbHMvJztcblxuICB0ZXJtLm9wZW4odGVybWluYWxDb250YWluZXIpO1xuICB0ZXJtLndpbnB0eUNvbXBhdEluaXQoKTtcbiAgdGVybS53ZWJMaW5rc0luaXQoKTtcbiAgdGVybS5maXQoKTtcbiAgdGVybS5mb2N1cygpO1xuXG5cbiAgLy8gZml0IGlzIGNhbGxlZCB3aXRoaW4gYSBzZXRUaW1lb3V0LCBjb2xzIGFuZCByb3dzIG5lZWQgdGhpcy5cbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgaW5pdE9wdGlvbnModGVybSk7XG5cbiAgICAvLyBTZXQgdGVybWluYWwgc2l6ZSBhZ2FpbiB0byBzZXQgdGhlIHNwZWNpZmljIGRpbWVuc2lvbnMgb24gdGhlIGRlbW9cbiAgICB1cGRhdGVUZXJtaW5hbFNpemUoKTtcblxuICAgIGZldGNoKCcvY29uc29sZS90ZXJtaW5hbHM/Y29scz0nICsgdGVybS5jb2xzICsgJyZyb3dzPScgKyB0ZXJtLnJvd3MsIHttZXRob2Q6ICdQT1NUJ30pLnRoZW4oKHJlcykgPT4ge1xuICAgICAgcmVzLnRleHQoKS50aGVuKChwcm9jZXNzSWQpID0+IHtcbiAgICAgICAgcGlkID0gcHJvY2Vzc0lkO1xuICAgICAgICBzb2NrZXRVUkwgKz0gcHJvY2Vzc0lkO1xuICAgICAgICBzb2NrZXQgPSBzb2NrZXRJbyhzb2NrZXRVUkwpO1xuICAgICAgICBydW5SZWFsVGVybWluYWwoKTtcbiAgICAgICAgc29ja2V0Lm9uKFwicmVjb25uZWN0X2Vycm9yXCIgLHJ1bkZha2VUZXJtaW5hbCk7XG4gICAgICAgIHNvY2tldC5vbihcImNvbm5lY3RfZXJyb3JcIiwgcnVuRmFrZVRlcm1pbmFsKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LCAwKTtcbn1cblxuZnVuY3Rpb24gcnVuUmVhbFRlcm1pbmFsKCk6IHZvaWQge1xuICB0ZXJtLmF0dGFjaChzb2NrZXQpO1xuICB0ZXJtLl9pbml0aWFsaXplZCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIHJ1bkZha2VUZXJtaW5hbCgpOiB2b2lkIHtcbiAgaWYgKHRlcm0uX2luaXRpYWxpemVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGVybS5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gIHRlcm0ucHJvbXB0ID0gKCkgPT4ge1xuICAgIHRlcm0ud3JpdGUoJ1xcclxcbiQgJyk7XG4gIH07XG5cbiAgdGVybS53cml0ZWxuKCdXZWxjb21lIHRvIHh0ZXJtLmpzJyk7XG4gIHRlcm0ud3JpdGVsbignVGhpcyBpcyBhIGxvY2FsIHRlcm1pbmFsIGVtdWxhdGlvbiwgd2l0aG91dCBhIHJlYWwgdGVybWluYWwgaW4gdGhlIGJhY2stZW5kLicpO1xuICB0ZXJtLndyaXRlbG4oJ1R5cGUgc29tZSBrZXlzIGFuZCBjb21tYW5kcyB0byBwbGF5IGFyb3VuZC4nKTtcbiAgdGVybS53cml0ZWxuKCcnKTtcbiAgdGVybS5wcm9tcHQoKTtcblxuICB0ZXJtLl9jb3JlLnJlZ2lzdGVyKHRlcm0uYWRkRGlzcG9zYWJsZUxpc3RlbmVyKCdrZXknLCAoa2V5LCBldikgPT4ge1xuICAgIGNvbnN0IHByaW50YWJsZSA9ICFldi5hbHRLZXkgJiYgIWV2LmFsdEdyYXBoS2V5ICYmICFldi5jdHJsS2V5ICYmICFldi5tZXRhS2V5O1xuXG4gICAgaWYgKGV2LmtleUNvZGUgPT09IDEzKSB7XG4gICAgICB0ZXJtLnByb21wdCgpO1xuICAgIH0gZWxzZSBpZiAoZXYua2V5Q29kZSA9PT0gOCkge1xuICAgICAvLyBEbyBub3QgZGVsZXRlIHRoZSBwcm9tcHRcbiAgICAgIGlmICh0ZXJtLnggPiAyKSB7XG4gICAgICAgIHRlcm0ud3JpdGUoJ1xcYiBcXGInKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByaW50YWJsZSkge1xuICAgICAgdGVybS53cml0ZShrZXkpO1xuICAgIH1cbiAgfSkpO1xuXG4gIHRlcm0uX2NvcmUucmVnaXN0ZXIodGVybS5hZGREaXNwb3NhYmxlTGlzdGVuZXIoJ3Bhc3RlJywgKGRhdGEsIGV2KSA9PiB7XG4gICAgdGVybS53cml0ZShkYXRhKTtcbiAgfSkpO1xufVxuXG5mdW5jdGlvbiBpbml0T3B0aW9ucyh0ZXJtOiBUZXJtaW5hbFR5cGUpOiB2b2lkIHtcbiAgY29uc3QgYmxhY2tsaXN0ZWRPcHRpb25zID0gW1xuICAgIC8vIEludGVybmFsIG9ubHkgb3B0aW9uc1xuICAgICdjYW5jZWxFdmVudHMnLFxuICAgICdjb252ZXJ0RW9sJyxcbiAgICAnZGVidWcnLFxuICAgICdoYW5kbGVyJyxcbiAgICAnc2NyZWVuS2V5cycsXG4gICAgJ3Rlcm1OYW1lJyxcbiAgICAndXNlRmxvd0NvbnRyb2wnLFxuICAgIC8vIENvbXBsZXggb3B0aW9uXG4gICAgJ3RoZW1lJ1xuICBdO1xuICBjb25zdCBzdHJpbmdPcHRpb25zID0ge1xuICAgIGJlbGxTb3VuZDogbnVsbCxcbiAgICBiZWxsU3R5bGU6IFsnbm9uZScsICdzb3VuZCddLFxuICAgIGN1cnNvclN0eWxlOiBbJ2Jsb2NrJywgJ3VuZGVybGluZScsICdiYXInXSxcbiAgICBleHBlcmltZW50YWxDaGFyQXRsYXM6IFsnbm9uZScsICdzdGF0aWMnLCAnZHluYW1pYyddLFxuICAgIGZvbnRGYW1pbHk6IG51bGwsXG4gICAgZm9udFdlaWdodDogWydub3JtYWwnLCAnYm9sZCcsICcxMDAnLCAnMjAwJywgJzMwMCcsICc0MDAnLCAnNTAwJywgJzYwMCcsICc3MDAnLCAnODAwJywgJzkwMCddLFxuICAgIGZvbnRXZWlnaHRCb2xkOiBbJ25vcm1hbCcsICdib2xkJywgJzEwMCcsICcyMDAnLCAnMzAwJywgJzQwMCcsICc1MDAnLCAnNjAwJywgJzcwMCcsICc4MDAnLCAnOTAwJ10sXG4gICAgcmVuZGVyZXJUeXBlOiBbJ2RvbScsICdjYW52YXMnXSxcbiAgICAvL2V4cGVyaW1lbnRhbEJ1ZmZlckxpbmVJbXBsOiBbJ0pzQXJyYXknLCAnVHlwZWRBcnJheSddXG4gIH07XG4gIGNvbnN0IG9wdGlvbnMgPSBPYmplY3Qua2V5cygoPGFueT50ZXJtKS5fY29yZS5vcHRpb25zKTtcbiAgY29uc3QgYm9vbGVhbk9wdGlvbnMgPSBbXTtcbiAgY29uc3QgbnVtYmVyT3B0aW9ucyA9IFtdO1xuICBvcHRpb25zLmZpbHRlcihvID0+IGJsYWNrbGlzdGVkT3B0aW9ucy5pbmRleE9mKG8pID09PSAtMSkuZm9yRWFjaChvID0+IHtcbiAgICBzd2l0Y2ggKHR5cGVvZiB0ZXJtLmdldE9wdGlvbihvKSkge1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGJvb2xlYW5PcHRpb25zLnB1c2gobyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgbnVtYmVyT3B0aW9ucy5wdXNoKG8pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhzdHJpbmdPcHRpb25zKS5pbmRleE9mKG8pID09PSAtMSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgVW5yZWNvZ25pemVkIG9wdGlvbjogXCIke299XCJgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfSk7XG5cblxufVxuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB1cGRhdGVUZXJtaW5hbFNpemUsIGZhbHNlKTtcblxuXG5cbmZ1bmN0aW9uIHVwZGF0ZVRlcm1pbmFsU2l6ZSgpOiB2b2lkIHtcbiAgdGVybS5maXQoKTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gYWZ0ZXJcblxuZnVuY3Rpb24gYWZ0ZXIoY291bnQsIGNhbGxiYWNrLCBlcnJfY2IpIHtcbiAgICB2YXIgYmFpbCA9IGZhbHNlXG4gICAgZXJyX2NiID0gZXJyX2NiIHx8IG5vb3BcbiAgICBwcm94eS5jb3VudCA9IGNvdW50XG5cbiAgICByZXR1cm4gKGNvdW50ID09PSAwKSA/IGNhbGxiYWNrKCkgOiBwcm94eVxuXG4gICAgZnVuY3Rpb24gcHJveHkoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgaWYgKHByb3h5LmNvdW50IDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWZ0ZXIgY2FsbGVkIHRvbyBtYW55IHRpbWVzJylcbiAgICAgICAgfVxuICAgICAgICAtLXByb3h5LmNvdW50XG5cbiAgICAgICAgLy8gYWZ0ZXIgZmlyc3QgZXJyb3IsIHJlc3QgYXJlIHBhc3NlZCB0byBlcnJfY2JcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgYmFpbCA9IHRydWVcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycilcbiAgICAgICAgICAgIC8vIGZ1dHVyZSBlcnJvciBjYWxsYmFja3Mgd2lsbCBnbyB0byBlcnJvciBoYW5kbGVyXG4gICAgICAgICAgICBjYWxsYmFjayA9IGVycl9jYlxuICAgICAgICB9IGVsc2UgaWYgKHByb3h5LmNvdW50ID09PSAwICYmICFiYWlsKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuIiwiLyoqXG4gKiBBbiBhYnN0cmFjdGlvbiBmb3Igc2xpY2luZyBhbiBhcnJheWJ1ZmZlciBldmVuIHdoZW5cbiAqIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSBpcyBub3Qgc3VwcG9ydGVkXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFycmF5YnVmZmVyLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGFycmF5YnVmZmVyLmJ5dGVMZW5ndGg7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgZW5kID0gZW5kIHx8IGJ5dGVzO1xuXG4gIGlmIChhcnJheWJ1ZmZlci5zbGljZSkgeyByZXR1cm4gYXJyYXlidWZmZXIuc2xpY2Uoc3RhcnQsIGVuZCk7IH1cblxuICBpZiAoc3RhcnQgPCAwKSB7IHN0YXJ0ICs9IGJ5dGVzOyB9XG4gIGlmIChlbmQgPCAwKSB7IGVuZCArPSBieXRlczsgfVxuICBpZiAoZW5kID4gYnl0ZXMpIHsgZW5kID0gYnl0ZXM7IH1cblxuICBpZiAoc3RhcnQgPj0gYnl0ZXMgfHwgc3RhcnQgPj0gZW5kIHx8IGJ5dGVzID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgfVxuXG4gIHZhciBhYnYgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG4gIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShlbmQgLSBzdGFydCk7XG4gIGZvciAodmFyIGkgPSBzdGFydCwgaWkgPSAwOyBpIDwgZW5kOyBpKyssIGlpKyspIHtcbiAgICByZXN1bHRbaWldID0gYWJ2W2ldO1xuICB9XG4gIHJldHVybiByZXN1bHQuYnVmZmVyO1xufTtcbiIsIlxuLyoqXG4gKiBFeHBvc2UgYEJhY2tvZmZgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja29mZjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGJhY2tvZmYgdGltZXIgd2l0aCBgb3B0c2AuXG4gKlxuICogLSBgbWluYCBpbml0aWFsIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIFsxMDBdXG4gKiAtIGBtYXhgIG1heCB0aW1lb3V0IFsxMDAwMF1cbiAqIC0gYGppdHRlcmAgWzBdXG4gKiAtIGBmYWN0b3JgIFsyXVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEJhY2tvZmYob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdGhpcy5tcyA9IG9wdHMubWluIHx8IDEwMDtcbiAgdGhpcy5tYXggPSBvcHRzLm1heCB8fCAxMDAwMDtcbiAgdGhpcy5mYWN0b3IgPSBvcHRzLmZhY3RvciB8fCAyO1xuICB0aGlzLmppdHRlciA9IG9wdHMuaml0dGVyID4gMCAmJiBvcHRzLmppdHRlciA8PSAxID8gb3B0cy5qaXR0ZXIgOiAwO1xuICB0aGlzLmF0dGVtcHRzID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGJhY2tvZmYgZHVyYXRpb24uXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uKCl7XG4gIHZhciBtcyA9IHRoaXMubXMgKiBNYXRoLnBvdyh0aGlzLmZhY3RvciwgdGhpcy5hdHRlbXB0cysrKTtcbiAgaWYgKHRoaXMuaml0dGVyKSB7XG4gICAgdmFyIHJhbmQgPSAgTWF0aC5yYW5kb20oKTtcbiAgICB2YXIgZGV2aWF0aW9uID0gTWF0aC5mbG9vcihyYW5kICogdGhpcy5qaXR0ZXIgKiBtcyk7XG4gICAgbXMgPSAoTWF0aC5mbG9vcihyYW5kICogMTApICYgMSkgPT0gMCAgPyBtcyAtIGRldmlhdGlvbiA6IG1zICsgZGV2aWF0aW9uO1xuICB9XG4gIHJldHVybiBNYXRoLm1pbihtcywgdGhpcy5tYXgpIHwgMDtcbn07XG5cbi8qKlxuICogUmVzZXQgdGhlIG51bWJlciBvZiBhdHRlbXB0cy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5hdHRlbXB0cyA9IDA7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWluaW11bSBkdXJhdGlvblxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0TWluID0gZnVuY3Rpb24obWluKXtcbiAgdGhpcy5tcyA9IG1pbjtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXhpbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRNYXggPSBmdW5jdGlvbihtYXgpe1xuICB0aGlzLm1heCA9IG1heDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBqaXR0ZXJcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldEppdHRlciA9IGZ1bmN0aW9uKGppdHRlcil7XG4gIHRoaXMuaml0dGVyID0gaml0dGVyO1xufTtcblxuIiwiLypcbiAqIGJhc2U2NC1hcnJheWJ1ZmZlclxuICogaHR0cHM6Ly9naXRodWIuY29tL25pa2xhc3ZoL2Jhc2U2NC1hcnJheWJ1ZmZlclxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBOaWtsYXMgdm9uIEhlcnR6ZW5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuKGZ1bmN0aW9uKCl7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBjaGFycyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xuXG4gIC8vIFVzZSBhIGxvb2t1cCB0YWJsZSB0byBmaW5kIHRoZSBpbmRleC5cbiAgdmFyIGxvb2t1cCA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICBsb29rdXBbY2hhcnMuY2hhckNvZGVBdChpKV0gPSBpO1xuICB9XG5cbiAgZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbihhcnJheWJ1ZmZlcikge1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSxcbiAgICBpLCBsZW4gPSBieXRlcy5sZW5ndGgsIGJhc2U2NCA9IFwiXCI7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKz0zKSB7XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaV0gPj4gMl07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpXSAmIDMpIDw8IDQpIHwgKGJ5dGVzW2kgKyAxXSA+PiA0KV07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpICsgMV0gJiAxNSkgPDwgMikgfCAoYnl0ZXNbaSArIDJdID4+IDYpXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpICsgMl0gJiA2M107XG4gICAgfVxuXG4gICAgaWYgKChsZW4gJSAzKSA9PT0gMikge1xuICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMSkgKyBcIj1cIjtcbiAgICB9IGVsc2UgaWYgKGxlbiAlIDMgPT09IDEpIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgXCI9PVwiO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlNjQ7XG4gIH07XG5cbiAgZXhwb3J0cy5kZWNvZGUgPSAgZnVuY3Rpb24oYmFzZTY0KSB7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGJhc2U2NC5sZW5ndGggKiAwLjc1LFxuICAgIGxlbiA9IGJhc2U2NC5sZW5ndGgsIGksIHAgPSAwLFxuICAgIGVuY29kZWQxLCBlbmNvZGVkMiwgZW5jb2RlZDMsIGVuY29kZWQ0O1xuXG4gICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMV0gPT09IFwiPVwiKSB7XG4gICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDJdID09PSBcIj1cIikge1xuICAgICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYXJyYXlidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyTGVuZ3RoKSxcbiAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcbiAgICAgIGVuY29kZWQxID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkpXTtcbiAgICAgIGVuY29kZWQyID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkrMSldO1xuICAgICAgZW5jb2RlZDMgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSsyKV07XG4gICAgICBlbmNvZGVkNCA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKzMpXTtcblxuICAgICAgYnl0ZXNbcCsrXSA9IChlbmNvZGVkMSA8PCAyKSB8IChlbmNvZGVkMiA+PiA0KTtcbiAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQyICYgMTUpIDw8IDQpIHwgKGVuY29kZWQzID4+IDIpO1xuICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDMgJiAzKSA8PCA2KSB8IChlbmNvZGVkNCAmIDYzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlidWZmZXI7XG4gIH07XG59KSgpO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIvKipcclxuICogQ3JlYXRlIGEgYmxvYiBidWlsZGVyIGV2ZW4gd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3RcclxuICovXHJcblxyXG52YXIgQmxvYkJ1aWxkZXIgPSB0eXBlb2YgQmxvYkJ1aWxkZXIgIT09ICd1bmRlZmluZWQnID8gQmxvYkJ1aWxkZXIgOlxyXG4gIHR5cGVvZiBXZWJLaXRCbG9iQnVpbGRlciAhPT0gJ3VuZGVmaW5lZCcgPyBXZWJLaXRCbG9iQnVpbGRlciA6XHJcbiAgdHlwZW9mIE1TQmxvYkJ1aWxkZXIgIT09ICd1bmRlZmluZWQnID8gTVNCbG9iQnVpbGRlciA6XHJcbiAgdHlwZW9mIE1vekJsb2JCdWlsZGVyICE9PSAndW5kZWZpbmVkJyA/IE1vekJsb2JCdWlsZGVyIDogXHJcbiAgZmFsc2U7XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBpcyBzdXBwb3J0ZWRcclxuICovXHJcblxyXG52YXIgYmxvYlN1cHBvcnRlZCA9IChmdW5jdGlvbigpIHtcclxuICB0cnkge1xyXG4gICAgdmFyIGEgPSBuZXcgQmxvYihbJ2hpJ10pO1xyXG4gICAgcmV0dXJuIGEuc2l6ZSA9PT0gMjtcclxuICB9IGNhdGNoKGUpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn0pKCk7XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBzdXBwb3J0cyBBcnJheUJ1ZmZlclZpZXdzXHJcbiAqIEZhaWxzIGluIFNhZmFyaSA2LCBzbyB3ZSBuZWVkIHRvIG1hcCB0byBBcnJheUJ1ZmZlcnMgdGhlcmUuXHJcbiAqL1xyXG5cclxudmFyIGJsb2JTdXBwb3J0c0FycmF5QnVmZmVyVmlldyA9IGJsb2JTdXBwb3J0ZWQgJiYgKGZ1bmN0aW9uKCkge1xyXG4gIHRyeSB7XHJcbiAgICB2YXIgYiA9IG5ldyBCbG9iKFtuZXcgVWludDhBcnJheShbMSwyXSldKTtcclxuICAgIHJldHVybiBiLnNpemUgPT09IDI7XHJcbiAgfSBjYXRjaChlKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59KSgpO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIEJsb2JCdWlsZGVyIGlzIHN1cHBvcnRlZFxyXG4gKi9cclxuXHJcbnZhciBibG9iQnVpbGRlclN1cHBvcnRlZCA9IEJsb2JCdWlsZGVyXHJcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmFwcGVuZFxyXG4gICYmIEJsb2JCdWlsZGVyLnByb3RvdHlwZS5nZXRCbG9iO1xyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IG1hcHMgQXJyYXlCdWZmZXJWaWV3cyB0byBBcnJheUJ1ZmZlcnNcclxuICogVXNlZCBieSBCbG9iQnVpbGRlciBjb25zdHJ1Y3RvciBhbmQgb2xkIGJyb3dzZXJzIHRoYXQgZGlkbid0XHJcbiAqIHN1cHBvcnQgaXQgaW4gdGhlIEJsb2IgY29uc3RydWN0b3IuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpIHtcclxuICByZXR1cm4gYXJ5Lm1hcChmdW5jdGlvbihjaHVuaykge1xyXG4gICAgaWYgKGNodW5rLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XHJcbiAgICAgIHZhciBidWYgPSBjaHVuay5idWZmZXI7XHJcblxyXG4gICAgICAvLyBpZiB0aGlzIGlzIGEgc3ViYXJyYXksIG1ha2UgYSBjb3B5IHNvIHdlIG9ubHlcclxuICAgICAgLy8gaW5jbHVkZSB0aGUgc3ViYXJyYXkgcmVnaW9uIGZyb20gdGhlIHVuZGVybHlpbmcgYnVmZmVyXHJcbiAgICAgIGlmIChjaHVuay5ieXRlTGVuZ3RoICE9PSBidWYuYnl0ZUxlbmd0aCkge1xyXG4gICAgICAgIHZhciBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmsuYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgY29weS5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmLCBjaHVuay5ieXRlT2Zmc2V0LCBjaHVuay5ieXRlTGVuZ3RoKSk7XHJcbiAgICAgICAgYnVmID0gY29weS5idWZmZXI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBidWY7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNodW5rO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xyXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICB2YXIgYmIgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcclxuICBtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSkuZm9yRWFjaChmdW5jdGlvbihwYXJ0KSB7XHJcbiAgICBiYi5hcHBlbmQocGFydCk7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiAob3B0aW9ucy50eXBlKSA/IGJiLmdldEJsb2Iob3B0aW9ucy50eXBlKSA6IGJiLmdldEJsb2IoKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIEJsb2JDb25zdHJ1Y3RvcihhcnksIG9wdGlvbnMpIHtcclxuICByZXR1cm4gbmV3IEJsb2IobWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpLCBvcHRpb25zIHx8IHt9KTtcclxufTtcclxuXHJcbmlmICh0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBCbG9iQnVpbGRlckNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IEJsb2IucHJvdG90eXBlO1xyXG4gIEJsb2JDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBCbG9iLnByb3RvdHlwZTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XHJcbiAgaWYgKGJsb2JTdXBwb3J0ZWQpIHtcclxuICAgIHJldHVybiBibG9iU3VwcG9ydHNBcnJheUJ1ZmZlclZpZXcgPyBCbG9iIDogQmxvYkNvbnN0cnVjdG9yO1xyXG4gIH0gZWxzZSBpZiAoYmxvYkJ1aWxkZXJTdXBwb3J0ZWQpIHtcclxuICAgIHJldHVybiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxufSkoKTtcclxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiLyoqXG4gKiBTbGljZSByZWZlcmVuY2UuXG4gKi9cblxudmFyIHNsaWNlID0gW10uc2xpY2U7XG5cbi8qKlxuICogQmluZCBgb2JqYCB0byBgZm5gLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBmbiBvciBzdHJpbmdcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgZm4pe1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIGZuKSBmbiA9IG9ialtmbl07XG4gIGlmICgnZnVuY3Rpb24nICE9IHR5cGVvZiBmbikgdGhyb3cgbmV3IEVycm9yKCdiaW5kKCkgcmVxdWlyZXMgYSBmdW5jdGlvbicpO1xuICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KG9iaiwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gIH1cbn07XG4iLCJcclxuLyoqXHJcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXHJcbiAqL1xyXG5cclxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xyXG59XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXHJcbiAqXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcclxuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAqIEByZXR1cm4ge09iamVjdH1cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XHJcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XHJcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XHJcbiAgfVxyXG4gIHJldHVybiBvYmo7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICAodGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW10pXHJcbiAgICAucHVzaChmbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXHJcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIGZ1bmN0aW9uIG9uKCkge1xyXG4gICAgdGhpcy5vZmYoZXZlbnQsIG9uKTtcclxuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG5cclxuICBvbi5mbiA9IGZuO1xyXG4gIHRoaXMub24oZXZlbnQsIG9uKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxyXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcblxyXG4gIC8vIGFsbFxyXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBzcGVjaWZpYyBldmVudFxyXG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcclxuXHJcbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xyXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxyXG4gIHZhciBjYjtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgY2IgPSBjYWxsYmFja3NbaV07XHJcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xyXG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge01peGVkfSAuLi5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxyXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG5cclxuICBpZiAoY2FsbGJhY2tzKSB7XHJcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xyXG59O1xyXG4iLCJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYSwgYil7XG4gIHZhciBmbiA9IGZ1bmN0aW9uKCl7fTtcbiAgZm4ucHJvdG90eXBlID0gYi5wcm90b3R5cGU7XG4gIGEucHJvdG90eXBlID0gbmV3IGZuO1xuICBhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGE7XG59OyIsIlxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xuXG4vKipcbiAqIEV4cG9ydHMgcGFyc2VyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzLnBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdHJhbnNwb3J0cyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0cy9pbmRleCcpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpzb2NrZXQnKTtcbnZhciBpbmRleCA9IHJlcXVpcmUoJ2luZGV4b2YnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgcGFyc2V1cmkgPSByZXF1aXJlKCdwYXJzZXVyaScpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTb2NrZXQ7XG5cbi8qKlxuICogU29ja2V0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdXJpIG9yIG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNvY2tldCAodXJpLCBvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTb2NrZXQpKSByZXR1cm4gbmV3IFNvY2tldCh1cmksIG9wdHMpO1xuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIGlmICh1cmkgJiYgJ29iamVjdCcgPT09IHR5cGVvZiB1cmkpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IG51bGw7XG4gIH1cblxuICBpZiAodXJpKSB7XG4gICAgdXJpID0gcGFyc2V1cmkodXJpKTtcbiAgICBvcHRzLmhvc3RuYW1lID0gdXJpLmhvc3Q7XG4gICAgb3B0cy5zZWN1cmUgPSB1cmkucHJvdG9jb2wgPT09ICdodHRwcycgfHwgdXJpLnByb3RvY29sID09PSAnd3NzJztcbiAgICBvcHRzLnBvcnQgPSB1cmkucG9ydDtcbiAgICBpZiAodXJpLnF1ZXJ5KSBvcHRzLnF1ZXJ5ID0gdXJpLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKG9wdHMuaG9zdCkge1xuICAgIG9wdHMuaG9zdG5hbWUgPSBwYXJzZXVyaShvcHRzLmhvc3QpLmhvc3Q7XG4gIH1cblxuICB0aGlzLnNlY3VyZSA9IG51bGwgIT0gb3B0cy5zZWN1cmUgPyBvcHRzLnNlY3VyZVxuICAgIDogKGdsb2JhbC5sb2NhdGlvbiAmJiAnaHR0cHM6JyA9PT0gbG9jYXRpb24ucHJvdG9jb2wpO1xuXG4gIGlmIChvcHRzLmhvc3RuYW1lICYmICFvcHRzLnBvcnQpIHtcbiAgICAvLyBpZiBubyBwb3J0IGlzIHNwZWNpZmllZCBtYW51YWxseSwgdXNlIHRoZSBwcm90b2NvbCBkZWZhdWx0XG4gICAgb3B0cy5wb3J0ID0gdGhpcy5zZWN1cmUgPyAnNDQzJyA6ICc4MCc7XG4gIH1cblxuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudCB8fCBmYWxzZTtcbiAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWUgfHxcbiAgICAoZ2xvYmFsLmxvY2F0aW9uID8gbG9jYXRpb24uaG9zdG5hbWUgOiAnbG9jYWxob3N0Jyk7XG4gIHRoaXMucG9ydCA9IG9wdHMucG9ydCB8fCAoZ2xvYmFsLmxvY2F0aW9uICYmIGxvY2F0aW9uLnBvcnRcbiAgICAgID8gbG9jYXRpb24ucG9ydFxuICAgICAgOiAodGhpcy5zZWN1cmUgPyA0NDMgOiA4MCkpO1xuICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeSB8fCB7fTtcbiAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdGhpcy5xdWVyeSkgdGhpcy5xdWVyeSA9IHBhcnNlcXMuZGVjb2RlKHRoaXMucXVlcnkpO1xuICB0aGlzLnVwZ3JhZGUgPSBmYWxzZSAhPT0gb3B0cy51cGdyYWRlO1xuICB0aGlzLnBhdGggPSAob3B0cy5wYXRoIHx8ICcvZW5naW5lLmlvJykucmVwbGFjZSgvXFwvJC8sICcnKSArICcvJztcbiAgdGhpcy5mb3JjZUpTT05QID0gISFvcHRzLmZvcmNlSlNPTlA7XG4gIHRoaXMuanNvbnAgPSBmYWxzZSAhPT0gb3B0cy5qc29ucDtcbiAgdGhpcy5mb3JjZUJhc2U2NCA9ICEhb3B0cy5mb3JjZUJhc2U2NDtcbiAgdGhpcy5lbmFibGVzWERSID0gISFvcHRzLmVuYWJsZXNYRFI7XG4gIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtIHx8ICd0JztcbiAgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyA9IG9wdHMudGltZXN0YW1wUmVxdWVzdHM7XG4gIHRoaXMudHJhbnNwb3J0cyA9IG9wdHMudHJhbnNwb3J0cyB8fCBbJ3BvbGxpbmcnLCAnd2Vic29ja2V0J107XG4gIHRoaXMudHJhbnNwb3J0T3B0aW9ucyA9IG9wdHMudHJhbnNwb3J0T3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG4gIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgdGhpcy5wcmV2QnVmZmVyTGVuID0gMDtcbiAgdGhpcy5wb2xpY3lQb3J0ID0gb3B0cy5wb2xpY3lQb3J0IHx8IDg0MztcbiAgdGhpcy5yZW1lbWJlclVwZ3JhZGUgPSBvcHRzLnJlbWVtYmVyVXBncmFkZSB8fCBmYWxzZTtcbiAgdGhpcy5iaW5hcnlUeXBlID0gbnVsbDtcbiAgdGhpcy5vbmx5QmluYXJ5VXBncmFkZXMgPSBvcHRzLm9ubHlCaW5hcnlVcGdyYWRlcztcbiAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IGZhbHNlICE9PSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlID8gKG9wdHMucGVyTWVzc2FnZURlZmxhdGUgfHwge30pIDogZmFsc2U7XG5cbiAgaWYgKHRydWUgPT09IHRoaXMucGVyTWVzc2FnZURlZmxhdGUpIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSB7fTtcbiAgaWYgKHRoaXMucGVyTWVzc2FnZURlZmxhdGUgJiYgbnVsbCA9PSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCkge1xuICAgIHRoaXMucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkID0gMTAyNDtcbiAgfVxuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4IHx8IG51bGw7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXkgfHwgbnVsbDtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlIHx8IG51bGw7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydCB8fCBudWxsO1xuICB0aGlzLmNhID0gb3B0cy5jYSB8fCBudWxsO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnMgfHwgbnVsbDtcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuICB0aGlzLmZvcmNlTm9kZSA9ICEhb3B0cy5mb3JjZU5vZGU7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG4gIGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCkge1xuICAgIGlmIChvcHRzLmV4dHJhSGVhZGVycyAmJiBPYmplY3Qua2V5cyhvcHRzLmV4dHJhSGVhZGVycykubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcbiAgICB9XG5cbiAgICBpZiAob3B0cy5sb2NhbEFkZHJlc3MpIHtcbiAgICAgIHRoaXMubG9jYWxBZGRyZXNzID0gb3B0cy5sb2NhbEFkZHJlc3M7XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IG9uIGhhbmRzaGFrZVxuICB0aGlzLmlkID0gbnVsbDtcbiAgdGhpcy51cGdyYWRlcyA9IG51bGw7XG4gIHRoaXMucGluZ0ludGVydmFsID0gbnVsbDtcbiAgdGhpcy5waW5nVGltZW91dCA9IG51bGw7XG5cbiAgLy8gc2V0IG9uIGhlYXJ0YmVhdFxuICB0aGlzLnBpbmdJbnRlcnZhbFRpbWVyID0gbnVsbDtcbiAgdGhpcy5waW5nVGltZW91dFRpbWVyID0gbnVsbDtcblxuICB0aGlzLm9wZW4oKTtcbn1cblxuU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sOyAvLyB0aGlzIGlzIGFuIGludFxuXG4vKipcbiAqIEV4cG9zZSBkZXBzIGZvciBsZWdhY3kgY29tcGF0aWJpbGl0eVxuICogYW5kIHN0YW5kYWxvbmUgYnJvd3NlciBhY2Nlc3MuXG4gKi9cblxuU29ja2V0LlNvY2tldCA9IFNvY2tldDtcblNvY2tldC5UcmFuc3BvcnQgPSByZXF1aXJlKCcuL3RyYW5zcG9ydCcpO1xuU29ja2V0LnRyYW5zcG9ydHMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydHMvaW5kZXgnKTtcblNvY2tldC5wYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyB0cmFuc3BvcnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG4gKiBAcmV0dXJuIHtUcmFuc3BvcnR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNyZWF0ZVRyYW5zcG9ydCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlYnVnKCdjcmVhdGluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gIHZhciBxdWVyeSA9IGNsb25lKHRoaXMucXVlcnkpO1xuXG4gIC8vIGFwcGVuZCBlbmdpbmUuaW8gcHJvdG9jb2wgaWRlbnRpZmllclxuICBxdWVyeS5FSU8gPSBwYXJzZXIucHJvdG9jb2w7XG5cbiAgLy8gdHJhbnNwb3J0IG5hbWVcbiAgcXVlcnkudHJhbnNwb3J0ID0gbmFtZTtcblxuICAvLyBwZXItdHJhbnNwb3J0IG9wdGlvbnNcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLnRyYW5zcG9ydE9wdGlvbnNbbmFtZV0gfHwge307XG5cbiAgLy8gc2Vzc2lvbiBpZCBpZiB3ZSBhbHJlYWR5IGhhdmUgb25lXG4gIGlmICh0aGlzLmlkKSBxdWVyeS5zaWQgPSB0aGlzLmlkO1xuXG4gIHZhciB0cmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0c1tuYW1lXSh7XG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIHNvY2tldDogdGhpcyxcbiAgICBhZ2VudDogb3B0aW9ucy5hZ2VudCB8fCB0aGlzLmFnZW50LFxuICAgIGhvc3RuYW1lOiBvcHRpb25zLmhvc3RuYW1lIHx8IHRoaXMuaG9zdG5hbWUsXG4gICAgcG9ydDogb3B0aW9ucy5wb3J0IHx8IHRoaXMucG9ydCxcbiAgICBzZWN1cmU6IG9wdGlvbnMuc2VjdXJlIHx8IHRoaXMuc2VjdXJlLFxuICAgIHBhdGg6IG9wdGlvbnMucGF0aCB8fCB0aGlzLnBhdGgsXG4gICAgZm9yY2VKU09OUDogb3B0aW9ucy5mb3JjZUpTT05QIHx8IHRoaXMuZm9yY2VKU09OUCxcbiAgICBqc29ucDogb3B0aW9ucy5qc29ucCB8fCB0aGlzLmpzb25wLFxuICAgIGZvcmNlQmFzZTY0OiBvcHRpb25zLmZvcmNlQmFzZTY0IHx8IHRoaXMuZm9yY2VCYXNlNjQsXG4gICAgZW5hYmxlc1hEUjogb3B0aW9ucy5lbmFibGVzWERSIHx8IHRoaXMuZW5hYmxlc1hEUixcbiAgICB0aW1lc3RhbXBSZXF1ZXN0czogb3B0aW9ucy50aW1lc3RhbXBSZXF1ZXN0cyB8fCB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzLFxuICAgIHRpbWVzdGFtcFBhcmFtOiBvcHRpb25zLnRpbWVzdGFtcFBhcmFtIHx8IHRoaXMudGltZXN0YW1wUGFyYW0sXG4gICAgcG9saWN5UG9ydDogb3B0aW9ucy5wb2xpY3lQb3J0IHx8IHRoaXMucG9saWN5UG9ydCxcbiAgICBwZng6IG9wdGlvbnMucGZ4IHx8IHRoaXMucGZ4LFxuICAgIGtleTogb3B0aW9ucy5rZXkgfHwgdGhpcy5rZXksXG4gICAgcGFzc3BocmFzZTogb3B0aW9ucy5wYXNzcGhyYXNlIHx8IHRoaXMucGFzc3BocmFzZSxcbiAgICBjZXJ0OiBvcHRpb25zLmNlcnQgfHwgdGhpcy5jZXJ0LFxuICAgIGNhOiBvcHRpb25zLmNhIHx8IHRoaXMuY2EsXG4gICAgY2lwaGVyczogb3B0aW9ucy5jaXBoZXJzIHx8IHRoaXMuY2lwaGVycyxcbiAgICByZWplY3RVbmF1dGhvcml6ZWQ6IG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkIHx8IHRoaXMucmVqZWN0VW5hdXRob3JpemVkLFxuICAgIHBlck1lc3NhZ2VEZWZsYXRlOiBvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlIHx8IHRoaXMucGVyTWVzc2FnZURlZmxhdGUsXG4gICAgZXh0cmFIZWFkZXJzOiBvcHRpb25zLmV4dHJhSGVhZGVycyB8fCB0aGlzLmV4dHJhSGVhZGVycyxcbiAgICBmb3JjZU5vZGU6IG9wdGlvbnMuZm9yY2VOb2RlIHx8IHRoaXMuZm9yY2VOb2RlLFxuICAgIGxvY2FsQWRkcmVzczogb3B0aW9ucy5sb2NhbEFkZHJlc3MgfHwgdGhpcy5sb2NhbEFkZHJlc3MsXG4gICAgcmVxdWVzdFRpbWVvdXQ6IG9wdGlvbnMucmVxdWVzdFRpbWVvdXQgfHwgdGhpcy5yZXF1ZXN0VGltZW91dCxcbiAgICBwcm90b2NvbHM6IG9wdGlvbnMucHJvdG9jb2xzIHx8IHZvaWQgKDApXG4gIH0pO1xuXG4gIHJldHVybiB0cmFuc3BvcnQ7XG59O1xuXG5mdW5jdGlvbiBjbG9uZSAob2JqKSB7XG4gIHZhciBvID0ge307XG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgb1tpXSA9IG9ialtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG87XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdHJhbnNwb3J0IHRvIHVzZSBhbmQgc3RhcnRzIHByb2JlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5Tb2NrZXQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0cmFuc3BvcnQ7XG4gIGlmICh0aGlzLnJlbWVtYmVyVXBncmFkZSAmJiBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzICYmIHRoaXMudHJhbnNwb3J0cy5pbmRleE9mKCd3ZWJzb2NrZXQnKSAhPT0gLTEpIHtcbiAgICB0cmFuc3BvcnQgPSAnd2Vic29ja2V0JztcbiAgfSBlbHNlIGlmICgwID09PSB0aGlzLnRyYW5zcG9ydHMubGVuZ3RoKSB7XG4gICAgLy8gRW1pdCBlcnJvciBvbiBuZXh0IHRpY2sgc28gaXQgY2FuIGJlIGxpc3RlbmVkIHRvXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsICdObyB0cmFuc3BvcnRzIGF2YWlsYWJsZScpO1xuICAgIH0sIDApO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIHtcbiAgICB0cmFuc3BvcnQgPSB0aGlzLnRyYW5zcG9ydHNbMF07XG4gIH1cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuXG4gIC8vIFJldHJ5IHdpdGggdGhlIG5leHQgdHJhbnNwb3J0IGlmIHRoZSB0cmFuc3BvcnQgaXMgZGlzYWJsZWQgKGpzb25wOiBmYWxzZSlcbiAgdHJ5IHtcbiAgICB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhpcy50cmFuc3BvcnRzLnNoaWZ0KCk7XG4gICAgdGhpcy5vcGVuKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdHJhbnNwb3J0Lm9wZW4oKTtcbiAgdGhpcy5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQuIERpc2FibGVzIHRoZSBleGlzdGluZyBvbmUgKGlmIGFueSkuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZXRUcmFuc3BvcnQgPSBmdW5jdGlvbiAodHJhbnNwb3J0KSB7XG4gIGRlYnVnKCdzZXR0aW5nIHRyYW5zcG9ydCAlcycsIHRyYW5zcG9ydC5uYW1lKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICh0aGlzLnRyYW5zcG9ydCkge1xuICAgIGRlYnVnKCdjbGVhcmluZyBleGlzdGluZyB0cmFuc3BvcnQgJXMnLCB0aGlzLnRyYW5zcG9ydC5uYW1lKTtcbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8vIHNldCB1cCB0cmFuc3BvcnRcbiAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG5cbiAgLy8gc2V0IHVwIHRyYW5zcG9ydCBsaXN0ZW5lcnNcbiAgdHJhbnNwb3J0XG4gIC5vbignZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbkRyYWluKCk7XG4gIH0pXG4gIC5vbigncGFja2V0JywgZnVuY3Rpb24gKHBhY2tldCkge1xuICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcbiAgfSlcbiAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgc2VsZi5vbkVycm9yKGUpO1xuICB9KVxuICAub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25DbG9zZSgndHJhbnNwb3J0IGNsb3NlJyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBQcm9iZXMgYSB0cmFuc3BvcnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnByb2JlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVidWcoJ3Byb2JpbmcgdHJhbnNwb3J0IFwiJXNcIicsIG5hbWUpO1xuICB2YXIgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQobmFtZSwgeyBwcm9iZTogMSB9KTtcbiAgdmFyIGZhaWxlZCA9IGZhbHNlO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIG9uVHJhbnNwb3J0T3BlbiAoKSB7XG4gICAgaWYgKHNlbGYub25seUJpbmFyeVVwZ3JhZGVzKSB7XG4gICAgICB2YXIgdXBncmFkZUxvc2VzQmluYXJ5ID0gIXRoaXMuc3VwcG9ydHNCaW5hcnkgJiYgc2VsZi50cmFuc3BvcnQuc3VwcG9ydHNCaW5hcnk7XG4gICAgICBmYWlsZWQgPSBmYWlsZWQgfHwgdXBncmFkZUxvc2VzQmluYXJ5O1xuICAgIH1cbiAgICBpZiAoZmFpbGVkKSByZXR1cm47XG5cbiAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBvcGVuZWQnLCBuYW1lKTtcbiAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiAncGluZycsIGRhdGE6ICdwcm9iZScgfV0pO1xuICAgIHRyYW5zcG9ydC5vbmNlKCdwYWNrZXQnLCBmdW5jdGlvbiAobXNnKSB7XG4gICAgICBpZiAoZmFpbGVkKSByZXR1cm47XG4gICAgICBpZiAoJ3BvbmcnID09PSBtc2cudHlwZSAmJiAncHJvYmUnID09PSBtc2cuZGF0YSkge1xuICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBwb25nJywgbmFtZSk7XG4gICAgICAgIHNlbGYudXBncmFkaW5nID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRpbmcnLCB0cmFuc3BvcnQpO1xuICAgICAgICBpZiAoIXRyYW5zcG9ydCkgcmV0dXJuO1xuICAgICAgICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gJ3dlYnNvY2tldCcgPT09IHRyYW5zcG9ydC5uYW1lO1xuXG4gICAgICAgIGRlYnVnKCdwYXVzaW5nIGN1cnJlbnQgdHJhbnNwb3J0IFwiJXNcIicsIHNlbGYudHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgICBzZWxmLnRyYW5zcG9ydC5wYXVzZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuICAgICAgICAgIGlmICgnY2xvc2VkJyA9PT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgICAgICAgZGVidWcoJ2NoYW5naW5nIHRyYW5zcG9ydCBhbmQgc2VuZGluZyB1cGdyYWRlIHBhY2tldCcpO1xuXG4gICAgICAgICAgY2xlYW51cCgpO1xuXG4gICAgICAgICAgc2VsZi5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgICAgICAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiAndXBncmFkZScgfV0pO1xuICAgICAgICAgIHNlbGYuZW1pdCgndXBncmFkZScsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYuZmx1c2goKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBmYWlsZWQnLCBuYW1lKTtcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcigncHJvYmUgZXJyb3InKTtcbiAgICAgICAgZXJyLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmcmVlemVUcmFuc3BvcnQgKCkge1xuICAgIGlmIChmYWlsZWQpIHJldHVybjtcblxuICAgIC8vIEFueSBjYWxsYmFjayBjYWxsZWQgYnkgdHJhbnNwb3J0IHNob3VsZCBiZSBpZ25vcmVkIHNpbmNlIG5vd1xuICAgIGZhaWxlZCA9IHRydWU7XG5cbiAgICBjbGVhbnVwKCk7XG5cbiAgICB0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB0cmFuc3BvcnQgPSBudWxsO1xuICB9XG5cbiAgLy8gSGFuZGxlIGFueSBlcnJvciB0aGF0IGhhcHBlbnMgd2hpbGUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbmVycm9yIChlcnIpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yOiAnICsgZXJyKTtcbiAgICBlcnJvci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcblxuICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuXG4gICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkIGJlY2F1c2Ugb2YgZXJyb3I6ICVzJywgbmFtZSwgZXJyKTtcblxuICAgIHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyb3IpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UcmFuc3BvcnRDbG9zZSAoKSB7XG4gICAgb25lcnJvcigndHJhbnNwb3J0IGNsb3NlZCcpO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgc29ja2V0IGlzIGNsb3NlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9uY2xvc2UgKCkge1xuICAgIG9uZXJyb3IoJ3NvY2tldCBjbG9zZWQnKTtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHNvY2tldCBpcyB1cGdyYWRlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9udXBncmFkZSAodG8pIHtcbiAgICBpZiAodHJhbnNwb3J0ICYmIHRvLm5hbWUgIT09IHRyYW5zcG9ydC5uYW1lKSB7XG4gICAgICBkZWJ1ZygnXCIlc1wiIHdvcmtzIC0gYWJvcnRpbmcgXCIlc1wiJywgdG8ubmFtZSwgdHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgZnJlZXplVHJhbnNwb3J0KCk7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgb24gdGhlIHRyYW5zcG9ydCBhbmQgb24gc2VsZlxuICBmdW5jdGlvbiBjbGVhbnVwICgpIHtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ29wZW4nLCBvblRyYW5zcG9ydE9wZW4pO1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25UcmFuc3BvcnRDbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCd1cGdyYWRpbmcnLCBvbnVwZ3JhZGUpO1xuICB9XG5cbiAgdHJhbnNwb3J0Lm9uY2UoJ29wZW4nLCBvblRyYW5zcG9ydE9wZW4pO1xuICB0cmFuc3BvcnQub25jZSgnZXJyb3InLCBvbmVycm9yKTtcbiAgdHJhbnNwb3J0Lm9uY2UoJ2Nsb3NlJywgb25UcmFuc3BvcnRDbG9zZSk7XG5cbiAgdGhpcy5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICB0aGlzLm9uY2UoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG5cbiAgdHJhbnNwb3J0Lm9wZW4oKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gY29ubmVjdGlvbiBpcyBkZWVtZWQgb3Blbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUub25PcGVuID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1Zygnc29ja2V0IG9wZW4nKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gJ3dlYnNvY2tldCcgPT09IHRoaXMudHJhbnNwb3J0Lm5hbWU7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuICB0aGlzLmZsdXNoKCk7XG5cbiAgLy8gd2UgY2hlY2sgZm9yIGByZWFkeVN0YXRlYCBpbiBjYXNlIGFuIGBvcGVuYFxuICAvLyBsaXN0ZW5lciBhbHJlYWR5IGNsb3NlZCB0aGUgc29ja2V0XG4gIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLnVwZ3JhZGUgJiYgdGhpcy50cmFuc3BvcnQucGF1c2UpIHtcbiAgICBkZWJ1Zygnc3RhcnRpbmcgdXBncmFkZSBwcm9iZXMnKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMudXBncmFkZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0aGlzLnByb2JlKHRoaXMudXBncmFkZXNbaV0pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGVzIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25QYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSB8fFxuICAgICAgJ2Nsb3NpbmcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1Zygnc29ja2V0IHJlY2VpdmU6IHR5cGUgXCIlc1wiLCBkYXRhIFwiJXNcIicsIHBhY2tldC50eXBlLCBwYWNrZXQuZGF0YSk7XG5cbiAgICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG5cbiAgICAvLyBTb2NrZXQgaXMgbGl2ZSAtIGFueSBwYWNrZXQgY291bnRzXG4gICAgdGhpcy5lbWl0KCdoZWFydGJlYXQnKTtcblxuICAgIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICAgIGNhc2UgJ29wZW4nOlxuICAgICAgICB0aGlzLm9uSGFuZHNoYWtlKEpTT04ucGFyc2UocGFja2V0LmRhdGEpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3BvbmcnOlxuICAgICAgICB0aGlzLnNldFBpbmcoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdwb25nJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3NlcnZlciBlcnJvcicpO1xuICAgICAgICBlcnIuY29kZSA9IHBhY2tldC5kYXRhO1xuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ21lc3NhZ2UnOlxuICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdwYWNrZXQgcmVjZWl2ZWQgd2l0aCBzb2NrZXQgcmVhZHlTdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGhhbmRzaGFrZSBjb21wbGV0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kc2hha2Ugb2JqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uSGFuZHNoYWtlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5lbWl0KCdoYW5kc2hha2UnLCBkYXRhKTtcbiAgdGhpcy5pZCA9IGRhdGEuc2lkO1xuICB0aGlzLnRyYW5zcG9ydC5xdWVyeS5zaWQgPSBkYXRhLnNpZDtcbiAgdGhpcy51cGdyYWRlcyA9IHRoaXMuZmlsdGVyVXBncmFkZXMoZGF0YS51cGdyYWRlcyk7XG4gIHRoaXMucGluZ0ludGVydmFsID0gZGF0YS5waW5nSW50ZXJ2YWw7XG4gIHRoaXMucGluZ1RpbWVvdXQgPSBkYXRhLnBpbmdUaW1lb3V0O1xuICB0aGlzLm9uT3BlbigpO1xuICAvLyBJbiBjYXNlIG9wZW4gaGFuZGxlciBjbG9zZXMgc29ja2V0XG4gIGlmICgnY2xvc2VkJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSByZXR1cm47XG4gIHRoaXMuc2V0UGluZygpO1xuXG4gIC8vIFByb2xvbmcgbGl2ZW5lc3Mgb2Ygc29ja2V0IG9uIGhlYXJ0YmVhdFxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdoZWFydGJlYXQnLCB0aGlzLm9uSGVhcnRiZWF0KTtcbiAgdGhpcy5vbignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG59O1xuXG4vKipcbiAqIFJlc2V0cyBwaW5nIHRpbWVvdXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkhlYXJ0YmVhdCA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYucGluZ1RpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmICgnY2xvc2VkJyA9PT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgc2VsZi5vbkNsb3NlKCdwaW5nIHRpbWVvdXQnKTtcbiAgfSwgdGltZW91dCB8fCAoc2VsZi5waW5nSW50ZXJ2YWwgKyBzZWxmLnBpbmdUaW1lb3V0KSk7XG59O1xuXG4vKipcbiAqIFBpbmdzIHNlcnZlciBldmVyeSBgdGhpcy5waW5nSW50ZXJ2YWxgIGFuZCBleHBlY3RzIHJlc3BvbnNlXG4gKiB3aXRoaW4gYHRoaXMucGluZ1RpbWVvdXRgIG9yIGNsb3NlcyBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2V0UGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjbGVhclRpbWVvdXQoc2VsZi5waW5nSW50ZXJ2YWxUaW1lcik7XG4gIHNlbGYucGluZ0ludGVydmFsVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JpdGluZyBwaW5nIHBhY2tldCAtIGV4cGVjdGluZyBwb25nIHdpdGhpbiAlc21zJywgc2VsZi5waW5nVGltZW91dCk7XG4gICAgc2VsZi5waW5nKCk7XG4gICAgc2VsZi5vbkhlYXJ0YmVhdChzZWxmLnBpbmdUaW1lb3V0KTtcbiAgfSwgc2VsZi5waW5nSW50ZXJ2YWwpO1xufTtcblxuLyoqXG4qIFNlbmRzIGEgcGluZyBwYWNrZXQuXG4qXG4qIEBhcGkgcHJpdmF0ZVxuKi9cblxuU29ja2V0LnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuc2VuZFBhY2tldCgncGluZycsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmVtaXQoJ3BpbmcnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBvbiBgZHJhaW5gIGV2ZW50XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkRyYWluID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLndyaXRlQnVmZmVyLnNwbGljZSgwLCB0aGlzLnByZXZCdWZmZXJMZW4pO1xuXG4gIC8vIHNldHRpbmcgcHJldkJ1ZmZlckxlbiA9IDAgaXMgdmVyeSBpbXBvcnRhbnRcbiAgLy8gZm9yIGV4YW1wbGUsIHdoZW4gdXBncmFkaW5nLCB1cGdyYWRlIHBhY2tldCBpcyBzZW50IG92ZXIsXG4gIC8vIGFuZCBhIG5vbnplcm8gcHJldkJ1ZmZlckxlbiBjb3VsZCBjYXVzZSBwcm9ibGVtcyBvbiBgZHJhaW5gXG4gIHRoaXMucHJldkJ1ZmZlckxlbiA9IDA7XG5cbiAgaWYgKDAgPT09IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgdGhpcy5lbWl0KCdkcmFpbicpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZmx1c2goKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGbHVzaCB3cml0ZSBidWZmZXJzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnY2xvc2VkJyAhPT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudHJhbnNwb3J0LndyaXRhYmxlICYmXG4gICAgIXRoaXMudXBncmFkaW5nICYmIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgZGVidWcoJ2ZsdXNoaW5nICVkIHBhY2tldHMgaW4gc29ja2V0JywgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpO1xuICAgIHRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy53cml0ZUJ1ZmZlcik7XG4gICAgLy8ga2VlcCB0cmFjayBvZiBjdXJyZW50IGxlbmd0aCBvZiB3cml0ZUJ1ZmZlclxuICAgIC8vIHNwbGljZSB3cml0ZUJ1ZmZlciBhbmQgY2FsbGJhY2tCdWZmZXIgb24gYGRyYWluYFxuICAgIHRoaXMucHJldkJ1ZmZlckxlbiA9IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoO1xuICAgIHRoaXMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZW5kcyBhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQHJldHVybiB7U29ja2V0fSBmb3IgY2hhaW5pbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUud3JpdGUgPVxuU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1zZywgb3B0aW9ucywgZm4pIHtcbiAgdGhpcy5zZW5kUGFja2V0KCdtZXNzYWdlJywgbXNnLCBvcHRpb25zLCBmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFja2V0IHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNlbmRQYWNrZXQgPSBmdW5jdGlvbiAodHlwZSwgZGF0YSwgb3B0aW9ucywgZm4pIHtcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBkYXRhKSB7XG4gICAgZm4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICBmbiA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cblxuICBpZiAoJ2Nsb3NpbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NlZCcgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmNvbXByZXNzID0gZmFsc2UgIT09IG9wdGlvbnMuY29tcHJlc3M7XG5cbiAgdmFyIHBhY2tldCA9IHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGRhdGE6IGRhdGEsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9O1xuICB0aGlzLmVtaXQoJ3BhY2tldENyZWF0ZScsIHBhY2tldCk7XG4gIHRoaXMud3JpdGVCdWZmZXIucHVzaChwYWNrZXQpO1xuICBpZiAoZm4pIHRoaXMub25jZSgnZmx1c2gnLCBmbik7XG4gIHRoaXMuZmx1c2goKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zaW5nJztcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICh0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgdGhpcy5vbmNlKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlICgpIHtcbiAgICBzZWxmLm9uQ2xvc2UoJ2ZvcmNlZCBjbG9zZScpO1xuICAgIGRlYnVnKCdzb2NrZXQgY2xvc2luZyAtIHRlbGxpbmcgdHJhbnNwb3J0IHRvIGNsb3NlJyk7XG4gICAgc2VsZi50cmFuc3BvcnQuY2xvc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFudXBBbmRDbG9zZSAoKSB7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZScsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBjbG9zZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FpdEZvclVwZ3JhZGUgKCkge1xuICAgIC8vIHdhaXQgZm9yIHVwZ3JhZGUgdG8gZmluaXNoIHNpbmNlIHdlIGNhbid0IHNlbmQgcGFja2V0cyB3aGlsZSBwYXVzaW5nIGEgdHJhbnNwb3J0XG4gICAgc2VsZi5vbmNlKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBzZWxmLm9uY2UoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGVycm9yXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICBkZWJ1Zygnc29ja2V0IGVycm9yICVqJywgZXJyKTtcbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5vbkNsb3NlKCd0cmFuc3BvcnQgZXJyb3InLCBlcnIpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbiwgZGVzYykge1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NpbmcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1Zygnc29ja2V0IGNsb3NlIHdpdGggcmVhc29uOiBcIiVzXCInLCByZWFzb24pO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIGNsZWFyIHRpbWVyc1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdJbnRlcnZhbFRpbWVyKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcblxuICAgIC8vIHN0b3AgZXZlbnQgZnJvbSBmaXJpbmcgYWdhaW4gZm9yIHRyYW5zcG9ydFxuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygnY2xvc2UnKTtcblxuICAgIC8vIGVuc3VyZSB0cmFuc3BvcnQgd29uJ3Qgc3RheSBvcGVuXG4gICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcblxuICAgIC8vIGlnbm9yZSBmdXJ0aGVyIHRyYW5zcG9ydCBjb21tdW5pY2F0aW9uXG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cbiAgICAvLyBzZXQgcmVhZHkgc3RhdGVcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcblxuICAgIC8vIGNsZWFyIHNlc3Npb24gaWRcbiAgICB0aGlzLmlkID0gbnVsbDtcblxuICAgIC8vIGVtaXQgY2xvc2UgZXZlbnRcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uLCBkZXNjKTtcblxuICAgIC8vIGNsZWFuIGJ1ZmZlcnMgYWZ0ZXIsIHNvIHVzZXJzIGNhbiBzdGlsbFxuICAgIC8vIGdyYWIgdGhlIGJ1ZmZlcnMgb24gYGNsb3NlYCBldmVudFxuICAgIHNlbGYud3JpdGVCdWZmZXIgPSBbXTtcbiAgICBzZWxmLnByZXZCdWZmZXJMZW4gPSAwO1xuICB9XG59O1xuXG4vKipcbiAqIEZpbHRlcnMgdXBncmFkZXMsIHJldHVybmluZyBvbmx5IHRob3NlIG1hdGNoaW5nIGNsaWVudCB0cmFuc3BvcnRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNlcnZlciB1cGdyYWRlc1xuICogQGFwaSBwcml2YXRlXG4gKlxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmlsdGVyVXBncmFkZXMgPSBmdW5jdGlvbiAodXBncmFkZXMpIHtcbiAgdmFyIGZpbHRlcmVkVXBncmFkZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSB1cGdyYWRlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICBpZiAofmluZGV4KHRoaXMudHJhbnNwb3J0cywgdXBncmFkZXNbaV0pKSBmaWx0ZXJlZFVwZ3JhZGVzLnB1c2godXBncmFkZXNbaV0pO1xuICB9XG4gIHJldHVybiBmaWx0ZXJlZFVwZ3JhZGVzO1xufTtcbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNwb3J0O1xuXG4vKipcbiAqIFRyYW5zcG9ydCBhYnN0cmFjdCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFRyYW5zcG9ydCAob3B0cykge1xuICB0aGlzLnBhdGggPSBvcHRzLnBhdGg7XG4gIHRoaXMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lO1xuICB0aGlzLnBvcnQgPSBvcHRzLnBvcnQ7XG4gIHRoaXMuc2VjdXJlID0gb3B0cy5zZWN1cmU7XG4gIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5O1xuICB0aGlzLnRpbWVzdGFtcFBhcmFtID0gb3B0cy50aW1lc3RhbXBQYXJhbTtcbiAgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyA9IG9wdHMudGltZXN0YW1wUmVxdWVzdHM7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICcnO1xuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudCB8fCBmYWxzZTtcbiAgdGhpcy5zb2NrZXQgPSBvcHRzLnNvY2tldDtcbiAgdGhpcy5lbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuICB0aGlzLmtleSA9IG9wdHMua2V5O1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcbiAgdGhpcy5jYSA9IG9wdHMuY2E7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgdGhpcy5mb3JjZU5vZGUgPSBvcHRzLmZvcmNlTm9kZTtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuICB0aGlzLmxvY2FsQWRkcmVzcyA9IG9wdHMubG9jYWxBZGRyZXNzO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihUcmFuc3BvcnQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBFbWl0cyBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtUcmFuc3BvcnR9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAobXNnLCBkZXNjKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgZXJyLnR5cGUgPSAnVHJhbnNwb3J0RXJyb3InO1xuICBlcnIuZGVzY3JpcHRpb24gPSBkZXNjO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE9wZW5zIHRoZSB0cmFuc3BvcnQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnY2xvc2VkJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG4gICAgdGhpcy5kb09wZW4oKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHRyYW5zcG9ydC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLmRvQ2xvc2UoKTtcbiAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBtdWx0aXBsZSBwYWNrZXRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChwYWNrZXRzKSB7XG4gIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMud3JpdGUocGFja2V0cyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgbm90IG9wZW4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBvcGVuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciBwYWNrZXQgPSBwYXJzZXIuZGVjb2RlUGFja2V0KGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUpO1xuICB0aGlzLm9uUGFja2V0KHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGEgZGVjb2RlZCBwYWNrZXQuXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG59O1xuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgneG1saHR0cHJlcXVlc3Qtc3NsJyk7XG52YXIgWEhSID0gcmVxdWlyZSgnLi9wb2xsaW5nLXhocicpO1xudmFyIEpTT05QID0gcmVxdWlyZSgnLi9wb2xsaW5nLWpzb25wJyk7XG52YXIgd2Vic29ja2V0ID0gcmVxdWlyZSgnLi93ZWJzb2NrZXQnKTtcblxuLyoqXG4gKiBFeHBvcnQgdHJhbnNwb3J0cy5cbiAqL1xuXG5leHBvcnRzLnBvbGxpbmcgPSBwb2xsaW5nO1xuZXhwb3J0cy53ZWJzb2NrZXQgPSB3ZWJzb2NrZXQ7XG5cbi8qKlxuICogUG9sbGluZyB0cmFuc3BvcnQgcG9seW1vcnBoaWMgY29uc3RydWN0b3IuXG4gKiBEZWNpZGVzIG9uIHhociB2cyBqc29ucCBiYXNlZCBvbiBmZWF0dXJlIGRldGVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwb2xsaW5nIChvcHRzKSB7XG4gIHZhciB4aHI7XG4gIHZhciB4ZCA9IGZhbHNlO1xuICB2YXIgeHMgPSBmYWxzZTtcbiAgdmFyIGpzb25wID0gZmFsc2UgIT09IG9wdHMuanNvbnA7XG5cbiAgaWYgKGdsb2JhbC5sb2NhdGlvbikge1xuICAgIHZhciBpc1NTTCA9ICdodHRwczonID09PSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICB2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7XG5cbiAgICAvLyBzb21lIHVzZXIgYWdlbnRzIGhhdmUgZW1wdHkgYGxvY2F0aW9uLnBvcnRgXG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcbiAgICB9XG5cbiAgICB4ZCA9IG9wdHMuaG9zdG5hbWUgIT09IGxvY2F0aW9uLmhvc3RuYW1lIHx8IHBvcnQgIT09IG9wdHMucG9ydDtcbiAgICB4cyA9IG9wdHMuc2VjdXJlICE9PSBpc1NTTDtcbiAgfVxuXG4gIG9wdHMueGRvbWFpbiA9IHhkO1xuICBvcHRzLnhzY2hlbWUgPSB4cztcbiAgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KG9wdHMpO1xuXG4gIGlmICgnb3BlbicgaW4geGhyICYmICFvcHRzLmZvcmNlSlNPTlApIHtcbiAgICByZXR1cm4gbmV3IFhIUihvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWpzb25wKSB0aHJvdyBuZXcgRXJyb3IoJ0pTT05QIGRpc2FibGVkJyk7XG4gICAgcmV0dXJuIG5ldyBKU09OUChvcHRzKTtcbiAgfVxufVxuIiwiXG4vKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIFBvbGxpbmcgPSByZXF1aXJlKCcuL3BvbGxpbmcnKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpTT05QUG9sbGluZztcblxuLyoqXG4gKiBDYWNoZWQgcmVndWxhciBleHByZXNzaW9ucy5cbiAqL1xuXG52YXIgck5ld2xpbmUgPSAvXFxuL2c7XG52YXIgckVzY2FwZWROZXdsaW5lID0gL1xcXFxuL2c7XG5cbi8qKlxuICogR2xvYmFsIEpTT05QIGNhbGxiYWNrcy5cbiAqL1xuXG52YXIgY2FsbGJhY2tzO1xuXG4vKipcbiAqIE5vb3AuXG4gKi9cblxuZnVuY3Rpb24gZW1wdHkgKCkgeyB9XG5cbi8qKlxuICogSlNPTlAgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gSlNPTlBQb2xsaW5nIChvcHRzKSB7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcblxuICB0aGlzLnF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcblxuICAvLyBkZWZpbmUgZ2xvYmFsIGNhbGxiYWNrcyBhcnJheSBpZiBub3QgcHJlc2VudFxuICAvLyB3ZSBkbyB0aGlzIGhlcmUgKGxhemlseSkgdG8gYXZvaWQgdW5uZWVkZWQgZ2xvYmFsIHBvbGx1dGlvblxuICBpZiAoIWNhbGxiYWNrcykge1xuICAgIC8vIHdlIG5lZWQgdG8gY29uc2lkZXIgbXVsdGlwbGUgZW5naW5lcyBpbiB0aGUgc2FtZSBwYWdlXG4gICAgaWYgKCFnbG9iYWwuX19fZWlvKSBnbG9iYWwuX19fZWlvID0gW107XG4gICAgY2FsbGJhY2tzID0gZ2xvYmFsLl9fX2VpbztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGlkZW50aWZpZXJcbiAgdGhpcy5pbmRleCA9IGNhbGxiYWNrcy5sZW5ndGg7XG5cbiAgLy8gYWRkIGNhbGxiYWNrIHRvIGpzb25wIGdsb2JhbFxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uIChtc2cpIHtcbiAgICBzZWxmLm9uRGF0YShtc2cpO1xuICB9KTtcblxuICAvLyBhcHBlbmQgdG8gcXVlcnkgc3RyaW5nXG4gIHRoaXMucXVlcnkuaiA9IHRoaXMuaW5kZXg7XG5cbiAgLy8gcHJldmVudCBzcHVyaW91cyBlcnJvcnMgZnJvbSBiZWluZyBlbWl0dGVkIHdoZW4gdGhlIHdpbmRvdyBpcyB1bmxvYWRlZFxuICBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLnNjcmlwdCkgc2VsZi5zY3JpcHQub25lcnJvciA9IGVtcHR5O1xuICAgIH0sIGZhbHNlKTtcbiAgfVxufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cbiAqL1xuXG5pbmhlcml0KEpTT05QUG9sbGluZywgUG9sbGluZyk7XG5cbi8qXG4gKiBKU09OUCBvbmx5IHN1cHBvcnRzIGJpbmFyeSBhcyBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuXG4vKipcbiAqIENsb3NlcyB0aGUgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICB9XG5cbiAgaWYgKHRoaXMuZm9ybSkge1xuICAgIHRoaXMuZm9ybS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZm9ybSk7XG4gICAgdGhpcy5mb3JtID0gbnVsbDtcbiAgICB0aGlzLmlmcmFtZSA9IG51bGw7XG4gIH1cblxuICBQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuXG4gIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gIHNjcmlwdC5zcmMgPSB0aGlzLnVyaSgpO1xuICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgc2VsZi5vbkVycm9yKCdqc29ucCBwb2xsIGVycm9yJywgZSk7XG4gIH07XG5cbiAgdmFyIGluc2VydEF0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdO1xuICBpZiAoaW5zZXJ0QXQpIHtcbiAgICBpbnNlcnRBdC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzY3JpcHQsIGluc2VydEF0KTtcbiAgfSBlbHNlIHtcbiAgICAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5ib2R5KS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICB9XG4gIHRoaXMuc2NyaXB0ID0gc2NyaXB0O1xuXG4gIHZhciBpc1VBZ2Vja28gPSAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG5hdmlnYXRvciAmJiAvZ2Vja28vaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4gIGlmIChpc1VBZ2Vja28pIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICB9LCAxMDApO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlcyB3aXRoIGEgaGlkZGVuIGlmcmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0byBzZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9Xcml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBmbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKCF0aGlzLmZvcm0pIHtcbiAgICB2YXIgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcbiAgICB2YXIgYXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgdmFyIGlkID0gdGhpcy5pZnJhbWVJZCA9ICdlaW9faWZyYW1lXycgKyB0aGlzLmluZGV4O1xuICAgIHZhciBpZnJhbWU7XG5cbiAgICBmb3JtLmNsYXNzTmFtZSA9ICdzb2NrZXRpbyc7XG4gICAgZm9ybS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZm9ybS5zdHlsZS50b3AgPSAnLTEwMDBweCc7XG4gICAgZm9ybS5zdHlsZS5sZWZ0ID0gJy0xMDAwcHgnO1xuICAgIGZvcm0udGFyZ2V0ID0gaWQ7XG4gICAgZm9ybS5tZXRob2QgPSAnUE9TVCc7XG4gICAgZm9ybS5zZXRBdHRyaWJ1dGUoJ2FjY2VwdC1jaGFyc2V0JywgJ3V0Zi04Jyk7XG4gICAgYXJlYS5uYW1lID0gJ2QnO1xuICAgIGZvcm0uYXBwZW5kQ2hpbGQoYXJlYSk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcblxuICAgIHRoaXMuZm9ybSA9IGZvcm07XG4gICAgdGhpcy5hcmVhID0gYXJlYTtcbiAgfVxuXG4gIHRoaXMuZm9ybS5hY3Rpb24gPSB0aGlzLnVyaSgpO1xuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlICgpIHtcbiAgICBpbml0SWZyYW1lKCk7XG4gICAgZm4oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRJZnJhbWUgKCkge1xuICAgIGlmIChzZWxmLmlmcmFtZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2VsZi5mb3JtLnJlbW92ZUNoaWxkKHNlbGYuaWZyYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2VsZi5vbkVycm9yKCdqc29ucCBwb2xsaW5nIGlmcmFtZSByZW1vdmFsIGVycm9yJywgZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIGllNiBkeW5hbWljIGlmcmFtZXMgd2l0aCB0YXJnZXQ9XCJcIiBzdXBwb3J0ICh0aGFua3MgQ2hyaXMgTGFtYmFjaGVyKVxuICAgICAgdmFyIGh0bWwgPSAnPGlmcmFtZSBzcmM9XCJqYXZhc2NyaXB0OjBcIiBuYW1lPVwiJyArIHNlbGYuaWZyYW1lSWQgKyAnXCI+JztcbiAgICAgIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaHRtbCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBpZnJhbWUubmFtZSA9IHNlbGYuaWZyYW1lSWQ7XG4gICAgICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6MCc7XG4gICAgfVxuXG4gICAgaWZyYW1lLmlkID0gc2VsZi5pZnJhbWVJZDtcblxuICAgIHNlbGYuZm9ybS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIHNlbGYuaWZyYW1lID0gaWZyYW1lO1xuICB9XG5cbiAgaW5pdElmcmFtZSgpO1xuXG4gIC8vIGVzY2FwZSBcXG4gdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIGNvbnZlcnRlZCBpbnRvIFxcclxcbiBieSBzb21lIFVBc1xuICAvLyBkb3VibGUgZXNjYXBpbmcgaXMgcmVxdWlyZWQgZm9yIGVzY2FwZWQgbmV3IGxpbmVzIGJlY2F1c2UgdW5lc2NhcGluZyBvZiBuZXcgbGluZXMgY2FuIGJlIGRvbmUgc2FmZWx5IG9uIHNlcnZlci1zaWRlXG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UockVzY2FwZWROZXdsaW5lLCAnXFxcXFxcbicpO1xuICB0aGlzLmFyZWEudmFsdWUgPSBkYXRhLnJlcGxhY2Uock5ld2xpbmUsICdcXFxcbicpO1xuXG4gIHRyeSB7XG4gICAgdGhpcy5mb3JtLnN1Ym1pdCgpO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIGlmICh0aGlzLmlmcmFtZS5hdHRhY2hFdmVudCkge1xuICAgIHRoaXMuaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLmlmcmFtZS5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlmcmFtZS5vbmxvYWQgPSBjb21wbGV0ZTtcbiAgfVxufTtcbiIsIi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbnZhciBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcteGhyJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBYSFI7XG5tb2R1bGUuZXhwb3J0cy5SZXF1ZXN0ID0gUmVxdWVzdDtcblxuLyoqXG4gKiBFbXB0eSBmdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIGVtcHR5ICgpIHt9XG5cbi8qKlxuICogWEhSIFBvbGxpbmcgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gWEhSIChvcHRzKSB7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcbiAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IG9wdHMucmVxdWVzdFRpbWVvdXQ7XG4gIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG5cbiAgaWYgKGdsb2JhbC5sb2NhdGlvbikge1xuICAgIHZhciBpc1NTTCA9ICdodHRwczonID09PSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICB2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7XG5cbiAgICAvLyBzb21lIHVzZXIgYWdlbnRzIGhhdmUgZW1wdHkgYGxvY2F0aW9uLnBvcnRgXG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcbiAgICB9XG5cbiAgICB0aGlzLnhkID0gb3B0cy5ob3N0bmFtZSAhPT0gZ2xvYmFsLmxvY2F0aW9uLmhvc3RuYW1lIHx8XG4gICAgICBwb3J0ICE9PSBvcHRzLnBvcnQ7XG4gICAgdGhpcy54cyA9IG9wdHMuc2VjdXJlICE9PSBpc1NTTDtcbiAgfVxufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cbiAqL1xuXG5pbmhlcml0KFhIUiwgUG9sbGluZyk7XG5cbi8qKlxuICogWEhSIHN1cHBvcnRzIGJpbmFyeVxuICovXG5cblhIUi5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBvcHRzLnVyaSA9IHRoaXMudXJpKCk7XG4gIG9wdHMueGQgPSB0aGlzLnhkO1xuICBvcHRzLnhzID0gdGhpcy54cztcbiAgb3B0cy5hZ2VudCA9IHRoaXMuYWdlbnQgfHwgZmFsc2U7XG4gIG9wdHMuc3VwcG9ydHNCaW5hcnkgPSB0aGlzLnN1cHBvcnRzQmluYXJ5O1xuICBvcHRzLmVuYWJsZXNYRFIgPSB0aGlzLmVuYWJsZXNYRFI7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuICBvcHRzLnJlcXVlc3RUaW1lb3V0ID0gdGhpcy5yZXF1ZXN0VGltZW91dDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLmV4dHJhSGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuXG4gIHJldHVybiBuZXcgUmVxdWVzdChvcHRzKTtcbn07XG5cbi8qKlxuICogU2VuZHMgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0byBzZW5kLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLmRvV3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZm4pIHtcbiAgdmFyIGlzQmluYXJ5ID0gdHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnICYmIGRhdGEgIT09IHVuZGVmaW5lZDtcbiAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCh7IG1ldGhvZDogJ1BPU1QnLCBkYXRhOiBkYXRhLCBpc0JpbmFyeTogaXNCaW5hcnkgfSk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmVxLm9uKCdzdWNjZXNzJywgZm4pO1xuICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYub25FcnJvcigneGhyIHBvc3QgZXJyb3InLCBlcnIpO1xuICB9KTtcbiAgdGhpcy5zZW5kWGhyID0gcmVxO1xufTtcblxuLyoqXG4gKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygneGhyIHBvbGwnKTtcbiAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCgpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJlcS5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgc2VsZi5vbkRhdGEoZGF0YSk7XG4gIH0pO1xuICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYub25FcnJvcigneGhyIHBvbGwgZXJyb3InLCBlcnIpO1xuICB9KTtcbiAgdGhpcy5wb2xsWGhyID0gcmVxO1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0IGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdCAob3B0cykge1xuICB0aGlzLm1ldGhvZCA9IG9wdHMubWV0aG9kIHx8ICdHRVQnO1xuICB0aGlzLnVyaSA9IG9wdHMudXJpO1xuICB0aGlzLnhkID0gISFvcHRzLnhkO1xuICB0aGlzLnhzID0gISFvcHRzLnhzO1xuICB0aGlzLmFzeW5jID0gZmFsc2UgIT09IG9wdHMuYXN5bmM7XG4gIHRoaXMuZGF0YSA9IHVuZGVmaW5lZCAhPT0gb3B0cy5kYXRhID8gb3B0cy5kYXRhIDogbnVsbDtcbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQ7XG4gIHRoaXMuaXNCaW5hcnkgPSBvcHRzLmlzQmluYXJ5O1xuICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gb3B0cy5zdXBwb3J0c0JpbmFyeTtcbiAgdGhpcy5lbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gb3B0cy5yZXF1ZXN0VGltZW91dDtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5wZnggPSBvcHRzLnBmeDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleTtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlO1xuICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQ7XG4gIHRoaXMuY2EgPSBvcHRzLmNhO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnM7XG4gIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcblxuICB0aGlzLmNyZWF0ZSgpO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihSZXF1ZXN0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgWEhSIG9iamVjdCBhbmQgc2VuZHMgdGhlIHJlcXVlc3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3B0cyA9IHsgYWdlbnQ6IHRoaXMuYWdlbnQsIHhkb21haW46IHRoaXMueGQsIHhzY2hlbWU6IHRoaXMueHMsIGVuYWJsZXNYRFI6IHRoaXMuZW5hYmxlc1hEUiB9O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICB2YXIgeGhyID0gdGhpcy54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0cnkge1xuICAgIGRlYnVnKCd4aHIgb3BlbiAlczogJXMnLCB0aGlzLm1ldGhvZCwgdGhpcy51cmkpO1xuICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVyaSwgdGhpcy5hc3luYyk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLmV4dHJhSGVhZGVycykge1xuICAgICAgICB4aHIuc2V0RGlzYWJsZUhlYWRlckNoZWNrICYmIHhoci5zZXREaXNhYmxlSGVhZGVyQ2hlY2sodHJ1ZSk7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5leHRyYUhlYWRlcnMpIHtcbiAgICAgICAgICBpZiAodGhpcy5leHRyYUhlYWRlcnMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGksIHRoaXMuZXh0cmFIZWFkZXJzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgaWYgKCdQT1NUJyA9PT0gdGhpcy5tZXRob2QpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLmlzQmluYXJ5KSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJyovKicpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAvLyBpZTYgY2hlY2tcbiAgICBpZiAoJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKSB7XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZXF1ZXN0VGltZW91dCkge1xuICAgICAgeGhyLnRpbWVvdXQgPSB0aGlzLnJlcXVlc3RUaW1lb3V0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc1hEUigpKSB7XG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgfTtcbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLm9uRXJyb3IoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKTtcbiAgICAgICAgICAgIGlmIChzZWxmLnN1cHBvcnRzQmluYXJ5ICYmIGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJykge1xuICAgICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG4gICAgICAgIGlmICg0ICE9PSB4aHIucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgICAgICBpZiAoMjAwID09PSB4aHIuc3RhdHVzIHx8IDEyMjMgPT09IHhoci5zdGF0dXMpIHtcbiAgICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgYGVycm9yYCBldmVudCBoYW5kbGVyIHRoYXQncyB1c2VyLXNldFxuICAgICAgICAgIC8vIGRvZXMgbm90IHRocm93IGluIHRoZSBzYW1lIHRpY2sgYW5kIGdldHMgY2F1Z2h0IGhlcmVcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYub25FcnJvcih4aHIuc3RhdHVzKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBkZWJ1ZygneGhyIGRhdGEgJXMnLCB0aGlzLmRhdGEpO1xuICAgIHhoci5zZW5kKHRoaXMuZGF0YSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBOZWVkIHRvIGRlZmVyIHNpbmNlIC5jcmVhdGUoKSBpcyBjYWxsZWQgZGlyZWN0bHkgZmhyb20gdGhlIGNvbnN0cnVjdG9yXG4gICAgLy8gYW5kIHRodXMgdGhlICdlcnJvcicgZXZlbnQgY2FuIG9ubHkgYmUgb25seSBib3VuZCAqYWZ0ZXIqIHRoaXMgZXhjZXB0aW9uXG4gICAgLy8gb2NjdXJzLiAgVGhlcmVmb3JlLCBhbHNvLCB3ZSBjYW5ub3QgdGhyb3cgaGVyZSBhdCBhbGwuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLm9uRXJyb3IoZSk7XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAgIHRoaXMuaW5kZXggPSBSZXF1ZXN0LnJlcXVlc3RzQ291bnQrKztcbiAgICBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdID0gdGhpcztcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uU3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdzdWNjZXNzJyk7XG4gIHRoaXMuY2xlYW51cCgpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgaWYgd2UgaGF2ZSBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZW1pdCgnZGF0YScsIGRhdGEpO1xuICB0aGlzLm9uU3VjY2VzcygpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5jbGVhbnVwKHRydWUpO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgaG91c2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uIChmcm9tRXJyb3IpIHtcbiAgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2YgdGhpcy54aHIgfHwgbnVsbCA9PT0gdGhpcy54aHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8geG1saHR0cHJlcXVlc3RcbiAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICB0aGlzLnhoci5vbmxvYWQgPSB0aGlzLnhoci5vbmVycm9yID0gZW1wdHk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZW1wdHk7XG4gIH1cblxuICBpZiAoZnJvbUVycm9yKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuXG4gIGlmIChnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICBkZWxldGUgUmVxdWVzdC5yZXF1ZXN0c1t0aGlzLmluZGV4XTtcbiAgfVxuXG4gIHRoaXMueGhyID0gbnVsbDtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gbG9hZC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkYXRhO1xuICB0cnkge1xuICAgIHZhciBjb250ZW50VHlwZTtcbiAgICB0cnkge1xuICAgICAgY29udGVudFR5cGUgPSB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICBpZiAoY29udGVudFR5cGUgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKSB7XG4gICAgICBkYXRhID0gdGhpcy54aHIucmVzcG9uc2UgfHwgdGhpcy54aHIucmVzcG9uc2VUZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gdGhpcy54aHIucmVzcG9uc2VUZXh0O1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMub25FcnJvcihlKTtcbiAgfVxuICBpZiAobnVsbCAhPSBkYXRhKSB7XG4gICAgdGhpcy5vbkRhdGEoZGF0YSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgaXQgaGFzIFhEb21haW5SZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmhhc1hEUiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICd1bmRlZmluZWQnICE9PSB0eXBlb2YgZ2xvYmFsLlhEb21haW5SZXF1ZXN0ICYmICF0aGlzLnhzICYmIHRoaXMuZW5hYmxlc1hEUjtcbn07XG5cbi8qKlxuICogQWJvcnRzIHRoZSByZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY2xlYW51cCgpO1xufTtcblxuLyoqXG4gKiBBYm9ydHMgcGVuZGluZyByZXF1ZXN0cyB3aGVuIHVubG9hZGluZyB0aGUgd2luZG93LiBUaGlzIGlzIG5lZWRlZCB0byBwcmV2ZW50XG4gKiBtZW1vcnkgbGVha3MgKGUuZy4gd2hlbiB1c2luZyBJRSkgYW5kIHRvIGVuc3VyZSB0aGF0IG5vIHNwdXJpb3VzIGVycm9yIGlzXG4gKiBlbWl0dGVkLlxuICovXG5cblJlcXVlc3QucmVxdWVzdHNDb3VudCA9IDA7XG5SZXF1ZXN0LnJlcXVlc3RzID0ge307XG5cbmlmIChnbG9iYWwuZG9jdW1lbnQpIHtcbiAgaWYgKGdsb2JhbC5hdHRhY2hFdmVudCkge1xuICAgIGdsb2JhbC5hdHRhY2hFdmVudCgnb251bmxvYWQnLCB1bmxvYWRIYW5kbGVyKTtcbiAgfSBlbHNlIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5sb2FkSGFuZGxlciAoKSB7XG4gIGZvciAodmFyIGkgaW4gUmVxdWVzdC5yZXF1ZXN0cykge1xuICAgIGlmIChSZXF1ZXN0LnJlcXVlc3RzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBSZXF1ZXN0LnJlcXVlc3RzW2ldLmFib3J0KCk7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydCcpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIHllYXN0ID0gcmVxdWlyZSgneWVhc3QnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6cG9sbGluZycpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUG9sbGluZztcblxuLyoqXG4gKiBJcyBYSFIyIHN1cHBvcnRlZD9cbiAqL1xuXG52YXIgaGFzWEhSMiA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0LXNzbCcpO1xuICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KHsgeGRvbWFpbjogZmFsc2UgfSk7XG4gIHJldHVybiBudWxsICE9IHhoci5yZXNwb25zZVR5cGU7XG59KSgpO1xuXG4vKipcbiAqIFBvbGxpbmcgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBQb2xsaW5nIChvcHRzKSB7XG4gIHZhciBmb3JjZUJhc2U2NCA9IChvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQpO1xuICBpZiAoIWhhc1hIUjIgfHwgZm9yY2VCYXNlNjQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cbiAgVHJhbnNwb3J0LmNhbGwodGhpcywgb3B0cyk7XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBUcmFuc3BvcnQuXG4gKi9cblxuaW5oZXJpdChQb2xsaW5nLCBUcmFuc3BvcnQpO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBuYW1lLlxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLm5hbWUgPSAncG9sbGluZyc7XG5cbi8qKlxuICogT3BlbnMgdGhlIHNvY2tldCAodHJpZ2dlcnMgcG9sbGluZykuIFdlIHdyaXRlIGEgUElORyBtZXNzYWdlIHRvIGRldGVybWluZVxuICogd2hlbiB0aGUgdHJhbnNwb3J0IGlzIG9wZW4uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnBvbGwoKTtcbn07XG5cbi8qKlxuICogUGF1c2VzIHBvbGxpbmcuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdXBvbiBidWZmZXJzIGFyZSBmbHVzaGVkIGFuZCB0cmFuc3BvcnQgaXMgcGF1c2VkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIChvblBhdXNlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLnJlYWR5U3RhdGUgPSAncGF1c2luZyc7XG5cbiAgZnVuY3Rpb24gcGF1c2UgKCkge1xuICAgIGRlYnVnKCdwYXVzZWQnKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAncGF1c2VkJztcbiAgICBvblBhdXNlKCk7XG4gIH1cblxuICBpZiAodGhpcy5wb2xsaW5nIHx8ICF0aGlzLndyaXRhYmxlKSB7XG4gICAgdmFyIHRvdGFsID0gMDtcblxuICAgIGlmICh0aGlzLnBvbGxpbmcpIHtcbiAgICAgIGRlYnVnKCd3ZSBhcmUgY3VycmVudGx5IHBvbGxpbmcgLSB3YWl0aW5nIHRvIHBhdXNlJyk7XG4gICAgICB0b3RhbCsrO1xuICAgICAgdGhpcy5vbmNlKCdwb2xsQ29tcGxldGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlYnVnKCdwcmUtcGF1c2UgcG9sbGluZyBjb21wbGV0ZScpO1xuICAgICAgICAtLXRvdGFsIHx8IHBhdXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMud3JpdGFibGUpIHtcbiAgICAgIGRlYnVnKCd3ZSBhcmUgY3VycmVudGx5IHdyaXRpbmcgLSB3YWl0aW5nIHRvIHBhdXNlJyk7XG4gICAgICB0b3RhbCsrO1xuICAgICAgdGhpcy5vbmNlKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVidWcoJ3ByZS1wYXVzZSB3cml0aW5nIGNvbXBsZXRlJyk7XG4gICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwYXVzZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBwb2xsaW5nIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUucG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3BvbGxpbmcnKTtcbiAgdGhpcy5wb2xsaW5nID0gdHJ1ZTtcbiAgdGhpcy5kb1BvbGwoKTtcbiAgdGhpcy5lbWl0KCdwb2xsJyk7XG59O1xuXG4vKipcbiAqIE92ZXJsb2FkcyBvbkRhdGEgdG8gZGV0ZWN0IHBheWxvYWRzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZGVidWcoJ3BvbGxpbmcgZ290IGRhdGEgJXMnLCBkYXRhKTtcbiAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKHBhY2tldCwgaW5kZXgsIHRvdGFsKSB7XG4gICAgLy8gaWYgaXRzIHRoZSBmaXJzdCBtZXNzYWdlIHdlIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgb3BlblxuICAgIGlmICgnb3BlbmluZycgPT09IHNlbGYucmVhZHlTdGF0ZSkge1xuICAgICAgc2VsZi5vbk9wZW4oKTtcbiAgICB9XG5cbiAgICAvLyBpZiBpdHMgYSBjbG9zZSBwYWNrZXQsIHdlIGNsb3NlIHRoZSBvbmdvaW5nIHJlcXVlc3RzXG4gICAgaWYgKCdjbG9zZScgPT09IHBhY2tldC50eXBlKSB7XG4gICAgICBzZWxmLm9uQ2xvc2UoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UgYnlwYXNzIG9uRGF0YSBhbmQgaGFuZGxlIHRoZSBtZXNzYWdlXG4gICAgc2VsZi5vblBhY2tldChwYWNrZXQpO1xuICB9O1xuXG4gIC8vIGRlY29kZSBwYXlsb2FkXG4gIHBhcnNlci5kZWNvZGVQYXlsb2FkKGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUsIGNhbGxiYWNrKTtcblxuICAvLyBpZiBhbiBldmVudCBkaWQgbm90IHRyaWdnZXIgY2xvc2luZ1xuICBpZiAoJ2Nsb3NlZCcgIT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIC8vIGlmIHdlIGdvdCBkYXRhIHdlJ3JlIG5vdCBwb2xsaW5nXG4gICAgdGhpcy5wb2xsaW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwb2xsQ29tcGxldGUnKTtcblxuICAgIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgdGhpcy5wb2xsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdpZ25vcmluZyBwb2xsIC0gdHJhbnNwb3J0IHN0YXRlIFwiJXNcIicsIHRoaXMucmVhZHlTdGF0ZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEZvciBwb2xsaW5nLCBzZW5kIGEgY2xvc2UgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmdW5jdGlvbiBjbG9zZSAoKSB7XG4gICAgZGVidWcoJ3dyaXRpbmcgY2xvc2UgcGFja2V0Jyk7XG4gICAgc2VsZi53cml0ZShbeyB0eXBlOiAnY2xvc2UnIH1dKTtcbiAgfVxuXG4gIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCd0cmFuc3BvcnQgb3BlbiAtIGNsb3NpbmcnKTtcbiAgICBjbG9zZSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIGluIGNhc2Ugd2UncmUgdHJ5aW5nIHRvIGNsb3NlIHdoaWxlXG4gICAgLy8gaGFuZHNoYWtpbmcgaXMgaW4gcHJvZ3Jlc3MgKEdILTE2NClcbiAgICBkZWJ1ZygndHJhbnNwb3J0IG5vdCBvcGVuIC0gZGVmZXJyaW5nIGNsb3NlJyk7XG4gICAgdGhpcy5vbmNlKCdvcGVuJywgY2xvc2UpO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHBhY2tldHMgcGF5bG9hZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhIHBhY2tldHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRyYWluIGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChwYWNrZXRzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICB2YXIgY2FsbGJhY2tmbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG4gIH07XG5cbiAgcGFyc2VyLmVuY29kZVBheWxvYWQocGFja2V0cywgdGhpcy5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBzZWxmLmRvV3JpdGUoZGF0YSwgY2FsbGJhY2tmbik7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgdXJpIGZvciBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnVyaSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ2h0dHBzJyA6ICdodHRwJztcbiAgdmFyIHBvcnQgPSAnJztcblxuICAvLyBjYWNoZSBidXN0aW5nIGlzIGZvcmNlZFxuICBpZiAoZmFsc2UgIT09IHRoaXMudGltZXN0YW1wUmVxdWVzdHMpIHtcbiAgICBxdWVyeVt0aGlzLnRpbWVzdGFtcFBhcmFtXSA9IHllYXN0KCk7XG4gIH1cblxuICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkgJiYgIXF1ZXJ5LnNpZCkge1xuICAgIHF1ZXJ5LmI2NCA9IDE7XG4gIH1cblxuICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblxuICAvLyBhdm9pZCBwb3J0IGlmIGRlZmF1bHQgZm9yIHNjaGVtYVxuICBpZiAodGhpcy5wb3J0ICYmICgoJ2h0dHBzJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA0NDMpIHx8XG4gICAgICgnaHR0cCcgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5wb3J0KSAhPT0gODApKSkge1xuICAgIHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG4gIH1cblxuICAvLyBwcmVwZW5kID8gdG8gcXVlcnlcbiAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gJz8nICsgcXVlcnk7XG4gIH1cblxuICB2YXIgaXB2NiA9IHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMTtcbiAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgKGlwdjYgPyAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nIDogdGhpcy5ob3N0bmFtZSkgKyBwb3J0ICsgdGhpcy5wYXRoICsgcXVlcnk7XG59O1xuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi90cmFuc3BvcnQnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciB5ZWFzdCA9IHJlcXVpcmUoJ3llYXN0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OndlYnNvY2tldCcpO1xudmFyIEJyb3dzZXJXZWJTb2NrZXQgPSBnbG9iYWwuV2ViU29ja2V0IHx8IGdsb2JhbC5Nb3pXZWJTb2NrZXQ7XG52YXIgTm9kZVdlYlNvY2tldDtcbmlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICB0cnkge1xuICAgIE5vZGVXZWJTb2NrZXQgPSByZXF1aXJlKCd3cycpO1xuICB9IGNhdGNoIChlKSB7IH1cbn1cblxuLyoqXG4gKiBHZXQgZWl0aGVyIHRoZSBgV2ViU29ja2V0YCBvciBgTW96V2ViU29ja2V0YCBnbG9iYWxzXG4gKiBpbiB0aGUgYnJvd3NlciBvciB0cnkgdG8gcmVzb2x2ZSBXZWJTb2NrZXQtY29tcGF0aWJsZVxuICogaW50ZXJmYWNlIGV4cG9zZWQgYnkgYHdzYCBmb3IgTm9kZS1saWtlIGVudmlyb25tZW50LlxuICovXG5cbnZhciBXZWJTb2NrZXQgPSBCcm93c2VyV2ViU29ja2V0O1xuaWYgKCFXZWJTb2NrZXQgJiYgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgV2ViU29ja2V0ID0gTm9kZVdlYlNvY2tldDtcbn1cblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdTO1xuXG4vKipcbiAqIFdlYlNvY2tldCB0cmFuc3BvcnQgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSB7T2JqZWN0fSBjb25uZWN0aW9uIG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gV1MgKG9wdHMpIHtcbiAgdmFyIGZvcmNlQmFzZTY0ID0gKG9wdHMgJiYgb3B0cy5mb3JjZUJhc2U2NCk7XG4gIGlmIChmb3JjZUJhc2U2NCkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0gb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZTtcbiAgdGhpcy51c2luZ0Jyb3dzZXJXZWJTb2NrZXQgPSBCcm93c2VyV2ViU29ja2V0ICYmICFvcHRzLmZvcmNlTm9kZTtcbiAgdGhpcy5wcm90b2NvbHMgPSBvcHRzLnByb3RvY29scztcbiAgaWYgKCF0aGlzLnVzaW5nQnJvd3NlcldlYlNvY2tldCkge1xuICAgIFdlYlNvY2tldCA9IE5vZGVXZWJTb2NrZXQ7XG4gIH1cbiAgVHJhbnNwb3J0LmNhbGwodGhpcywgb3B0cyk7XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBUcmFuc3BvcnQuXG4gKi9cblxuaW5oZXJpdChXUywgVHJhbnNwb3J0KTtcblxuLyoqXG4gKiBUcmFuc3BvcnQgbmFtZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbldTLnByb3RvdHlwZS5uYW1lID0gJ3dlYnNvY2tldCc7XG5cbi8qXG4gKiBXZWJTb2NrZXRzIHN1cHBvcnQgYmluYXJ5XG4gKi9cblxuV1MucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcblxuLyoqXG4gKiBPcGVucyBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmNoZWNrKCkpIHtcbiAgICAvLyBsZXQgcHJvYmUgdGltZW91dFxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB1cmkgPSB0aGlzLnVyaSgpO1xuICB2YXIgcHJvdG9jb2xzID0gdGhpcy5wcm90b2NvbHM7XG4gIHZhciBvcHRzID0ge1xuICAgIGFnZW50OiB0aGlzLmFnZW50LFxuICAgIHBlck1lc3NhZ2VEZWZsYXRlOiB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlXG4gIH07XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuICBpZiAodGhpcy5leHRyYUhlYWRlcnMpIHtcbiAgICBvcHRzLmhlYWRlcnMgPSB0aGlzLmV4dHJhSGVhZGVycztcbiAgfVxuICBpZiAodGhpcy5sb2NhbEFkZHJlc3MpIHtcbiAgICBvcHRzLmxvY2FsQWRkcmVzcyA9IHRoaXMubG9jYWxBZGRyZXNzO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB0aGlzLndzID0gdGhpcy51c2luZ0Jyb3dzZXJXZWJTb2NrZXQgPyAocHJvdG9jb2xzID8gbmV3IFdlYlNvY2tldCh1cmksIHByb3RvY29scykgOiBuZXcgV2ViU29ja2V0KHVyaSkpIDogbmV3IFdlYlNvY2tldCh1cmksIHByb3RvY29scywgb3B0cyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfVxuXG4gIGlmICh0aGlzLndzLmJpbmFyeVR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLndzLnN1cHBvcnRzICYmIHRoaXMud3Muc3VwcG9ydHMuYmluYXJ5KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG4gICAgdGhpcy53cy5iaW5hcnlUeXBlID0gJ25vZGVidWZmZXInO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gIH1cblxuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG59O1xuXG4vKipcbiAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBzb2NrZXRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLndzLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLm9uT3BlbigpO1xuICB9O1xuICB0aGlzLndzLm9uY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbkNsb3NlKCk7XG4gIH07XG4gIHRoaXMud3Mub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgc2VsZi5vbkRhdGEoZXYuZGF0YSk7XG4gIH07XG4gIHRoaXMud3Mub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgc2VsZi5vbkVycm9yKCd3ZWJzb2NrZXQgZXJyb3InLCBlKTtcbiAgfTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGRhdGEgdG8gc29ja2V0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IG9mIHBhY2tldHMuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAocGFja2V0cykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICAvLyBlbmNvZGVQYWNrZXQgZWZmaWNpZW50IGFzIGl0IHVzZXMgV1MgZnJhbWluZ1xuICAvLyBubyBuZWVkIGZvciBlbmNvZGVQYXlsb2FkXG4gIHZhciB0b3RhbCA9IHBhY2tldHMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHRvdGFsOyBpIDwgbDsgaSsrKSB7XG4gICAgKGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgICAgIHBhcnNlci5lbmNvZGVQYWNrZXQocGFja2V0LCBzZWxmLnN1cHBvcnRzQmluYXJ5LCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoIXNlbGYudXNpbmdCcm93c2VyV2ViU29ja2V0KSB7XG4gICAgICAgICAgLy8gYWx3YXlzIGNyZWF0ZSBhIG5ldyBvYmplY3QgKEdILTQzNylcbiAgICAgICAgICB2YXIgb3B0cyA9IHt9O1xuICAgICAgICAgIGlmIChwYWNrZXQub3B0aW9ucykge1xuICAgICAgICAgICAgb3B0cy5jb21wcmVzcyA9IHBhY2tldC5vcHRpb25zLmNvbXByZXNzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWxmLnBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gJ3N0cmluZycgPT09IHR5cGVvZiBkYXRhID8gZ2xvYmFsLkJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpIDogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVuIDwgc2VsZi5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgb3B0cy5jb21wcmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNvbWV0aW1lcyB0aGUgd2Vic29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkIGJ1dCB0aGUgYnJvd3NlciBkaWRuJ3RcbiAgICAgICAgLy8gaGF2ZSBhIGNoYW5jZSBvZiBpbmZvcm1pbmcgdXMgYWJvdXQgaXQgeWV0LCBpbiB0aGF0IGNhc2Ugc2VuZCB3aWxsXG4gICAgICAgIC8vIHRocm93IGFuIGVycm9yXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHNlbGYudXNpbmdCcm93c2VyV2ViU29ja2V0KSB7XG4gICAgICAgICAgICAvLyBUeXBlRXJyb3IgaXMgdGhyb3duIHdoZW4gcGFzc2luZyB0aGUgc2Vjb25kIGFyZ3VtZW50IG9uIFNhZmFyaVxuICAgICAgICAgICAgc2VsZi53cy5zZW5kKGRhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLndzLnNlbmQoZGF0YSwgb3B0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcoJ3dlYnNvY2tldCBjbG9zZWQgYmVmb3JlIG9uY2xvc2UgZXZlbnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC0tdG90YWwgfHwgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfSkocGFja2V0c1tpXSk7XG4gIH1cblxuICBmdW5jdGlvbiBkb25lICgpIHtcbiAgICBzZWxmLmVtaXQoJ2ZsdXNoJyk7XG5cbiAgICAvLyBmYWtlIGRyYWluXG4gICAgLy8gZGVmZXIgdG8gbmV4dCB0aWNrIHRvIGFsbG93IFNvY2tldCB0byBjbGVhciB3cml0ZUJ1ZmZlclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi53cml0YWJsZSA9IHRydWU7XG4gICAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG4gICAgfSwgMCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gY2xvc2VcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIENsb3NlcyBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgdGhpcy53cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLndzLmNsb3NlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuICB2YXIgc2NoZW1hID0gdGhpcy5zZWN1cmUgPyAnd3NzJyA6ICd3cyc7XG4gIHZhciBwb3J0ID0gJyc7XG5cbiAgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcbiAgaWYgKHRoaXMucG9ydCAmJiAoKCd3c3MnID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMucG9ydCkgIT09IDQ0MykgfHxcbiAgICAoJ3dzJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA4MCkpKSB7XG4gICAgcG9ydCA9ICc6JyArIHRoaXMucG9ydDtcbiAgfVxuXG4gIC8vIGFwcGVuZCB0aW1lc3RhbXAgdG8gVVJJXG4gIGlmICh0aGlzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG4gICAgcXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuICB9XG5cbiAgLy8gY29tbXVuaWNhdGUgYmluYXJ5IHN1cHBvcnQgY2FwYWJpbGl0aWVzXG4gIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuICAgIHF1ZXJ5LmI2NCA9IDE7XG4gIH1cblxuICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblxuICAvLyBwcmVwZW5kID8gdG8gcXVlcnlcbiAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gJz8nICsgcXVlcnk7XG4gIH1cblxuICB2YXIgaXB2NiA9IHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMTtcbiAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgKGlwdjYgPyAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nIDogdGhpcy5ob3N0bmFtZSkgKyBwb3J0ICsgdGhpcy5wYXRoICsgcXVlcnk7XG59O1xuXG4vKipcbiAqIEZlYXR1cmUgZGV0ZWN0aW9uIGZvciBXZWJTb2NrZXQuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciB0aGlzIHRyYW5zcG9ydCBpcyBhdmFpbGFibGUuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbldTLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICEhV2ViU29ja2V0ICYmICEoJ19faW5pdGlhbGl6ZScgaW4gV2ViU29ja2V0ICYmIHRoaXMubmFtZSA9PT0gV1MucHJvdG90eXBlLm5hbWUpO1xufTtcbiIsIi8vIGJyb3dzZXIgc2hpbSBmb3IgeG1saHR0cHJlcXVlc3QgbW9kdWxlXG5cbnZhciBoYXNDT1JTID0gcmVxdWlyZSgnaGFzLWNvcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgeGRvbWFpbiA9IG9wdHMueGRvbWFpbjtcblxuICAvLyBzY2hlbWUgbXVzdCBiZSBzYW1lIHdoZW4gdXNpZ24gWERvbWFpblJlcXVlc3RcbiAgLy8gaHR0cDovL2Jsb2dzLm1zZG4uY29tL2IvaWVpbnRlcm5hbHMvYXJjaGl2ZS8yMDEwLzA1LzEzL3hkb21haW5yZXF1ZXN0LXJlc3RyaWN0aW9ucy1saW1pdGF0aW9ucy1hbmQtd29ya2Fyb3VuZHMuYXNweFxuICB2YXIgeHNjaGVtZSA9IG9wdHMueHNjaGVtZTtcblxuICAvLyBYRG9tYWluUmVxdWVzdCBoYXMgYSBmbG93IG9mIG5vdCBzZW5kaW5nIGNvb2tpZSwgdGhlcmVmb3JlIGl0IHNob3VsZCBiZSBkaXNhYmxlZCBhcyBhIGRlZmF1bHQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL2VuZ2luZS5pby1jbGllbnQvcHVsbC8yMTdcbiAgdmFyIGVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gWE1MSHR0cFJlcXVlc3QgY2FuIGJlIGRpc2FibGVkIG9uIElFXG4gIHRyeSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgJiYgKCF4ZG9tYWluIHx8IGhhc0NPUlMpKSB7XG4gICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7IH1cblxuICAvLyBVc2UgWERvbWFpblJlcXVlc3QgZm9yIElFOCBpZiBlbmFibGVzWERSIGlzIHRydWVcbiAgLy8gYmVjYXVzZSBsb2FkaW5nIGJhciBrZWVwcyBmbGFzaGluZyB3aGVuIHVzaW5nIGpzb25wLXBvbGxpbmdcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3l1amlvc2FrYS9zb2NrZS5pby1pZTgtbG9hZGluZy1leGFtcGxlXG4gIHRyeSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgWERvbWFpblJlcXVlc3QgJiYgIXhzY2hlbWUgJiYgZW5hYmxlc1hEUikge1xuICAgICAgcmV0dXJuIG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgaWYgKCF4ZG9tYWluKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgZ2xvYmFsW1snQWN0aXZlJ10uY29uY2F0KCdPYmplY3QnKS5qb2luKCdYJyldKCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuICAgIH0gY2F0Y2ggKGUpIHsgfVxuICB9XG59O1xuIiwiLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnIzAwMDBDQycsICcjMDAwMEZGJywgJyMwMDMzQ0MnLCAnIzAwMzNGRicsICcjMDA2NkNDJywgJyMwMDY2RkYnLCAnIzAwOTlDQycsXG4gICcjMDA5OUZGJywgJyMwMENDMDAnLCAnIzAwQ0MzMycsICcjMDBDQzY2JywgJyMwMENDOTknLCAnIzAwQ0NDQycsICcjMDBDQ0ZGJyxcbiAgJyMzMzAwQ0MnLCAnIzMzMDBGRicsICcjMzMzM0NDJywgJyMzMzMzRkYnLCAnIzMzNjZDQycsICcjMzM2NkZGJywgJyMzMzk5Q0MnLFxuICAnIzMzOTlGRicsICcjMzNDQzAwJywgJyMzM0NDMzMnLCAnIzMzQ0M2NicsICcjMzNDQzk5JywgJyMzM0NDQ0MnLCAnIzMzQ0NGRicsXG4gICcjNjYwMENDJywgJyM2NjAwRkYnLCAnIzY2MzNDQycsICcjNjYzM0ZGJywgJyM2NkNDMDAnLCAnIzY2Q0MzMycsICcjOTkwMENDJyxcbiAgJyM5OTAwRkYnLCAnIzk5MzNDQycsICcjOTkzM0ZGJywgJyM5OUNDMDAnLCAnIzk5Q0MzMycsICcjQ0MwMDAwJywgJyNDQzAwMzMnLFxuICAnI0NDMDA2NicsICcjQ0MwMDk5JywgJyNDQzAwQ0MnLCAnI0NDMDBGRicsICcjQ0MzMzAwJywgJyNDQzMzMzMnLCAnI0NDMzM2NicsXG4gICcjQ0MzMzk5JywgJyNDQzMzQ0MnLCAnI0NDMzNGRicsICcjQ0M2NjAwJywgJyNDQzY2MzMnLCAnI0NDOTkwMCcsICcjQ0M5OTMzJyxcbiAgJyNDQ0NDMDAnLCAnI0NDQ0MzMycsICcjRkYwMDAwJywgJyNGRjAwMzMnLCAnI0ZGMDA2NicsICcjRkYwMDk5JywgJyNGRjAwQ0MnLFxuICAnI0ZGMDBGRicsICcjRkYzMzAwJywgJyNGRjMzMzMnLCAnI0ZGMzM2NicsICcjRkYzMzk5JywgJyNGRjMzQ0MnLCAnI0ZGMzNGRicsXG4gICcjRkY2NjAwJywgJyNGRjY2MzMnLCAnI0ZGOTkwMCcsICcjRkY5OTMzJywgJyNGRkNDMDAnLCAnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcbiAgcmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG4gICAgLy8gZG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVyci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybjtcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpXG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuXG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cbiIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnWydkZWZhdWx0J10gPSBjcmVhdGVEZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIEFjdGl2ZSBgZGVidWdgIGluc3RhbmNlcy5cbiAqL1xuZXhwb3J0cy5pbnN0YW5jZXMgPSBbXTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICB2YXIgaGFzaCA9IDAsIGk7XG5cbiAgZm9yIChpIGluIG5hbWVzcGFjZSkge1xuICAgIGhhc2ggID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW01hdGguYWJzKGhhc2gpICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cbiAgdmFyIHByZXZUaW1lO1xuXG4gIGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgIC8vIGRpc2FibGVkP1xuICAgIGlmICghZGVidWcuZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgdmFyIHNlbGYgPSBkZWJ1ZztcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gdHVybiB0aGUgYGFyZ3VtZW50c2AgaW50byBhIHByb3BlciBBcnJheVxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG4gICAgICBpbmRleCsrO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG5cbiAgICAvLyBhcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuICAgIGV4cG9ydHMuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG4gICAgdmFyIGxvZ0ZuID0gZGVidWcubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cblxuICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gIGRlYnVnLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgZGVidWcudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuICBkZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblxuICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuaW5pdCkge1xuICAgIGV4cG9ydHMuaW5pdChkZWJ1Zyk7XG4gIH1cblxuICBleHBvcnRzLmluc3RhbmNlcy5wdXNoKGRlYnVnKTtcblxuICByZXR1cm4gZGVidWc7XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3kgKCkge1xuICB2YXIgaW5kZXggPSBleHBvcnRzLmluc3RhbmNlcy5pbmRleE9mKHRoaXMpO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgZXhwb3J0cy5pbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICBleHBvcnRzLm5hbWVzID0gW107XG4gIGV4cG9ydHMuc2tpcHMgPSBbXTtcblxuICB2YXIgaTtcbiAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4cG9ydHMuaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGluc3RhbmNlID0gZXhwb3J0cy5pbnN0YW5jZXNbaV07XG4gICAgaW5zdGFuY2UuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChpbnN0YW5jZS5uYW1lc3BhY2UpO1xuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgaWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xudmFyIGhhc0JpbmFyeSA9IHJlcXVpcmUoJ2hhcy1iaW5hcnkyJyk7XG52YXIgc2xpY2VCdWZmZXIgPSByZXF1aXJlKCdhcnJheWJ1ZmZlci5zbGljZScpO1xudmFyIGFmdGVyID0gcmVxdWlyZSgnYWZ0ZXInKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG5cbnZhciBiYXNlNjRlbmNvZGVyO1xuaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgYmFzZTY0ZW5jb2RlciA9IHJlcXVpcmUoJ2Jhc2U2NC1hcnJheWJ1ZmZlcicpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGFuIGFuZHJvaWQgYnJvd3Nlci4gVGhhdCByZXF1aXJlcyB1cyB0byB1c2VcbiAqIEFycmF5QnVmZmVyIHdpdGggcG9sbGluZyB0cmFuc3BvcnRzLi4uXG4gKlxuICogaHR0cDovL2doaW5kYS5uZXQvanBlZy1ibG9iLWFqYXgtYW5kcm9pZC9cbiAqL1xuXG52YXIgaXNBbmRyb2lkID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGluIFBoYW50b21KUy5cbiAqIFVwbG9hZGluZyBhIEJsb2Igd2l0aCBQaGFudG9tSlMgZG9lcyBub3Qgd29yayBjb3JyZWN0bHksIGFzIHJlcG9ydGVkIGhlcmU6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYXJpeWEvcGhhbnRvbWpzL2lzc3Vlcy8xMTM5NVxuICogQHR5cGUgYm9vbGVhblxuICovXG52YXIgaXNQaGFudG9tSlMgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvUGhhbnRvbUpTL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBXaGVuIHRydWUsIGF2b2lkcyB1c2luZyBCbG9icyB0byBlbmNvZGUgcGF5bG9hZHMuXG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbnZhciBkb250U2VuZEJsb2JzID0gaXNBbmRyb2lkIHx8IGlzUGhhbnRvbUpTO1xuXG4vKipcbiAqIEN1cnJlbnQgcHJvdG9jb2wgdmVyc2lvbi5cbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gMztcblxuLyoqXG4gKiBQYWNrZXQgdHlwZXMuXG4gKi9cblxudmFyIHBhY2tldHMgPSBleHBvcnRzLnBhY2tldHMgPSB7XG4gICAgb3BlbjogICAgIDAgICAgLy8gbm9uLXdzXG4gICwgY2xvc2U6ICAgIDEgICAgLy8gbm9uLXdzXG4gICwgcGluZzogICAgIDJcbiAgLCBwb25nOiAgICAgM1xuICAsIG1lc3NhZ2U6ICA0XG4gICwgdXBncmFkZTogIDVcbiAgLCBub29wOiAgICAgNlxufTtcblxudmFyIHBhY2tldHNsaXN0ID0ga2V5cyhwYWNrZXRzKTtcblxuLyoqXG4gKiBQcmVtYWRlIGVycm9yIHBhY2tldC5cbiAqL1xuXG52YXIgZXJyID0geyB0eXBlOiAnZXJyb3InLCBkYXRhOiAncGFyc2VyIGVycm9yJyB9O1xuXG4vKipcbiAqIENyZWF0ZSBhIGJsb2IgYXBpIGV2ZW4gZm9yIGJsb2IgYnVpbGRlciB3aGVuIHZlbmRvciBwcmVmaXhlcyBleGlzdFxuICovXG5cbnZhciBCbG9iID0gcmVxdWlyZSgnYmxvYicpO1xuXG4vKipcbiAqIEVuY29kZXMgYSBwYWNrZXQuXG4gKlxuICogICAgIDxwYWNrZXQgdHlwZSBpZD4gWyA8ZGF0YT4gXVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDVoZWxsbyB3b3JsZFxuICogICAgIDNcbiAqICAgICA0XG4gKlxuICogQmluYXJ5IGlzIGVuY29kZWQgaW4gYW4gaWRlbnRpY2FsIHByaW5jaXBsZVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIHV0ZjhlbmNvZGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygc3VwcG9ydHNCaW5hcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgIHN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIHV0ZjhlbmNvZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHV0ZjhlbmNvZGU7XG4gICAgdXRmOGVuY29kZSA9IG51bGw7XG4gIH1cblxuICB2YXIgZGF0YSA9IChwYWNrZXQuZGF0YSA9PT0gdW5kZWZpbmVkKVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiBwYWNrZXQuZGF0YS5idWZmZXIgfHwgcGFja2V0LmRhdGE7XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGVuY29kZUFycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICByZXR1cm4gZW5jb2RlQmxvYihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH1cblxuICAvLyBtaWdodCBiZSBhbiBvYmplY3Qgd2l0aCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cbiAgaWYgKGRhdGEgJiYgZGF0YS5iYXNlNjQpIHtcbiAgICByZXR1cm4gZW5jb2RlQmFzZTY0T2JqZWN0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gU2VuZGluZyBkYXRhIGFzIGEgdXRmLTggc3RyaW5nXG4gIHZhciBlbmNvZGVkID0gcGFja2V0c1twYWNrZXQudHlwZV07XG5cbiAgLy8gZGF0YSBmcmFnbWVudCBpcyBvcHRpb25hbFxuICBpZiAodW5kZWZpbmVkICE9PSBwYWNrZXQuZGF0YSkge1xuICAgIGVuY29kZWQgKz0gdXRmOGVuY29kZSA/IHV0ZjguZW5jb2RlKFN0cmluZyhwYWNrZXQuZGF0YSksIHsgc3RyaWN0OiBmYWxzZSB9KSA6IFN0cmluZyhwYWNrZXQuZGF0YSk7XG4gIH1cblxuICByZXR1cm4gY2FsbGJhY2soJycgKyBlbmNvZGVkKTtcblxufTtcblxuZnVuY3Rpb24gZW5jb2RlQmFzZTY0T2JqZWN0KHBhY2tldCwgY2FsbGJhY2spIHtcbiAgLy8gcGFja2V0IGRhdGEgaXMgYW4gb2JqZWN0IHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBkYXRhQXNCYXNlNjRTdHJpbmcgfVxuICB2YXIgbWVzc2FnZSA9ICdiJyArIGV4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV0gKyBwYWNrZXQuZGF0YS5kYXRhO1xuICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG59XG5cbi8qKlxuICogRW5jb2RlIHBhY2tldCBoZWxwZXJzIGZvciBiaW5hcnkgdHlwZXNcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGRhdGEgPSBwYWNrZXQuZGF0YTtcbiAgdmFyIGNvbnRlbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB2YXIgcmVzdWx0QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMSArIGRhdGEuYnl0ZUxlbmd0aCk7XG5cbiAgcmVzdWx0QnVmZmVyWzBdID0gcGFja2V0c1twYWNrZXQudHlwZV07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0QnVmZmVyW2krMV0gPSBjb250ZW50QXJyYXlbaV07XG4gIH1cblxuICByZXR1cm4gY2FsbGJhY2socmVzdWx0QnVmZmVyLmJ1ZmZlcik7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJsb2JBc0FycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICBmci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldCh7IHR5cGU6IHBhY2tldC50eXBlLCBkYXRhOiBmci5yZXN1bHQgfSwgc3VwcG9ydHNCaW5hcnksIHRydWUsIGNhbGxiYWNrKTtcbiAgfTtcbiAgcmV0dXJuIGZyLnJlYWRBc0FycmF5QnVmZmVyKHBhY2tldC5kYXRhKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmxvYihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKGRvbnRTZW5kQmxvYnMpIHtcbiAgICByZXR1cm4gZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IG5ldyBVaW50OEFycmF5KDEpO1xuICBsZW5ndGhbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgdmFyIGJsb2IgPSBuZXcgQmxvYihbbGVuZ3RoLmJ1ZmZlciwgcGFja2V0LmRhdGFdKTtcblxuICByZXR1cm4gY2FsbGJhY2soYmxvYik7XG59XG5cbi8qKlxuICogRW5jb2RlcyBhIHBhY2tldCB3aXRoIGJpbmFyeSBkYXRhIGluIGEgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQsIGhhcyBgdHlwZWAgYW5kIGBkYXRhYFxuICogQHJldHVybiB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGNhbGxiYWNrKSB7XG4gIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgaWYgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBwYWNrZXQuZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICB2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGI2NCA9IGZyLnJlc3VsdC5zcGxpdCgnLCcpWzFdO1xuICAgICAgY2FsbGJhY2sobWVzc2FnZSArIGI2NCk7XG4gICAgfTtcbiAgICByZXR1cm4gZnIucmVhZEFzRGF0YVVSTChwYWNrZXQuZGF0YSk7XG4gIH1cblxuICB2YXIgYjY0ZGF0YTtcbiAgdHJ5IHtcbiAgICBiNjRkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgd2l0aCB0eXBlZCBhcnJheXNcbiAgICB2YXIgdHlwZWQgPSBuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSk7XG4gICAgdmFyIGJhc2ljID0gbmV3IEFycmF5KHR5cGVkLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZC5sZW5ndGg7IGkrKykge1xuICAgICAgYmFzaWNbaV0gPSB0eXBlZFtpXTtcbiAgICB9XG4gICAgYjY0ZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYmFzaWMpO1xuICB9XG4gIG1lc3NhZ2UgKz0gYnRvYShiNjRkYXRhKTtcbiAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgcGFja2V0LiBDaGFuZ2VzIGZvcm1hdCB0byBCbG9iIGlmIHJlcXVlc3RlZC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZGVjb2RlUGFja2V0ID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIHV0ZjhkZWNvZGUpIHtcbiAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBlcnI7XG4gIH1cbiAgLy8gU3RyaW5nIGRhdGFcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIGlmIChkYXRhLmNoYXJBdCgwKSA9PT0gJ2InKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQoZGF0YS5zdWJzdHIoMSksIGJpbmFyeVR5cGUpO1xuICAgIH1cblxuICAgIGlmICh1dGY4ZGVjb2RlKSB7XG4gICAgICBkYXRhID0gdHJ5RGVjb2RlKGRhdGEpO1xuICAgICAgaWYgKGRhdGEgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB0eXBlID0gZGF0YS5jaGFyQXQoMCk7XG5cbiAgICBpZiAoTnVtYmVyKHR5cGUpICE9IHR5cGUgfHwgIXBhY2tldHNsaXN0W3R5cGVdKSB7XG4gICAgICByZXR1cm4gZXJyO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdLCBkYXRhOiBkYXRhLnN1YnN0cmluZygxKSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBhc0FycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIHZhciB0eXBlID0gYXNBcnJheVswXTtcbiAgdmFyIHJlc3QgPSBzbGljZUJ1ZmZlcihkYXRhLCAxKTtcbiAgaWYgKEJsb2IgJiYgYmluYXJ5VHlwZSA9PT0gJ2Jsb2InKSB7XG4gICAgcmVzdCA9IG5ldyBCbG9iKFtyZXN0XSk7XG4gIH1cbiAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IHJlc3QgfTtcbn07XG5cbmZ1bmN0aW9uIHRyeURlY29kZShkYXRhKSB7XG4gIHRyeSB7XG4gICAgZGF0YSA9IHV0ZjguZGVjb2RlKGRhdGEsIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBEZWNvZGVzIGEgcGFja2V0IGVuY29kZWQgaW4gYSBiYXNlNjQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICovXG5cbmV4cG9ydHMuZGVjb2RlQmFzZTY0UGFja2V0ID0gZnVuY3Rpb24obXNnLCBiaW5hcnlUeXBlKSB7XG4gIHZhciB0eXBlID0gcGFja2V0c2xpc3RbbXNnLmNoYXJBdCgwKV07XG4gIGlmICghYmFzZTY0ZW5jb2Rlcikge1xuICAgIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBtc2cuc3Vic3RyKDEpIH0gfTtcbiAgfVxuXG4gIHZhciBkYXRhID0gYmFzZTY0ZW5jb2Rlci5kZWNvZGUobXNnLnN1YnN0cigxKSk7XG5cbiAgaWYgKGJpbmFyeVR5cGUgPT09ICdibG9iJyAmJiBCbG9iKSB7XG4gICAgZGF0YSA9IG5ldyBCbG9iKFtkYXRhXSk7XG4gIH1cblxuICByZXR1cm4geyB0eXBlOiB0eXBlLCBkYXRhOiBkYXRhIH07XG59O1xuXG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpLlxuICpcbiAqICAgICA8bGVuZ3RoPjpkYXRhXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgMTE6aGVsbG8gd29ybGQyOmhpXG4gKlxuICogSWYgYW55IGNvbnRlbnRzIGFyZSBiaW5hcnksIHRoZXkgd2lsbCBiZSBlbmNvZGVkIGFzIGJhc2U2NCBzdHJpbmdzLiBCYXNlNjRcbiAqIGVuY29kZWQgc3RyaW5ncyBhcmUgbWFya2VkIHdpdGggYSBiIGJlZm9yZSB0aGUgbGVuZ3RoIHNwZWNpZmllclxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChwYWNrZXRzLCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBzdXBwb3J0c0JpbmFyeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gc3VwcG9ydHNCaW5hcnk7XG4gICAgc3VwcG9ydHNCaW5hcnkgPSBudWxsO1xuICB9XG5cbiAgdmFyIGlzQmluYXJ5ID0gaGFzQmluYXJ5KHBhY2tldHMpO1xuXG4gIGlmIChzdXBwb3J0c0JpbmFyeSAmJiBpc0JpbmFyeSkge1xuICAgIGlmIChCbG9iICYmICFkb250U2VuZEJsb2JzKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNCbG9iKHBhY2tldHMsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlcihwYWNrZXRzLCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAoIXBhY2tldHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKCcwOicpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbWVzc2FnZS5sZW5ndGggKyAnOicgKyBtZXNzYWdlO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCAhaXNCaW5hcnkgPyBmYWxzZSA6IHN1cHBvcnRzQmluYXJ5LCBmYWxzZSwgZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIHNldExlbmd0aEhlYWRlcihtZXNzYWdlKSk7XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0cy5qb2luKCcnKSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBBc3luYyBhcnJheSBtYXAgdXNpbmcgYWZ0ZXJcbiAqL1xuXG5mdW5jdGlvbiBtYXAoYXJ5LCBlYWNoLCBkb25lKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoYXJ5Lmxlbmd0aCk7XG4gIHZhciBuZXh0ID0gYWZ0ZXIoYXJ5Lmxlbmd0aCwgZG9uZSk7XG5cbiAgdmFyIGVhY2hXaXRoSW5kZXggPSBmdW5jdGlvbihpLCBlbCwgY2IpIHtcbiAgICBlYWNoKGVsLCBmdW5jdGlvbihlcnJvciwgbXNnKSB7XG4gICAgICByZXN1bHRbaV0gPSBtc2c7XG4gICAgICBjYihlcnJvciwgcmVzdWx0KTtcbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuICAgIGVhY2hXaXRoSW5kZXgoaSwgYXJ5W2ldLCBuZXh0KTtcbiAgfVxufVxuXG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBQb3NzaWJsZSBiaW5hcnkgY29udGVudHMgYXJlXG4gKiBkZWNvZGVkIGZyb20gdGhlaXIgYmFzZTY0IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEsIGNhbGxiYWNrIG1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBheWxvYWQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBleHBvcnRzLmRlY29kZVBheWxvYWRBc0JpbmFyeShkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG4gICAgYmluYXJ5VHlwZSA9IG51bGw7XG4gIH1cblxuICB2YXIgcGFja2V0O1xuICBpZiAoZGF0YSA9PT0gJycpIHtcbiAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gJycsIG4sIG1zZztcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNociA9IGRhdGEuY2hhckF0KGkpO1xuXG4gICAgaWYgKGNociAhPT0gJzonKSB7XG4gICAgICBsZW5ndGggKz0gY2hyO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGxlbmd0aCA9PT0gJycgfHwgKGxlbmd0aCAhPSAobiA9IE51bWJlcihsZW5ndGgpKSkpIHtcbiAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgIH1cblxuICAgIG1zZyA9IGRhdGEuc3Vic3RyKGkgKyAxLCBuKTtcblxuICAgIGlmIChsZW5ndGggIT0gbXNnLmxlbmd0aCkge1xuICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgfVxuXG4gICAgaWYgKG1zZy5sZW5ndGgpIHtcbiAgICAgIHBhY2tldCA9IGV4cG9ydHMuZGVjb2RlUGFja2V0KG1zZywgYmluYXJ5VHlwZSwgZmFsc2UpO1xuXG4gICAgICBpZiAoZXJyLnR5cGUgPT09IHBhY2tldC50eXBlICYmIGVyci5kYXRhID09PSBwYWNrZXQuZGF0YSkge1xuICAgICAgICAvLyBwYXJzZXIgZXJyb3IgaW4gaW5kaXZpZHVhbCBwYWNrZXQgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmV0ID0gY2FsbGJhY2socGFja2V0LCBpICsgbiwgbCk7XG4gICAgICBpZiAoZmFsc2UgPT09IHJldCkgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGFkdmFuY2UgY3Vyc29yXG4gICAgaSArPSBuO1xuICAgIGxlbmd0aCA9ICcnO1xuICB9XG5cbiAgaWYgKGxlbmd0aCAhPT0gJycpIHtcbiAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gIH1cblxufTtcblxuLyoqXG4gKiBFbmNvZGVzIG11bHRpcGxlIG1lc3NhZ2VzIChwYXlsb2FkKSBhcyBiaW5hcnkuXG4gKlxuICogPDEgPSBiaW5hcnksIDAgPSBzdHJpbmc+PG51bWJlciBmcm9tIDAtOT48bnVtYmVyIGZyb20gMC05PlsuLi5dPG51bWJlclxuICogMjU1PjxkYXRhPlxuICpcbiAqIEV4YW1wbGU6XG4gKiAxIDMgMjU1IDEgMiAzLCBpZiB0aGUgYmluYXJ5IGNvbnRlbnRzIGFyZSBpbnRlcnByZXRlZCBhcyA4IGJpdCBpbnRlZ2Vyc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBlbmNvZGVkIHBheWxvYWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQXJyYXlCdWZmZXIgPSBmdW5jdGlvbihwYWNrZXRzLCBjYWxsYmFjaykge1xuICBpZiAoIXBhY2tldHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBBcnJheUJ1ZmZlcigwKSk7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIHRydWUsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiBkb25lQ2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIGVuY29kZWRQYWNrZXRzKSB7XG4gICAgdmFyIHRvdGFsTGVuZ3RoID0gZW5jb2RlZFBhY2tldHMucmVkdWNlKGZ1bmN0aW9uKGFjYywgcCkge1xuICAgICAgdmFyIGxlbjtcbiAgICAgIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpe1xuICAgICAgICBsZW4gPSBwLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IHAuYnl0ZUxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2MgKyBsZW4udG9TdHJpbmcoKS5sZW5ndGggKyBsZW4gKyAyOyAvLyBzdHJpbmcvYmluYXJ5IGlkZW50aWZpZXIgKyBzZXBhcmF0b3IgPSAyXG4gICAgfSwgMCk7XG5cbiAgICB2YXIgcmVzdWx0QXJyYXkgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG5cbiAgICB2YXIgYnVmZmVySW5kZXggPSAwO1xuICAgIGVuY29kZWRQYWNrZXRzLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIHAgPT09ICdzdHJpbmcnO1xuICAgICAgdmFyIGFiID0gcDtcbiAgICAgIGlmIChpc1N0cmluZykge1xuICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KHAubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmlld1tpXSA9IHAuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBhYiA9IHZpZXcuYnVmZmVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNTdHJpbmcpIHsgLy8gbm90IHRydWUgYmluYXJ5XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMDtcbiAgICAgIH0gZWxzZSB7IC8vIHRydWUgYmluYXJ5XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlblN0ciA9IGFiLmJ5dGVMZW5ndGgudG9TdHJpbmcoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuU3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMjU1O1xuXG4gICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGFiKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IHZpZXdbaV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0QXJyYXkuYnVmZmVyKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEVuY29kZSBhcyBCbG9iXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNCbG9iID0gZnVuY3Rpb24ocGFja2V0cywgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCB0cnVlLCB0cnVlLCBmdW5jdGlvbihlbmNvZGVkKSB7XG4gICAgICB2YXIgYmluYXJ5SWRlbnRpZmllciA9IG5ldyBVaW50OEFycmF5KDEpO1xuICAgICAgYmluYXJ5SWRlbnRpZmllclswXSA9IDE7XG4gICAgICBpZiAodHlwZW9mIGVuY29kZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZC5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2aWV3W2ldID0gZW5jb2RlZC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGVuY29kZWQgPSB2aWV3LmJ1ZmZlcjtcbiAgICAgICAgYmluYXJ5SWRlbnRpZmllclswXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW4gPSAoZW5jb2RlZCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgICAgICA/IGVuY29kZWQuYnl0ZUxlbmd0aFxuICAgICAgICA6IGVuY29kZWQuc2l6ZTtcblxuICAgICAgdmFyIGxlblN0ciA9IGxlbi50b1N0cmluZygpO1xuICAgICAgdmFyIGxlbmd0aEFyeSA9IG5ldyBVaW50OEFycmF5KGxlblN0ci5sZW5ndGggKyAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuU3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxlbmd0aEFyeVtpXSA9IHBhcnNlSW50KGxlblN0cltpXSk7XG4gICAgICB9XG4gICAgICBsZW5ndGhBcnlbbGVuU3RyLmxlbmd0aF0gPSAyNTU7XG5cbiAgICAgIGlmIChCbG9iKSB7XG4gICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW2JpbmFyeUlkZW50aWZpZXIuYnVmZmVyLCBsZW5ndGhBcnkuYnVmZmVyLCBlbmNvZGVkXSk7XG4gICAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBibG9iKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgIHJldHVybiBjYWxsYmFjayhuZXcgQmxvYihyZXN1bHRzKSk7XG4gIH0pO1xufTtcblxuLypcbiAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gU3RyaW5ncyBhcmUgZGVjb2RlZCBieVxuICogaW50ZXJwcmV0aW5nIGVhY2ggYnl0ZSBhcyBhIGtleSBjb2RlIGZvciBlbnRyaWVzIG1hcmtlZCB0byBzdGFydCB3aXRoIDAuIFNlZVxuICogZGVzY3JpcHRpb24gb2YgZW5jb2RlUGF5bG9hZEFzQmluYXJ5XG4gKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5ID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBidWZmZXJUYWlsID0gZGF0YTtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcblxuICB3aGlsZSAoYnVmZmVyVGFpbC5ieXRlTGVuZ3RoID4gMCkge1xuICAgIHZhciB0YWlsQXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXJUYWlsKTtcbiAgICB2YXIgaXNTdHJpbmcgPSB0YWlsQXJyYXlbMF0gPT09IDA7XG4gICAgdmFyIG1zZ0xlbmd0aCA9ICcnO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IDsgaSsrKSB7XG4gICAgICBpZiAodGFpbEFycmF5W2ldID09PSAyNTUpIGJyZWFrO1xuXG4gICAgICAvLyAzMTAgPSBjaGFyIGxlbmd0aCBvZiBOdW1iZXIuTUFYX1ZBTFVFXG4gICAgICBpZiAobXNnTGVuZ3RoLmxlbmd0aCA+IDMxMCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgIH1cblxuICAgICAgbXNnTGVuZ3RoICs9IHRhaWxBcnJheVtpXTtcbiAgICB9XG5cbiAgICBidWZmZXJUYWlsID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgMiArIG1zZ0xlbmd0aC5sZW5ndGgpO1xuICAgIG1zZ0xlbmd0aCA9IHBhcnNlSW50KG1zZ0xlbmd0aCk7XG5cbiAgICB2YXIgbXNnID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgMCwgbXNnTGVuZ3RoKTtcbiAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1zZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkobXNnKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlQaG9uZSBTYWZhcmkgZG9lc24ndCBsZXQgeW91IGFwcGx5IHRvIHR5cGVkIGFycmF5c1xuICAgICAgICB2YXIgdHlwZWQgPSBuZXcgVWludDhBcnJheShtc2cpO1xuICAgICAgICBtc2cgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG1zZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHR5cGVkW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGJ1ZmZlcnMucHVzaChtc2cpO1xuICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCBtc2dMZW5ndGgpO1xuICB9XG5cbiAgdmFyIHRvdGFsID0gYnVmZmVycy5sZW5ndGg7XG4gIGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbihidWZmZXIsIGkpIHtcbiAgICBjYWxsYmFjayhleHBvcnRzLmRlY29kZVBhY2tldChidWZmZXIsIGJpbmFyeVR5cGUsIHRydWUpLCBpLCB0b3RhbCk7XG4gIH0pO1xufTtcbiIsIlxuLyoqXG4gKiBHZXRzIHRoZSBrZXlzIGZvciBhbiBvYmplY3QuXG4gKlxuICogQHJldHVybiB7QXJyYXl9IGtleXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyAob2JqKXtcbiAgdmFyIGFyciA9IFtdO1xuICB2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGkpKSB7XG4gICAgICBhcnIucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3V0ZjhqcyB2Mi4xLjIgYnkgQG1hdGhpYXMgKi9cblxudmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbi8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5mdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHR2YXIgb3V0cHV0ID0gW107XG5cdHZhciBjb3VudGVyID0gMDtcblx0dmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdHZhciB2YWx1ZTtcblx0dmFyIGV4dHJhO1xuXHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG91dHB1dDtcbn1cblxuLy8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcbmZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0dmFyIGluZGV4ID0gLTE7XG5cdHZhciB2YWx1ZTtcblx0dmFyIG91dHB1dCA9ICcnO1xuXHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdH1cblx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0fVxuXHRyZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSB7XG5cdGlmIChjb2RlUG9pbnQgPj0gMHhEODAwICYmIGNvZGVQb2ludCA8PSAweERGRkYpIHtcblx0XHRpZiAoc3RyaWN0KSB7XG5cdFx0XHR0aHJvdyBFcnJvcihcblx0XHRcdFx0J0xvbmUgc3Vycm9nYXRlIFUrJyArIGNvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArXG5cdFx0XHRcdCcgaXMgbm90IGEgc2NhbGFyIHZhbHVlJ1xuXHRcdFx0KTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHJldHVybiB0cnVlO1xufVxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ5dGUoY29kZVBvaW50LCBzaGlmdCkge1xuXHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IHNoaWZ0KSAmIDB4M0YpIHwgMHg4MCk7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQsIHN0cmljdCkge1xuXHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkZGODApID09IDApIHsgLy8gMS1ieXRlIHNlcXVlbmNlXG5cdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuXHR9XG5cdHZhciBzeW1ib2wgPSAnJztcblx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGODAwKSA9PSAwKSB7IC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiA2KSAmIDB4MUYpIHwgMHhDMCk7XG5cdH1cblx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZGRjAwMDApID09IDApIHsgLy8gMy1ieXRlIHNlcXVlbmNlXG5cdFx0aWYgKCFjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSkge1xuXHRcdFx0Y29kZVBvaW50ID0gMHhGRkZEO1xuXHRcdH1cblx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTIpICYgMHgwRikgfCAweEUwKTtcblx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHR9XG5cdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRTAwMDAwKSA9PSAwKSB7IC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxOCkgJiAweDA3KSB8IDB4RjApO1xuXHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgMTIpO1xuXHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdH1cblx0c3ltYm9sICs9IHN0cmluZ0Zyb21DaGFyQ29kZSgoY29kZVBvaW50ICYgMHgzRikgfCAweDgwKTtcblx0cmV0dXJuIHN5bWJvbDtcbn1cblxuZnVuY3Rpb24gdXRmOGVuY29kZShzdHJpbmcsIG9wdHMpIHtcblx0b3B0cyA9IG9wdHMgfHwge307XG5cdHZhciBzdHJpY3QgPSBmYWxzZSAhPT0gb3B0cy5zdHJpY3Q7XG5cblx0dmFyIGNvZGVQb2ludHMgPSB1Y3MyZGVjb2RlKHN0cmluZyk7XG5cdHZhciBsZW5ndGggPSBjb2RlUG9pbnRzLmxlbmd0aDtcblx0dmFyIGluZGV4ID0gLTE7XG5cdHZhciBjb2RlUG9pbnQ7XG5cdHZhciBieXRlU3RyaW5nID0gJyc7XG5cdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0Y29kZVBvaW50ID0gY29kZVBvaW50c1tpbmRleF07XG5cdFx0Ynl0ZVN0cmluZyArPSBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50LCBzdHJpY3QpO1xuXHR9XG5cdHJldHVybiBieXRlU3RyaW5nO1xufVxuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuZnVuY3Rpb24gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKSB7XG5cdGlmIChieXRlSW5kZXggPj0gYnl0ZUNvdW50KSB7XG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHR9XG5cblx0dmFyIGNvbnRpbnVhdGlvbkJ5dGUgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG5cdGJ5dGVJbmRleCsrO1xuXG5cdGlmICgoY29udGludWF0aW9uQnl0ZSAmIDB4QzApID09IDB4ODApIHtcblx0XHRyZXR1cm4gY29udGludWF0aW9uQnl0ZSAmIDB4M0Y7XG5cdH1cblxuXHQvLyBJZiB3ZSBlbmQgdXAgaGVyZSwgaXTigJlzIG5vdCBhIGNvbnRpbnVhdGlvbiBieXRlXG5cdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVN5bWJvbChzdHJpY3QpIHtcblx0dmFyIGJ5dGUxO1xuXHR2YXIgYnl0ZTI7XG5cdHZhciBieXRlMztcblx0dmFyIGJ5dGU0O1xuXHR2YXIgY29kZVBvaW50O1xuXG5cdGlmIChieXRlSW5kZXggPiBieXRlQ291bnQpIHtcblx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG5cdH1cblxuXHRpZiAoYnl0ZUluZGV4ID09IGJ5dGVDb3VudCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIFJlYWQgZmlyc3QgYnl0ZVxuXHRieXRlMSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0Ynl0ZUluZGV4Kys7XG5cblx0Ly8gMS1ieXRlIHNlcXVlbmNlIChubyBjb250aW51YXRpb24gYnl0ZXMpXG5cdGlmICgoYnl0ZTEgJiAweDgwKSA9PSAwKSB7XG5cdFx0cmV0dXJuIGJ5dGUxO1xuXHR9XG5cblx0Ly8gMi1ieXRlIHNlcXVlbmNlXG5cdGlmICgoYnl0ZTEgJiAweEUwKSA9PSAweEMwKSB7XG5cdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDFGKSA8PCA2KSB8IGJ5dGUyO1xuXHRcdGlmIChjb2RlUG9pbnQgPj0gMHg4MCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHR9XG5cdH1cblxuXHQvLyAzLWJ5dGUgc2VxdWVuY2UgKG1heSBpbmNsdWRlIHVucGFpcmVkIHN1cnJvZ2F0ZXMpXG5cdGlmICgoYnl0ZTEgJiAweEYwKSA9PSAweEUwKSB7XG5cdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwRikgPDwgMTIpIHwgKGJ5dGUyIDw8IDYpIHwgYnl0ZTM7XG5cdFx0aWYgKGNvZGVQb2ludCA+PSAweDA4MDApIHtcblx0XHRcdHJldHVybiBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSA/IGNvZGVQb2ludCA6IDB4RkZGRDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHR9XG5cdH1cblxuXHQvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0aWYgKChieXRlMSAmIDB4RjgpID09IDB4RjApIHtcblx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdGJ5dGU0ID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwNykgPDwgMHgxMikgfCAoYnl0ZTIgPDwgMHgwQykgfFxuXHRcdFx0KGJ5dGUzIDw8IDB4MDYpIHwgYnl0ZTQ7XG5cdFx0aWYgKGNvZGVQb2ludCA+PSAweDAxMDAwMCAmJiBjb2RlUG9pbnQgPD0gMHgxMEZGRkYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0fVxuXHR9XG5cblx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgVVRGLTggZGV0ZWN0ZWQnKTtcbn1cblxudmFyIGJ5dGVBcnJheTtcbnZhciBieXRlQ291bnQ7XG52YXIgYnl0ZUluZGV4O1xuZnVuY3Rpb24gdXRmOGRlY29kZShieXRlU3RyaW5nLCBvcHRzKSB7XG5cdG9wdHMgPSBvcHRzIHx8IHt9O1xuXHR2YXIgc3RyaWN0ID0gZmFsc2UgIT09IG9wdHMuc3RyaWN0O1xuXG5cdGJ5dGVBcnJheSA9IHVjczJkZWNvZGUoYnl0ZVN0cmluZyk7XG5cdGJ5dGVDb3VudCA9IGJ5dGVBcnJheS5sZW5ndGg7XG5cdGJ5dGVJbmRleCA9IDA7XG5cdHZhciBjb2RlUG9pbnRzID0gW107XG5cdHZhciB0bXA7XG5cdHdoaWxlICgodG1wID0gZGVjb2RlU3ltYm9sKHN0cmljdCkpICE9PSBmYWxzZSkge1xuXHRcdGNvZGVQb2ludHMucHVzaCh0bXApO1xuXHR9XG5cdHJldHVybiB1Y3MyZW5jb2RlKGNvZGVQb2ludHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0dmVyc2lvbjogJzIuMS4yJyxcblx0ZW5jb2RlOiB1dGY4ZW5jb2RlLFxuXHRkZWNvZGU6IHV0ZjhkZWNvZGVcbn07XG4iLCIvKiBnbG9iYWwgQmxvYiBGaWxlICovXG5cbi8qXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHdpdGhOYXRpdmVCbG9iID0gdHlwZW9mIEJsb2IgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiB0b1N0cmluZy5jYWxsKEJsb2IpID09PSAnW29iamVjdCBCbG9iQ29uc3RydWN0b3JdJztcbnZhciB3aXRoTmF0aXZlRmlsZSA9IHR5cGVvZiBGaWxlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgRmlsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdG9TdHJpbmcuY2FsbChGaWxlKSA9PT0gJ1tvYmplY3QgRmlsZUNvbnN0cnVjdG9yXSc7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNCaW5hcnk7XG5cbi8qKlxuICogQ2hlY2tzIGZvciBiaW5hcnkgZGF0YS5cbiAqXG4gKiBTdXBwb3J0cyBCdWZmZXIsIEFycmF5QnVmZmVyLCBCbG9iIGFuZCBGaWxlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhbnl0aGluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBoYXNCaW5hcnkgKG9iaikge1xuICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChoYXNCaW5hcnkob2JqW2ldKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCh0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIEJ1ZmZlci5pc0J1ZmZlciAmJiBCdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAodHlwZW9mIEFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fFxuICAgICh3aXRoTmF0aXZlQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICh3aXRoTmF0aXZlRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvaGFzLWJpbmFyeS9wdWxsLzRcbiAgaWYgKG9iai50b0pTT04gJiYgdHlwZW9mIG9iai50b0pTT04gPT09ICdmdW5jdGlvbicgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBoYXNCaW5hcnkob2JqLnRvSlNPTigpLCB0cnVlKTtcbiAgfVxuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSAmJiBoYXNCaW5hcnkob2JqW2tleV0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqXG4gKiBMb2dpYyBib3Jyb3dlZCBmcm9tIE1vZGVybml6cjpcbiAqXG4gKiAgIC0gaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2NvcnMuanNcbiAqL1xuXG50cnkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbn0gY2F0Y2ggKGVycikge1xuICAvLyBpZiBYTUxIdHRwIHN1cHBvcnQgaXMgZGlzYWJsZWQgaW4gSUUgdGhlbiBpdCB3aWxsIHRocm93XG4gIC8vIHdoZW4gdHJ5aW5nIHRvIGNyZWF0ZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xufVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiXG52YXIgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyLCBvYmope1xuICBpZiAoaW5kZXhPZikgcmV0dXJuIGFyci5pbmRleE9mKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFycltpXSA9PT0gb2JqKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59OyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgaWYgKG1zID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtcyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKSB8fFxuICAgIHBsdXJhbChtcywgaCwgJ2hvdXInKSB8fFxuICAgIHBsdXJhbChtcywgbSwgJ21pbnV0ZScpIHx8XG4gICAgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJykgfHxcbiAgICBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuICBpZiAobXMgPCBuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChtcyA8IG4gKiAxLjUpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcbiAgfVxuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xufVxuIiwiLyoqXHJcbiAqIENvbXBpbGVzIGEgcXVlcnlzdHJpbmdcclxuICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdFxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH1cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgdmFyIHN0ciA9ICcnO1xyXG5cclxuICBmb3IgKHZhciBpIGluIG9iaikge1xyXG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xyXG4gICAgICBpZiAoc3RyLmxlbmd0aCkgc3RyICs9ICcmJztcclxuICAgICAgc3RyICs9IGVuY29kZVVSSUNvbXBvbmVudChpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0cjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBQYXJzZXMgYSBzaW1wbGUgcXVlcnlzdHJpbmcgaW50byBhbiBvYmplY3RcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHFzXHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24ocXMpe1xyXG4gIHZhciBxcnkgPSB7fTtcclxuICB2YXIgcGFpcnMgPSBxcy5zcGxpdCgnJicpO1xyXG4gIGZvciAodmFyIGkgPSAwLCBsID0gcGFpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICB2YXIgcGFpciA9IHBhaXJzW2ldLnNwbGl0KCc9Jyk7XHJcbiAgICBxcnlbZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMF0pXSA9IGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKTtcclxuICB9XHJcbiAgcmV0dXJuIHFyeTtcclxufTtcclxuIiwiLyoqXHJcbiAqIFBhcnNlcyBhbiBVUklcclxuICpcclxuICogQGF1dGhvciBTdGV2ZW4gTGV2aXRoYW4gPHN0ZXZlbmxldml0aGFuLmNvbT4gKE1JVCBsaWNlbnNlKVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG52YXIgcmUgPSAvXig/Oig/IVteOkBdKzpbXjpAXFwvXSpAKShodHRwfGh0dHBzfHdzfHdzcyk6XFwvXFwvKT8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPygoPzpbYS1mMC05XXswLDR9Oil7Miw3fVthLWYwLTldezAsNH18W146XFwvPyNdKikoPzo6KFxcZCopKT8pKCgoXFwvKD86W14/I10oPyFbXj8jXFwvXSpcXC5bXj8jXFwvLl0rKD86Wz8jXXwkKSkpKlxcLz8pPyhbXj8jXFwvXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pLztcclxuXHJcbnZhciBwYXJ0cyA9IFtcclxuICAgICdzb3VyY2UnLCAncHJvdG9jb2wnLCAnYXV0aG9yaXR5JywgJ3VzZXJJbmZvJywgJ3VzZXInLCAncGFzc3dvcmQnLCAnaG9zdCcsICdwb3J0JywgJ3JlbGF0aXZlJywgJ3BhdGgnLCAnZGlyZWN0b3J5JywgJ2ZpbGUnLCAncXVlcnknLCAnYW5jaG9yJ1xyXG5dO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZXVyaShzdHIpIHtcclxuICAgIHZhciBzcmMgPSBzdHIsXHJcbiAgICAgICAgYiA9IHN0ci5pbmRleE9mKCdbJyksXHJcbiAgICAgICAgZSA9IHN0ci5pbmRleE9mKCddJyk7XHJcblxyXG4gICAgaWYgKGIgIT0gLTEgJiYgZSAhPSAtMSkge1xyXG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgYikgKyBzdHIuc3Vic3RyaW5nKGIsIGUpLnJlcGxhY2UoLzovZywgJzsnKSArIHN0ci5zdWJzdHJpbmcoZSwgc3RyLmxlbmd0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG0gPSByZS5leGVjKHN0ciB8fCAnJyksXHJcbiAgICAgICAgdXJpID0ge30sXHJcbiAgICAgICAgaSA9IDE0O1xyXG5cclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICB1cmlbcGFydHNbaV1dID0gbVtpXSB8fCAnJztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XHJcbiAgICAgICAgdXJpLnNvdXJjZSA9IHNyYztcclxuICAgICAgICB1cmkuaG9zdCA9IHVyaS5ob3N0LnN1YnN0cmluZygxLCB1cmkuaG9zdC5sZW5ndGggLSAxKS5yZXBsYWNlKC87L2csICc6Jyk7XHJcbiAgICAgICAgdXJpLmF1dGhvcml0eSA9IHVyaS5hdXRob3JpdHkucmVwbGFjZSgnWycsICcnKS5yZXBsYWNlKCddJywgJycpLnJlcGxhY2UoLzsvZywgJzonKTtcclxuICAgICAgICB1cmkuaXB2NnVyaSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHVyaTtcclxufTtcclxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB1cmwgPSByZXF1aXJlKCcuL3VybCcpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBNYW5hZ2VyID0gcmVxdWlyZSgnLi9tYW5hZ2VyJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbG9va3VwO1xuXG4vKipcbiAqIE1hbmFnZXJzIGNhY2hlLlxuICovXG5cbnZhciBjYWNoZSA9IGV4cG9ydHMubWFuYWdlcnMgPSB7fTtcblxuLyoqXG4gKiBMb29rcyB1cCBhbiBleGlzdGluZyBgTWFuYWdlcmAgZm9yIG11bHRpcGxleGluZy5cbiAqIElmIHRoZSB1c2VyIHN1bW1vbnM6XG4gKlxuICogICBgaW8oJ2h0dHA6Ly9sb2NhbGhvc3QvYScpO2BcbiAqICAgYGlvKCdodHRwOi8vbG9jYWxob3N0L2InKTtgXG4gKlxuICogV2UgcmV1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlIGJhc2VkIG9uIHNhbWUgc2NoZW1lL3BvcnQvaG9zdCxcbiAqIGFuZCB3ZSBpbml0aWFsaXplIHNvY2tldHMgZm9yIGVhY2ggbmFtZXNwYWNlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9va3VwICh1cmksIG9wdHMpIHtcbiAgaWYgKHR5cGVvZiB1cmkgPT09ICdvYmplY3QnKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICB2YXIgcGFyc2VkID0gdXJsKHVyaSk7XG4gIHZhciBzb3VyY2UgPSBwYXJzZWQuc291cmNlO1xuICB2YXIgaWQgPSBwYXJzZWQuaWQ7XG4gIHZhciBwYXRoID0gcGFyc2VkLnBhdGg7XG4gIHZhciBzYW1lTmFtZXNwYWNlID0gY2FjaGVbaWRdICYmIHBhdGggaW4gY2FjaGVbaWRdLm5zcHM7XG4gIHZhciBuZXdDb25uZWN0aW9uID0gb3B0cy5mb3JjZU5ldyB8fCBvcHRzWydmb3JjZSBuZXcgY29ubmVjdGlvbiddIHx8XG4gICAgICAgICAgICAgICAgICAgICAgZmFsc2UgPT09IG9wdHMubXVsdGlwbGV4IHx8IHNhbWVOYW1lc3BhY2U7XG5cbiAgdmFyIGlvO1xuXG4gIGlmIChuZXdDb25uZWN0aW9uKSB7XG4gICAgZGVidWcoJ2lnbm9yaW5nIHNvY2tldCBjYWNoZSBmb3IgJXMnLCBzb3VyY2UpO1xuICAgIGlvID0gTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghY2FjaGVbaWRdKSB7XG4gICAgICBkZWJ1ZygnbmV3IGlvIGluc3RhbmNlIGZvciAlcycsIHNvdXJjZSk7XG4gICAgICBjYWNoZVtpZF0gPSBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG4gICAgfVxuICAgIGlvID0gY2FjaGVbaWRdO1xuICB9XG4gIGlmIChwYXJzZWQucXVlcnkgJiYgIW9wdHMucXVlcnkpIHtcbiAgICBvcHRzLnF1ZXJ5ID0gcGFyc2VkLnF1ZXJ5O1xuICB9XG4gIHJldHVybiBpby5zb2NrZXQocGFyc2VkLnBhdGgsIG9wdHMpO1xufVxuXG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sO1xuXG4vKipcbiAqIGBjb25uZWN0YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJpXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuY29ubmVjdCA9IGxvb2t1cDtcblxuLyoqXG4gKiBFeHBvc2UgY29uc3RydWN0b3JzIGZvciBzdGFuZGFsb25lIGJ1aWxkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5NYW5hZ2VyID0gcmVxdWlyZSgnLi9tYW5hZ2VyJyk7XG5leHBvcnRzLlNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZWlvID0gcmVxdWlyZSgnZW5naW5lLmlvLWNsaWVudCcpO1xudmFyIFNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIG9uID0gcmVxdWlyZSgnLi9vbicpO1xudmFyIGJpbmQgPSByZXF1aXJlKCdjb21wb25lbnQtYmluZCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDptYW5hZ2VyJyk7XG52YXIgaW5kZXhPZiA9IHJlcXVpcmUoJ2luZGV4b2YnKTtcbnZhciBCYWNrb2ZmID0gcmVxdWlyZSgnYmFja28yJyk7XG5cbi8qKlxuICogSUU2KyBoYXNPd25Qcm9wZXJ0eVxuICovXG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBNYW5hZ2VyO1xuXG4vKipcbiAqIGBNYW5hZ2VyYCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5naW5lIGluc3RhbmNlIG9yIGVuZ2luZSB1cmkvb3B0c1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gTWFuYWdlciAodXJpLCBvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNYW5hZ2VyKSkgcmV0dXJuIG5ldyBNYW5hZ2VyKHVyaSwgb3B0cyk7XG4gIGlmICh1cmkgJiYgKCdvYmplY3QnID09PSB0eXBlb2YgdXJpKSkge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gdW5kZWZpbmVkO1xuICB9XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIG9wdHMucGF0aCA9IG9wdHMucGF0aCB8fCAnL3NvY2tldC5pbyc7XG4gIHRoaXMubnNwcyA9IHt9O1xuICB0aGlzLnN1YnMgPSBbXTtcbiAgdGhpcy5vcHRzID0gb3B0cztcbiAgdGhpcy5yZWNvbm5lY3Rpb24ob3B0cy5yZWNvbm5lY3Rpb24gIT09IGZhbHNlKTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25BdHRlbXB0cyhvcHRzLnJlY29ubmVjdGlvbkF0dGVtcHRzIHx8IEluZmluaXR5KTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25EZWxheShvcHRzLnJlY29ubmVjdGlvbkRlbGF5IHx8IDEwMDApO1xuICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KG9wdHMucmVjb25uZWN0aW9uRGVsYXlNYXggfHwgNTAwMCk7XG4gIHRoaXMucmFuZG9taXphdGlvbkZhY3RvcihvcHRzLnJhbmRvbWl6YXRpb25GYWN0b3IgfHwgMC41KTtcbiAgdGhpcy5iYWNrb2ZmID0gbmV3IEJhY2tvZmYoe1xuICAgIG1pbjogdGhpcy5yZWNvbm5lY3Rpb25EZWxheSgpLFxuICAgIG1heDogdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heCgpLFxuICAgIGppdHRlcjogdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKClcbiAgfSk7XG4gIHRoaXMudGltZW91dChudWxsID09IG9wdHMudGltZW91dCA/IDIwMDAwIDogb3B0cy50aW1lb3V0KTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMudXJpID0gdXJpO1xuICB0aGlzLmNvbm5lY3RpbmcgPSBbXTtcbiAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcbiAgdGhpcy5wYWNrZXRCdWZmZXIgPSBbXTtcbiAgdmFyIF9wYXJzZXIgPSBvcHRzLnBhcnNlciB8fCBwYXJzZXI7XG4gIHRoaXMuZW5jb2RlciA9IG5ldyBfcGFyc2VyLkVuY29kZXIoKTtcbiAgdGhpcy5kZWNvZGVyID0gbmV3IF9wYXJzZXIuRGVjb2RlcigpO1xuICB0aGlzLmF1dG9Db25uZWN0ID0gb3B0cy5hdXRvQ29ubmVjdCAhPT0gZmFsc2U7XG4gIGlmICh0aGlzLmF1dG9Db25uZWN0KSB0aGlzLm9wZW4oKTtcbn1cblxuLyoqXG4gKiBQcm9wYWdhdGUgZ2l2ZW4gZXZlbnQgdG8gc29ja2V0cyBhbmQgZW1pdCBvbiBgdGhpc2BcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5lbWl0QWxsID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgZm9yICh2YXIgbnNwIGluIHRoaXMubnNwcykge1xuICAgIGlmIChoYXMuY2FsbCh0aGlzLm5zcHMsIG5zcCkpIHtcbiAgICAgIHRoaXMubnNwc1tuc3BdLmVtaXQuYXBwbHkodGhpcy5uc3BzW25zcF0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBgc29ja2V0LmlkYCBvZiBhbGwgc29ja2V0c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVNvY2tldElkcyA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgbnNwIGluIHRoaXMubnNwcykge1xuICAgIGlmIChoYXMuY2FsbCh0aGlzLm5zcHMsIG5zcCkpIHtcbiAgICAgIHRoaXMubnNwc1tuc3BdLmlkID0gdGhpcy5nZW5lcmF0ZUlkKG5zcCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIGdlbmVyYXRlIGBzb2NrZXQuaWRgIGZvciB0aGUgZ2l2ZW4gYG5zcGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbnNwXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5nZW5lcmF0ZUlkID0gZnVuY3Rpb24gKG5zcCkge1xuICByZXR1cm4gKG5zcCA9PT0gJy8nID8gJycgOiAobnNwICsgJyMnKSkgKyB0aGlzLmVuZ2luZS5pZDtcbn07XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKE1hbmFnZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgcmVjb25uZWN0aW9uYCBjb25maWcuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSB0cnVlL2ZhbHNlIGlmIGl0IHNob3VsZCBhdXRvbWF0aWNhbGx5IHJlY29ubmVjdFxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb24gPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb247XG4gIHRoaXMuX3JlY29ubmVjdGlvbiA9ICEhdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHJlY29ubmVjdGlvbiBhdHRlbXB0cyBjb25maWcuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heCByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgYmVmb3JlIGdpdmluZyB1cFxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzO1xuICB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5ID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXk7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5ID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRNaW4odik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuTWFuYWdlci5wcm90b3R5cGUucmFuZG9taXphdGlvbkZhY3RvciA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3I7XG4gIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3IgPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldEppdHRlcih2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIG1heGltdW0gZGVsYXkgYmV0d2VlbiByZWNvbm5lY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25EZWxheU1heCA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4O1xuICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heCA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWF4KHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY29ubmVjdGlvbiB0aW1lb3V0LiBgZmFsc2VgIHRvIGRpc2FibGVcbiAqXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl90aW1lb3V0O1xuICB0aGlzLl90aW1lb3V0ID0gdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyB0cnlpbmcgdG8gcmVjb25uZWN0IGlmIHJlY29ubmVjdGlvbiBpcyBlbmFibGVkIGFuZCB3ZSBoYXZlIG5vdFxuICogc3RhcnRlZCByZWNvbm5lY3RpbmcgeWV0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUubWF5YmVSZWNvbm5lY3RPbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIC8vIE9ubHkgdHJ5IHRvIHJlY29ubmVjdCBpZiBpdCdzIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIGNvbm5lY3RpbmdcbiAgaWYgKCF0aGlzLnJlY29ubmVjdGluZyAmJiB0aGlzLl9yZWNvbm5lY3Rpb24gJiYgdGhpcy5iYWNrb2ZmLmF0dGVtcHRzID09PSAwKSB7XG4gICAgLy8ga2VlcHMgcmVjb25uZWN0aW9uIGZyb20gZmlyaW5nIHR3aWNlIGZvciB0aGUgc2FtZSByZWNvbm5lY3Rpb24gbG9vcFxuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQgYHNvY2tldGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9uYWwsIGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9wZW4gPVxuTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChmbiwgb3B0cykge1xuICBkZWJ1ZygncmVhZHlTdGF0ZSAlcycsIHRoaXMucmVhZHlTdGF0ZSk7XG4gIGlmICh+dGhpcy5yZWFkeVN0YXRlLmluZGV4T2YoJ29wZW4nKSkgcmV0dXJuIHRoaXM7XG5cbiAgZGVidWcoJ29wZW5pbmcgJXMnLCB0aGlzLnVyaSk7XG4gIHRoaXMuZW5naW5lID0gZWlvKHRoaXMudXJpLCB0aGlzLm9wdHMpO1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuICB0aGlzLnNraXBSZWNvbm5lY3QgPSBmYWxzZTtcblxuICAvLyBlbWl0IGBvcGVuYFxuICB2YXIgb3BlblN1YiA9IG9uKHNvY2tldCwgJ29wZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbm9wZW4oKTtcbiAgICBmbiAmJiBmbigpO1xuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X2Vycm9yYFxuICB2YXIgZXJyb3JTdWIgPSBvbihzb2NrZXQsICdlcnJvcicsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGVidWcoJ2Nvbm5lY3RfZXJyb3InKTtcbiAgICBzZWxmLmNsZWFudXAoKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfZXJyb3InLCBkYXRhKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gZXJyb3InKTtcbiAgICAgIGVyci5kYXRhID0gZGF0YTtcbiAgICAgIGZuKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9ubHkgZG8gdGhpcyBpZiB0aGVyZSBpcyBubyBmbiB0byBoYW5kbGUgdGhlIGVycm9yXG4gICAgICBzZWxmLm1heWJlUmVjb25uZWN0T25PcGVuKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X3RpbWVvdXRgXG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fdGltZW91dCkge1xuICAgIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcbiAgICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHdpbGwgdGltZW91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuXG4gICAgLy8gc2V0IHRpbWVyXG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHRpbWVkIG91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuICAgICAgb3BlblN1Yi5kZXN0cm95KCk7XG4gICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgIHNvY2tldC5lbWl0KCdlcnJvcicsICd0aW1lb3V0Jyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfdGltZW91dCcsIHRpbWVvdXQpO1xuICAgIH0sIHRpbWVvdXQpO1xuXG4gICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdGhpcy5zdWJzLnB1c2gob3BlblN1Yik7XG4gIHRoaXMuc3Vicy5wdXNoKGVycm9yU3ViKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IG9wZW4uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1Zygnb3BlbicpO1xuXG4gIC8vIGNsZWFyIG9sZCBzdWJzXG4gIHRoaXMuY2xlYW51cCgpO1xuXG4gIC8vIG1hcmsgYXMgb3BlblxuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuXG4gIC8vIGFkZCBuZXcgc3Vic1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2RhdGEnLCBiaW5kKHRoaXMsICdvbmRhdGEnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdwaW5nJywgYmluZCh0aGlzLCAnb25waW5nJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAncG9uZycsIGJpbmQodGhpcywgJ29ucG9uZycpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Vycm9yJywgYmluZCh0aGlzLCAnb25lcnJvcicpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHRoaXMuZGVjb2RlciwgJ2RlY29kZWQnLCBiaW5kKHRoaXMsICdvbmRlY29kZWQnKSkpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHBpbmcuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25waW5nID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxhc3RQaW5nID0gbmV3IERhdGUoKTtcbiAgdGhpcy5lbWl0QWxsKCdwaW5nJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucG9uZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0QWxsKCdwb25nJywgbmV3IERhdGUoKSAtIHRoaXMubGFzdFBpbmcpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZGVjb2Rlci5hZGQoZGF0YSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHBhcnNlciBmdWxseSBkZWNvZGVzIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGVjb2RlZCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzb2NrZXQgZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgZGVidWcoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5lbWl0QWxsKCdlcnJvcicsIGVycik7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgc29ja2V0IGZvciB0aGUgZ2l2ZW4gYG5zcGAuXG4gKlxuICogQHJldHVybiB7U29ja2V0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5zb2NrZXQgPSBmdW5jdGlvbiAobnNwLCBvcHRzKSB7XG4gIHZhciBzb2NrZXQgPSB0aGlzLm5zcHNbbnNwXTtcbiAgaWYgKCFzb2NrZXQpIHtcbiAgICBzb2NrZXQgPSBuZXcgU29ja2V0KHRoaXMsIG5zcCwgb3B0cyk7XG4gICAgdGhpcy5uc3BzW25zcF0gPSBzb2NrZXQ7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNvY2tldC5vbignY29ubmVjdGluZycsIG9uQ29ubmVjdGluZyk7XG4gICAgc29ja2V0Lm9uKCdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgc29ja2V0LmlkID0gc2VsZi5nZW5lcmF0ZUlkKG5zcCk7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5hdXRvQ29ubmVjdCkge1xuICAgICAgLy8gbWFudWFsbHkgY2FsbCBoZXJlIHNpbmNlIGNvbm5lY3RpbmcgZXZlbnQgaXMgZmlyZWQgYmVmb3JlIGxpc3RlbmluZ1xuICAgICAgb25Db25uZWN0aW5nKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Db25uZWN0aW5nICgpIHtcbiAgICBpZiAoIX5pbmRleE9mKHNlbGYuY29ubmVjdGluZywgc29ja2V0KSkge1xuICAgICAgc2VsZi5jb25uZWN0aW5nLnB1c2goc29ja2V0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc29ja2V0O1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNvY2tldCBjbG9zZS5cbiAqXG4gKiBAcGFyYW0ge1NvY2tldH0gc29ja2V0XG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChzb2NrZXQpIHtcbiAgdmFyIGluZGV4ID0gaW5kZXhPZih0aGlzLmNvbm5lY3RpbmcsIHNvY2tldCk7XG4gIGlmICh+aW5kZXgpIHRoaXMuY29ubmVjdGluZy5zcGxpY2UoaW5kZXgsIDEpO1xuICBpZiAodGhpcy5jb25uZWN0aW5nLmxlbmd0aCkgcmV0dXJuO1xuXG4gIHRoaXMuY2xvc2UoKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgZGVidWcoJ3dyaXRpbmcgcGFja2V0ICVqJywgcGFja2V0KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAocGFja2V0LnF1ZXJ5ICYmIHBhY2tldC50eXBlID09PSAwKSBwYWNrZXQubnNwICs9ICc/JyArIHBhY2tldC5xdWVyeTtcblxuICBpZiAoIXNlbGYuZW5jb2RpbmcpIHtcbiAgICAvLyBlbmNvZGUsIHRoZW4gd3JpdGUgdG8gZW5naW5lIHdpdGggcmVzdWx0XG4gICAgc2VsZi5lbmNvZGluZyA9IHRydWU7XG4gICAgdGhpcy5lbmNvZGVyLmVuY29kZShwYWNrZXQsIGZ1bmN0aW9uIChlbmNvZGVkUGFja2V0cykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGVkUGFja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLmVuZ2luZS53cml0ZShlbmNvZGVkUGFja2V0c1tpXSwgcGFja2V0Lm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgc2VsZi5lbmNvZGluZyA9IGZhbHNlO1xuICAgICAgc2VsZi5wcm9jZXNzUGFja2V0UXVldWUoKTtcbiAgICB9KTtcbiAgfSBlbHNlIHsgLy8gYWRkIHBhY2tldCB0byB0aGUgcXVldWVcbiAgICBzZWxmLnBhY2tldEJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIH1cbn07XG5cbi8qKlxuICogSWYgcGFja2V0IGJ1ZmZlciBpcyBub24tZW1wdHksIGJlZ2lucyBlbmNvZGluZyB0aGVcbiAqIG5leHQgcGFja2V0IGluIGxpbmUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucHJvY2Vzc1BhY2tldFF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5wYWNrZXRCdWZmZXIubGVuZ3RoID4gMCAmJiAhdGhpcy5lbmNvZGluZykge1xuICAgIHZhciBwYWNrID0gdGhpcy5wYWNrZXRCdWZmZXIuc2hpZnQoKTtcbiAgICB0aGlzLnBhY2tldChwYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCB0cmFuc3BvcnQgc3Vic2NyaXB0aW9ucyBhbmQgcGFja2V0IGJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2xlYW51cCcpO1xuXG4gIHZhciBzdWJzTGVuZ3RoID0gdGhpcy5zdWJzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzTGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3ViID0gdGhpcy5zdWJzLnNoaWZ0KCk7XG4gICAgc3ViLmRlc3Ryb3koKTtcbiAgfVxuXG4gIHRoaXMucGFja2V0QnVmZmVyID0gW107XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcbiAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG5cbiAgdGhpcy5kZWNvZGVyLmRlc3Ryb3koKTtcbn07XG5cbi8qKlxuICogQ2xvc2UgdGhlIGN1cnJlbnQgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmNsb3NlID1cbk1hbmFnZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdkaXNjb25uZWN0Jyk7XG4gIHRoaXMuc2tpcFJlY29ubmVjdCA9IHRydWU7XG4gIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIC8vIGBvbmNsb3NlYCB3aWxsIG5vdCBmaXJlIGJlY2F1c2VcbiAgICAvLyBhbiBvcGVuIGV2ZW50IG5ldmVyIGhhcHBlbmVkXG4gICAgdGhpcy5jbGVhbnVwKCk7XG4gIH1cbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICBpZiAodGhpcy5lbmdpbmUpIHRoaXMuZW5naW5lLmNsb3NlKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICBkZWJ1Zygnb25jbG9zZScpO1xuXG4gIHRoaXMuY2xlYW51cCgpO1xuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCByZWFzb24pO1xuXG4gIGlmICh0aGlzLl9yZWNvbm5lY3Rpb24gJiYgIXRoaXMuc2tpcFJlY29ubmVjdCkge1xuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogQXR0ZW1wdCBhIHJlY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnJlY29ubmVjdGluZyB8fCB0aGlzLnNraXBSZWNvbm5lY3QpIHJldHVybiB0aGlzO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy5iYWNrb2ZmLmF0dGVtcHRzID49IHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzKSB7XG4gICAgZGVidWcoJ3JlY29ubmVjdCBmYWlsZWQnKTtcbiAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICB0aGlzLmVtaXRBbGwoJ3JlY29ubmVjdF9mYWlsZWQnKTtcbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHZhciBkZWxheSA9IHRoaXMuYmFja29mZi5kdXJhdGlvbigpO1xuICAgIGRlYnVnKCd3aWxsIHdhaXQgJWRtcyBiZWZvcmUgcmVjb25uZWN0IGF0dGVtcHQnLCBkZWxheSk7XG5cbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IHRydWU7XG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KSByZXR1cm47XG5cbiAgICAgIGRlYnVnKCdhdHRlbXB0aW5nIHJlY29ubmVjdCcpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RfYXR0ZW1wdCcsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdGluZycsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG5cbiAgICAgIC8vIGNoZWNrIGFnYWluIGZvciB0aGUgY2FzZSBzb2NrZXQgY2xvc2VkIGluIGFib3ZlIGV2ZW50c1xuICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXG4gICAgICBzZWxmLm9wZW4oZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZGVidWcoJ3JlY29ubmVjdCBhdHRlbXB0IGVycm9yJyk7XG4gICAgICAgICAgc2VsZi5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLnJlY29ubmVjdCgpO1xuICAgICAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2Vycm9yJywgZXJyLmRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdyZWNvbm5lY3Qgc3VjY2VzcycpO1xuICAgICAgICAgIHNlbGYub25yZWNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgZGVsYXkpO1xuXG4gICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXR0ZW1wdCA9IHRoaXMuYmFja29mZi5hdHRlbXB0cztcbiAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMudXBkYXRlU29ja2V0SWRzKCk7XG4gIHRoaXMuZW1pdEFsbCgncmVjb25uZWN0JywgYXR0ZW1wdCk7XG59O1xuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gb247XG5cbi8qKlxuICogSGVscGVyIGZvciBzdWJzY3JpcHRpb25zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEV2ZW50RW1pdHRlcn0gb2JqIHdpdGggYEVtaXR0ZXJgIG1peGluIG9yIGBFdmVudEVtaXR0ZXJgXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gb24gKG9iaiwgZXYsIGZuKSB7XG4gIG9iai5vbihldiwgZm4pO1xuICByZXR1cm4ge1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgIG9iai5yZW1vdmVMaXN0ZW5lcihldiwgZm4pO1xuICAgIH1cbiAgfTtcbn1cbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgdG9BcnJheSA9IHJlcXVpcmUoJ3RvLWFycmF5Jyk7XG52YXIgb24gPSByZXF1aXJlKCcuL29uJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1iaW5kJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50OnNvY2tldCcpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG52YXIgaGFzQmluID0gcmVxdWlyZSgnaGFzLWJpbmFyeTInKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBTb2NrZXQ7XG5cbi8qKlxuICogSW50ZXJuYWwgZXZlbnRzIChibGFja2xpc3RlZCkuXG4gKiBUaGVzZSBldmVudHMgY2FuJ3QgYmUgZW1pdHRlZCBieSB0aGUgdXNlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgZXZlbnRzID0ge1xuICBjb25uZWN0OiAxLFxuICBjb25uZWN0X2Vycm9yOiAxLFxuICBjb25uZWN0X3RpbWVvdXQ6IDEsXG4gIGNvbm5lY3Rpbmc6IDEsXG4gIGRpc2Nvbm5lY3Q6IDEsXG4gIGVycm9yOiAxLFxuICByZWNvbm5lY3Q6IDEsXG4gIHJlY29ubmVjdF9hdHRlbXB0OiAxLFxuICByZWNvbm5lY3RfZmFpbGVkOiAxLFxuICByZWNvbm5lY3RfZXJyb3I6IDEsXG4gIHJlY29ubmVjdGluZzogMSxcbiAgcGluZzogMSxcbiAgcG9uZzogMVxufTtcblxuLyoqXG4gKiBTaG9ydGN1dCB0byBgRW1pdHRlciNlbWl0YC5cbiAqL1xuXG52YXIgZW1pdCA9IEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ7XG5cbi8qKlxuICogYFNvY2tldGAgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTb2NrZXQgKGlvLCBuc3AsIG9wdHMpIHtcbiAgdGhpcy5pbyA9IGlvO1xuICB0aGlzLm5zcCA9IG5zcDtcbiAgdGhpcy5qc29uID0gdGhpczsgLy8gY29tcGF0XG4gIHRoaXMuaWRzID0gMDtcbiAgdGhpcy5hY2tzID0ge307XG4gIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuICB0aGlzLmZsYWdzID0ge307XG4gIGlmIChvcHRzICYmIG9wdHMucXVlcnkpIHtcbiAgICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeTtcbiAgfVxuICBpZiAodGhpcy5pby5hdXRvQ29ubmVjdCkgdGhpcy5vcGVuKCk7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFN1YnNjcmliZSB0byBvcGVuLCBjbG9zZSBhbmQgcGFja2V0IGV2ZW50c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc3ViRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zdWJzKSByZXR1cm47XG5cbiAgdmFyIGlvID0gdGhpcy5pbztcbiAgdGhpcy5zdWJzID0gW1xuICAgIG9uKGlvLCAnb3BlbicsIGJpbmQodGhpcywgJ29ub3BlbicpKSxcbiAgICBvbihpbywgJ3BhY2tldCcsIGJpbmQodGhpcywgJ29ucGFja2V0JykpLFxuICAgIG9uKGlvLCAnY2xvc2UnLCBiaW5kKHRoaXMsICdvbmNsb3NlJykpXG4gIF07XG59O1xuXG4vKipcbiAqIFwiT3BlbnNcIiB0aGUgc29ja2V0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vcGVuID1cblNvY2tldC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY29ubmVjdGVkKSByZXR1cm4gdGhpcztcblxuICB0aGlzLnN1YkV2ZW50cygpO1xuICB0aGlzLmlvLm9wZW4oKTsgLy8gZW5zdXJlIG9wZW5cbiAgaWYgKCdvcGVuJyA9PT0gdGhpcy5pby5yZWFkeVN0YXRlKSB0aGlzLm9ub3BlbigpO1xuICB0aGlzLmVtaXQoJ2Nvbm5lY3RpbmcnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50LlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICBhcmdzLnVuc2hpZnQoJ21lc3NhZ2UnKTtcbiAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgYGVtaXRgLlxuICogSWYgdGhlIGV2ZW50IGlzIGluIGBldmVudHNgLCBpdCdzIGVtaXR0ZWQgbm9ybWFsbHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXYpIHtcbiAgaWYgKGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldikpIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgdmFyIHBhY2tldCA9IHtcbiAgICB0eXBlOiAodGhpcy5mbGFncy5iaW5hcnkgIT09IHVuZGVmaW5lZCA/IHRoaXMuZmxhZ3MuYmluYXJ5IDogaGFzQmluKGFyZ3MpKSA/IHBhcnNlci5CSU5BUllfRVZFTlQgOiBwYXJzZXIuRVZFTlQsXG4gICAgZGF0YTogYXJnc1xuICB9O1xuXG4gIHBhY2tldC5vcHRpb25zID0ge307XG4gIHBhY2tldC5vcHRpb25zLmNvbXByZXNzID0gIXRoaXMuZmxhZ3MgfHwgZmFsc2UgIT09IHRoaXMuZmxhZ3MuY29tcHJlc3M7XG5cbiAgLy8gZXZlbnQgYWNrIGNhbGxiYWNrXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdKSB7XG4gICAgZGVidWcoJ2VtaXR0aW5nIHBhY2tldCB3aXRoIGFjayBpZCAlZCcsIHRoaXMuaWRzKTtcbiAgICB0aGlzLmFja3NbdGhpcy5pZHNdID0gYXJncy5wb3AoKTtcbiAgICBwYWNrZXQuaWQgPSB0aGlzLmlkcysrO1xuICB9XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgdGhpcy5wYWNrZXQocGFja2V0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNlbmRCdWZmZXIucHVzaChwYWNrZXQpO1xuICB9XG5cbiAgdGhpcy5mbGFncyA9IHt9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgcGFja2V0Lm5zcCA9IHRoaXMubnNwO1xuICB0aGlzLmlvLnBhY2tldChwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgYG9wZW5gLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygndHJhbnNwb3J0IGlzIG9wZW4gLSBjb25uZWN0aW5nJyk7XG5cbiAgLy8gd3JpdGUgY29ubmVjdCBwYWNrZXQgaWYgbmVjZXNzYXJ5XG4gIGlmICgnLycgIT09IHRoaXMubnNwKSB7XG4gICAgaWYgKHRoaXMucXVlcnkpIHtcbiAgICAgIHZhciBxdWVyeSA9IHR5cGVvZiB0aGlzLnF1ZXJ5ID09PSAnb2JqZWN0JyA/IHBhcnNlcXMuZW5jb2RlKHRoaXMucXVlcnkpIDogdGhpcy5xdWVyeTtcbiAgICAgIGRlYnVnKCdzZW5kaW5nIGNvbm5lY3QgcGFja2V0IHdpdGggcXVlcnkgJXMnLCBxdWVyeSk7XG4gICAgICB0aGlzLnBhY2tldCh7dHlwZTogcGFyc2VyLkNPTk5FQ1QsIHF1ZXJ5OiBxdWVyeX0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhY2tldCh7dHlwZTogcGFyc2VyLkNPTk5FQ1R9KTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGBjbG9zZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlYXNvblxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICBkZWJ1ZygnY2xvc2UgKCVzKScsIHJlYXNvbik7XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgZGVsZXRlIHRoaXMuaWQ7XG4gIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcsIHJlYXNvbik7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIHNvY2tldCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbnBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdmFyIHNhbWVOYW1lc3BhY2UgPSBwYWNrZXQubnNwID09PSB0aGlzLm5zcDtcbiAgdmFyIHJvb3ROYW1lc3BhY2VFcnJvciA9IHBhY2tldC50eXBlID09PSBwYXJzZXIuRVJST1IgJiYgcGFja2V0Lm5zcCA9PT0gJy8nO1xuXG4gIGlmICghc2FtZU5hbWVzcGFjZSAmJiAhcm9vdE5hbWVzcGFjZUVycm9yKSByZXR1cm47XG5cbiAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgIGNhc2UgcGFyc2VyLkNPTk5FQ1Q6XG4gICAgICB0aGlzLm9uY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5FVkVOVDpcbiAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfRVZFTlQ6XG4gICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5ESVNDT05ORUNUOlxuICAgICAgdGhpcy5vbmRpc2Nvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRVJST1I6XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgcGFja2V0LmRhdGEpO1xuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmV2ZW50ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB2YXIgYXJncyA9IHBhY2tldC5kYXRhIHx8IFtdO1xuICBkZWJ1ZygnZW1pdHRpbmcgZXZlbnQgJWonLCBhcmdzKTtcblxuICBpZiAobnVsbCAhPSBwYWNrZXQuaWQpIHtcbiAgICBkZWJ1ZygnYXR0YWNoaW5nIGFjayBjYWxsYmFjayB0byBldmVudCcpO1xuICAgIGFyZ3MucHVzaCh0aGlzLmFjayhwYWNrZXQuaWQpKTtcbiAgfVxuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIGVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yZWNlaXZlQnVmZmVyLnB1c2goYXJncyk7XG4gIH1cbn07XG5cbi8qKlxuICogUHJvZHVjZXMgYW4gYWNrIGNhbGxiYWNrIHRvIGVtaXQgd2l0aCBhbiBldmVudC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmFjayA9IGZ1bmN0aW9uIChpZCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzZW50ID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcHJldmVudCBkb3VibGUgY2FsbGJhY2tzXG4gICAgaWYgKHNlbnQpIHJldHVybjtcbiAgICBzZW50ID0gdHJ1ZTtcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICBkZWJ1Zygnc2VuZGluZyBhY2sgJWonLCBhcmdzKTtcblxuICAgIHNlbGYucGFja2V0KHtcbiAgICAgIHR5cGU6IGhhc0JpbihhcmdzKSA/IHBhcnNlci5CSU5BUllfQUNLIDogcGFyc2VyLkFDSyxcbiAgICAgIGlkOiBpZCxcbiAgICAgIGRhdGE6IGFyZ3NcbiAgICB9KTtcbiAgfTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgYWNrbm93bGVnZW1lbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmFjayA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdmFyIGFjayA9IHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGFjaykge1xuICAgIGRlYnVnKCdjYWxsaW5nIGFjayAlcyB3aXRoICVqJywgcGFja2V0LmlkLCBwYWNrZXQuZGF0YSk7XG4gICAgYWNrLmFwcGx5KHRoaXMsIHBhY2tldC5kYXRhKTtcbiAgICBkZWxldGUgdGhpcy5hY2tzW3BhY2tldC5pZF07XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoJ2JhZCBhY2sgJXMnLCBwYWNrZXQuaWQpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNlcnZlciBjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZW1pdCgnY29ubmVjdCcpO1xuICB0aGlzLmVtaXRCdWZmZXJlZCgpO1xufTtcblxuLyoqXG4gKiBFbWl0IGJ1ZmZlcmVkIGV2ZW50cyAocmVjZWl2ZWQgYW5kIGVtaXR0ZWQpLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZW1pdEJ1ZmZlcmVkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMucmVjZWl2ZUJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIGVtaXQuYXBwbHkodGhpcywgdGhpcy5yZWNlaXZlQnVmZmVyW2ldKTtcbiAgfVxuICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zZW5kQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5wYWNrZXQodGhpcy5zZW5kQnVmZmVyW2ldKTtcbiAgfVxuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc2VydmVyIGRpc2Nvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdzZXJ2ZXIgZGlzY29ubmVjdCAoJXMpJywgdGhpcy5uc3ApO1xuICB0aGlzLmRlc3Ryb3koKTtcbiAgdGhpcy5vbmNsb3NlKCdpbyBzZXJ2ZXIgZGlzY29ubmVjdCcpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBmb3JjZWQgY2xpZW50L3NlcnZlciBzaWRlIGRpc2Nvbm5lY3Rpb25zLFxuICogdGhpcyBtZXRob2QgZW5zdXJlcyB0aGUgbWFuYWdlciBzdG9wcyB0cmFja2luZyB1cyBhbmRcbiAqIHRoYXQgcmVjb25uZWN0aW9ucyBkb24ndCBnZXQgdHJpZ2dlcmVkIGZvciB0aGlzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZS5cbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnN1YnMpIHtcbiAgICAvLyBjbGVhbiBzdWJzY3JpcHRpb25zIHRvIGF2b2lkIHJlY29ubmVjdGlvbnNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3Vicy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5zdWJzW2ldLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5zdWJzID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMuaW8uZGVzdHJveSh0aGlzKTtcbn07XG5cbi8qKlxuICogRGlzY29ubmVjdHMgdGhlIHNvY2tldCBtYW51YWxseS5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9XG5Tb2NrZXQucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIGRlYnVnKCdwZXJmb3JtaW5nIGRpc2Nvbm5lY3QgKCVzKScsIHRoaXMubnNwKTtcbiAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlci5ESVNDT05ORUNUIH0pO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHNvY2tldCBmcm9tIHBvb2xcbiAgdGhpcy5kZXN0cm95KCk7XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgLy8gZmlyZSBldmVudHNcbiAgICB0aGlzLm9uY2xvc2UoJ2lvIGNsaWVudCBkaXNjb25uZWN0Jyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGNvbXByZXNzIGZsYWcuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBpZiBgdHJ1ZWAsIGNvbXByZXNzZXMgdGhlIHNlbmRpbmcgZGF0YVxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuY29tcHJlc3MgPSBmdW5jdGlvbiAoY29tcHJlc3MpIHtcbiAgdGhpcy5mbGFncy5jb21wcmVzcyA9IGNvbXByZXNzO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgYmluYXJ5IGZsYWdcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHdoZXRoZXIgdGhlIGVtaXR0ZWQgZGF0YSBjb250YWlucyBiaW5hcnlcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmJpbmFyeSA9IGZ1bmN0aW9uIChiaW5hcnkpIHtcbiAgdGhpcy5mbGFncy5iaW5hcnkgPSBiaW5hcnk7XG4gIHJldHVybiB0aGlzO1xufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXVyaSA9IHJlcXVpcmUoJ3BhcnNldXJpJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50OnVybCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gdXJsO1xuXG4vKipcbiAqIFVSTCBwYXJzZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtPYmplY3R9IEFuIG9iamVjdCBtZWFudCB0byBtaW1pYyB3aW5kb3cubG9jYXRpb24uXG4gKiAgICAgICAgICAgICAgICAgRGVmYXVsdHMgdG8gd2luZG93LmxvY2F0aW9uLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiB1cmwgKHVyaSwgbG9jKSB7XG4gIHZhciBvYmogPSB1cmk7XG5cbiAgLy8gZGVmYXVsdCB0byB3aW5kb3cubG9jYXRpb25cbiAgbG9jID0gbG9jIHx8IGdsb2JhbC5sb2NhdGlvbjtcbiAgaWYgKG51bGwgPT0gdXJpKSB1cmkgPSBsb2MucHJvdG9jb2wgKyAnLy8nICsgbG9jLmhvc3Q7XG5cbiAgLy8gcmVsYXRpdmUgcGF0aCBzdXBwb3J0XG4gIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHVyaSkge1xuICAgIGlmICgnLycgPT09IHVyaS5jaGFyQXQoMCkpIHtcbiAgICAgIGlmICgnLycgPT09IHVyaS5jaGFyQXQoMSkpIHtcbiAgICAgICAgdXJpID0gbG9jLnByb3RvY29sICsgdXJpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJpID0gbG9jLmhvc3QgKyB1cmk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEvXihodHRwcz98d3NzPyk6XFwvXFwvLy50ZXN0KHVyaSkpIHtcbiAgICAgIGRlYnVnKCdwcm90b2NvbC1sZXNzIHVybCAlcycsIHVyaSk7XG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBsb2MpIHtcbiAgICAgICAgdXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIHVyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVyaSA9ICdodHRwczovLycgKyB1cmk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcGFyc2VcbiAgICBkZWJ1ZygncGFyc2UgJXMnLCB1cmkpO1xuICAgIG9iaiA9IHBhcnNldXJpKHVyaSk7XG4gIH1cblxuICAvLyBtYWtlIHN1cmUgd2UgdHJlYXQgYGxvY2FsaG9zdDo4MGAgYW5kIGBsb2NhbGhvc3RgIGVxdWFsbHlcbiAgaWYgKCFvYmoucG9ydCkge1xuICAgIGlmICgvXihodHRwfHdzKSQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuICAgICAgb2JqLnBvcnQgPSAnODAnO1xuICAgIH0gZWxzZSBpZiAoL14oaHR0cHx3cylzJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG4gICAgICBvYmoucG9ydCA9ICc0NDMnO1xuICAgIH1cbiAgfVxuXG4gIG9iai5wYXRoID0gb2JqLnBhdGggfHwgJy8nO1xuXG4gIHZhciBpcHY2ID0gb2JqLmhvc3QuaW5kZXhPZignOicpICE9PSAtMTtcbiAgdmFyIGhvc3QgPSBpcHY2ID8gJ1snICsgb2JqLmhvc3QgKyAnXScgOiBvYmouaG9zdDtcblxuICAvLyBkZWZpbmUgdW5pcXVlIGlkXG4gIG9iai5pZCA9IG9iai5wcm90b2NvbCArICc6Ly8nICsgaG9zdCArICc6JyArIG9iai5wb3J0O1xuICAvLyBkZWZpbmUgaHJlZlxuICBvYmouaHJlZiA9IG9iai5wcm90b2NvbCArICc6Ly8nICsgaG9zdCArIChsb2MgJiYgbG9jLnBvcnQgPT09IG9iai5wb3J0ID8gJycgOiAoJzonICsgb2JqLnBvcnQpKTtcblxuICByZXR1cm4gb2JqO1xufVxuIiwiLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnIzAwMDBDQycsICcjMDAwMEZGJywgJyMwMDMzQ0MnLCAnIzAwMzNGRicsICcjMDA2NkNDJywgJyMwMDY2RkYnLCAnIzAwOTlDQycsXG4gICcjMDA5OUZGJywgJyMwMENDMDAnLCAnIzAwQ0MzMycsICcjMDBDQzY2JywgJyMwMENDOTknLCAnIzAwQ0NDQycsICcjMDBDQ0ZGJyxcbiAgJyMzMzAwQ0MnLCAnIzMzMDBGRicsICcjMzMzM0NDJywgJyMzMzMzRkYnLCAnIzMzNjZDQycsICcjMzM2NkZGJywgJyMzMzk5Q0MnLFxuICAnIzMzOTlGRicsICcjMzNDQzAwJywgJyMzM0NDMzMnLCAnIzMzQ0M2NicsICcjMzNDQzk5JywgJyMzM0NDQ0MnLCAnIzMzQ0NGRicsXG4gICcjNjYwMENDJywgJyM2NjAwRkYnLCAnIzY2MzNDQycsICcjNjYzM0ZGJywgJyM2NkNDMDAnLCAnIzY2Q0MzMycsICcjOTkwMENDJyxcbiAgJyM5OTAwRkYnLCAnIzk5MzNDQycsICcjOTkzM0ZGJywgJyM5OUNDMDAnLCAnIzk5Q0MzMycsICcjQ0MwMDAwJywgJyNDQzAwMzMnLFxuICAnI0NDMDA2NicsICcjQ0MwMDk5JywgJyNDQzAwQ0MnLCAnI0NDMDBGRicsICcjQ0MzMzAwJywgJyNDQzMzMzMnLCAnI0NDMzM2NicsXG4gICcjQ0MzMzk5JywgJyNDQzMzQ0MnLCAnI0NDMzNGRicsICcjQ0M2NjAwJywgJyNDQzY2MzMnLCAnI0NDOTkwMCcsICcjQ0M5OTMzJyxcbiAgJyNDQ0NDMDAnLCAnI0NDQ0MzMycsICcjRkYwMDAwJywgJyNGRjAwMzMnLCAnI0ZGMDA2NicsICcjRkYwMDk5JywgJyNGRjAwQ0MnLFxuICAnI0ZGMDBGRicsICcjRkYzMzAwJywgJyNGRjMzMzMnLCAnI0ZGMzM2NicsICcjRkYzMzk5JywgJyNGRjMzQ0MnLCAnI0ZGMzNGRicsXG4gICcjRkY2NjAwJywgJyNGRjY2MzMnLCAnI0ZGOTkwMCcsICcjRkY5OTMzJywgJyNGRkNDMDAnLCAnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcbiAgcmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG4gICAgLy8gZG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVyci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybjtcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpXG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuXG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cbiIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnWydkZWZhdWx0J10gPSBjcmVhdGVEZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIEFjdGl2ZSBgZGVidWdgIGluc3RhbmNlcy5cbiAqL1xuZXhwb3J0cy5pbnN0YW5jZXMgPSBbXTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICB2YXIgaGFzaCA9IDAsIGk7XG5cbiAgZm9yIChpIGluIG5hbWVzcGFjZSkge1xuICAgIGhhc2ggID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW01hdGguYWJzKGhhc2gpICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cbiAgdmFyIHByZXZUaW1lO1xuXG4gIGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgIC8vIGRpc2FibGVkP1xuICAgIGlmICghZGVidWcuZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgdmFyIHNlbGYgPSBkZWJ1ZztcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gdHVybiB0aGUgYGFyZ3VtZW50c2AgaW50byBhIHByb3BlciBBcnJheVxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG4gICAgICBpbmRleCsrO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG5cbiAgICAvLyBhcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuICAgIGV4cG9ydHMuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG4gICAgdmFyIGxvZ0ZuID0gZGVidWcubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cblxuICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gIGRlYnVnLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgZGVidWcudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuICBkZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblxuICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuaW5pdCkge1xuICAgIGV4cG9ydHMuaW5pdChkZWJ1Zyk7XG4gIH1cblxuICBleHBvcnRzLmluc3RhbmNlcy5wdXNoKGRlYnVnKTtcblxuICByZXR1cm4gZGVidWc7XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3kgKCkge1xuICB2YXIgaW5kZXggPSBleHBvcnRzLmluc3RhbmNlcy5pbmRleE9mKHRoaXMpO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgZXhwb3J0cy5pbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICBleHBvcnRzLm5hbWVzID0gW107XG4gIGV4cG9ydHMuc2tpcHMgPSBbXTtcblxuICB2YXIgaTtcbiAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4cG9ydHMuaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGluc3RhbmNlID0gZXhwb3J0cy5pbnN0YW5jZXNbaV07XG4gICAgaW5zdGFuY2UuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChpbnN0YW5jZS5uYW1lc3BhY2UpO1xuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgaWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cbiIsIi8qZ2xvYmFsIEJsb2IsRmlsZSovXG5cbi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50c1xuICovXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xudmFyIGlzQnVmID0gcmVxdWlyZSgnLi9pcy1idWZmZXInKTtcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgd2l0aE5hdGl2ZUJsb2IgPSB0eXBlb2YgZ2xvYmFsLkJsb2IgPT09ICdmdW5jdGlvbicgfHwgdG9TdHJpbmcuY2FsbChnbG9iYWwuQmxvYikgPT09ICdbb2JqZWN0IEJsb2JDb25zdHJ1Y3Rvcl0nO1xudmFyIHdpdGhOYXRpdmVGaWxlID0gdHlwZW9mIGdsb2JhbC5GaWxlID09PSAnZnVuY3Rpb24nIHx8IHRvU3RyaW5nLmNhbGwoZ2xvYmFsLkZpbGUpID09PSAnW29iamVjdCBGaWxlQ29uc3RydWN0b3JdJztcblxuLyoqXG4gKiBSZXBsYWNlcyBldmVyeSBCdWZmZXIgfCBBcnJheUJ1ZmZlciBpbiBwYWNrZXQgd2l0aCBhIG51bWJlcmVkIHBsYWNlaG9sZGVyLlxuICogQW55dGhpbmcgd2l0aCBibG9icyBvciBmaWxlcyBzaG91bGQgYmUgZmVkIHRocm91Z2ggcmVtb3ZlQmxvYnMgYmVmb3JlIGNvbWluZ1xuICogaGVyZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gc29ja2V0LmlvIGV2ZW50IHBhY2tldFxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGRlY29uc3RydWN0ZWQgcGFja2V0IGFuZCBsaXN0IG9mIGJ1ZmZlcnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvbnN0cnVjdFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCkge1xuICB2YXIgYnVmZmVycyA9IFtdO1xuICB2YXIgcGFja2V0RGF0YSA9IHBhY2tldC5kYXRhO1xuICB2YXIgcGFjayA9IHBhY2tldDtcbiAgcGFjay5kYXRhID0gX2RlY29uc3RydWN0UGFja2V0KHBhY2tldERhdGEsIGJ1ZmZlcnMpO1xuICBwYWNrLmF0dGFjaG1lbnRzID0gYnVmZmVycy5sZW5ndGg7IC8vIG51bWJlciBvZiBiaW5hcnkgJ2F0dGFjaG1lbnRzJ1xuICByZXR1cm4ge3BhY2tldDogcGFjaywgYnVmZmVyczogYnVmZmVyc307XG59O1xuXG5mdW5jdGlvbiBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YSwgYnVmZmVycykge1xuICBpZiAoIWRhdGEpIHJldHVybiBkYXRhO1xuXG4gIGlmIChpc0J1ZihkYXRhKSkge1xuICAgIHZhciBwbGFjZWhvbGRlciA9IHsgX3BsYWNlaG9sZGVyOiB0cnVlLCBudW06IGJ1ZmZlcnMubGVuZ3RoIH07XG4gICAgYnVmZmVycy5wdXNoKGRhdGEpO1xuICAgIHJldHVybiBwbGFjZWhvbGRlcjtcbiAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgdmFyIG5ld0RhdGEgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgbmV3RGF0YVtpXSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldLCBidWZmZXJzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0RhdGE7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmICEoZGF0YSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgdmFyIG5ld0RhdGEgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgbmV3RGF0YVtrZXldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSwgYnVmZmVycyk7XG4gICAgfVxuICAgIHJldHVybiBuZXdEYXRhO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFJlY29uc3RydWN0cyBhIGJpbmFyeSBwYWNrZXQgZnJvbSBpdHMgcGxhY2Vob2xkZXIgcGFja2V0IGFuZCBidWZmZXJzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIGV2ZW50IHBhY2tldCB3aXRoIHBsYWNlaG9sZGVyc1xuICogQHBhcmFtIHtBcnJheX0gYnVmZmVycyAtIGJpbmFyeSBidWZmZXJzIHRvIHB1dCBpbiBwbGFjZWhvbGRlciBwb3NpdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH0gcmVjb25zdHJ1Y3RlZCBwYWNrZXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5yZWNvbnN0cnVjdFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCwgYnVmZmVycykge1xuICBwYWNrZXQuZGF0YSA9IF9yZWNvbnN0cnVjdFBhY2tldChwYWNrZXQuZGF0YSwgYnVmZmVycyk7XG4gIHBhY2tldC5hdHRhY2htZW50cyA9IHVuZGVmaW5lZDsgLy8gbm8gbG9uZ2VyIHVzZWZ1bFxuICByZXR1cm4gcGFja2V0O1xufTtcblxuZnVuY3Rpb24gX3JlY29uc3RydWN0UGFja2V0KGRhdGEsIGJ1ZmZlcnMpIHtcbiAgaWYgKCFkYXRhKSByZXR1cm4gZGF0YTtcblxuICBpZiAoZGF0YSAmJiBkYXRhLl9wbGFjZWhvbGRlcikge1xuICAgIHJldHVybiBidWZmZXJzW2RhdGEubnVtXTsgLy8gYXBwcm9wcmlhdGUgYnVmZmVyIChzaG91bGQgYmUgbmF0dXJhbCBvcmRlciBhbnl3YXkpXG4gIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YVtpXSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldLCBidWZmZXJzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgIGRhdGFba2V5XSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0sIGJ1ZmZlcnMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHJlbW92ZXMgQmxvYnMgb3IgRmlsZXMgZnJvbSBkYXRhIHZpYVxuICogRmlsZVJlYWRlcidzIHJlYWRBc0FycmF5QnVmZmVyIG1ldGhvZC4gVXNlZCBiZWZvcmUgZW5jb2RpbmdcbiAqIGRhdGEgYXMgbXNncGFjay4gQ2FsbHMgY2FsbGJhY2sgd2l0aCB0aGUgYmxvYmxlc3MgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMucmVtb3ZlQmxvYnMgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBfcmVtb3ZlQmxvYnMob2JqLCBjdXJLZXksIGNvbnRhaW5pbmdPYmplY3QpIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIG9iajtcblxuICAgIC8vIGNvbnZlcnQgYW55IGJsb2JcbiAgICBpZiAoKHdpdGhOYXRpdmVCbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICAgICh3aXRoTmF0aXZlRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKSkge1xuICAgICAgcGVuZGluZ0Jsb2JzKys7XG5cbiAgICAgIC8vIGFzeW5jIGZpbGVyZWFkZXJcbiAgICAgIHZhciBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7IC8vIHRoaXMucmVzdWx0ID09IGFycmF5YnVmZmVyXG4gICAgICAgIGlmIChjb250YWluaW5nT2JqZWN0KSB7XG4gICAgICAgICAgY29udGFpbmluZ09iamVjdFtjdXJLZXldID0gdGhpcy5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYmxvYmxlc3NEYXRhID0gdGhpcy5yZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBub3RoaW5nIHBlbmRpbmcgaXRzIGNhbGxiYWNrIHRpbWVcbiAgICAgICAgaWYoISAtLXBlbmRpbmdCbG9icykge1xuICAgICAgICAgIGNhbGxiYWNrKGJsb2JsZXNzRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIob2JqKTsgLy8gYmxvYiAtPiBhcnJheWJ1ZmZlclxuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmopKSB7IC8vIGhhbmRsZSBhcnJheVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgX3JlbW92ZUJsb2JzKG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmICFpc0J1ZihvYmopKSB7IC8vIGFuZCBvYmplY3RcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgX3JlbW92ZUJsb2JzKG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHBlbmRpbmdCbG9icyA9IDA7XG4gIHZhciBibG9ibGVzc0RhdGEgPSBkYXRhO1xuICBfcmVtb3ZlQmxvYnMoYmxvYmxlc3NEYXRhKTtcbiAgaWYgKCFwZW5kaW5nQmxvYnMpIHtcbiAgICBjYWxsYmFjayhibG9ibGVzc0RhdGEpO1xuICB9XG59O1xuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGJpbmFyeSA9IHJlcXVpcmUoJy4vYmluYXJ5Jyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbnZhciBpc0J1ZiA9IHJlcXVpcmUoJy4vaXMtYnVmZmVyJyk7XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSA0O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudHlwZXMgPSBbXG4gICdDT05ORUNUJyxcbiAgJ0RJU0NPTk5FQ1QnLFxuICAnRVZFTlQnLFxuICAnQUNLJyxcbiAgJ0VSUk9SJyxcbiAgJ0JJTkFSWV9FVkVOVCcsXG4gICdCSU5BUllfQUNLJ1xuXTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgY29ubmVjdGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkNPTk5FQ1QgPSAwO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBkaXNjb25uZWN0YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRElTQ09OTkVDVCA9IDE7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGV2ZW50YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRVZFTlQgPSAyO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBhY2tgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5BQ0sgPSAzO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBlcnJvcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVSUk9SID0gNDtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSAnYmluYXJ5IGV2ZW50J1xuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5CSU5BUllfRVZFTlQgPSA1O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBiaW5hcnkgYWNrYC4gRm9yIGFja3Mgd2l0aCBiaW5hcnkgYXJndW1lbnRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5CSU5BUllfQUNLID0gNjtcblxuLyoqXG4gKiBFbmNvZGVyIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FbmNvZGVyID0gRW5jb2RlcjtcblxuLyoqXG4gKiBEZWNvZGVyIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5EZWNvZGVyID0gRGVjb2RlcjtcblxuLyoqXG4gKiBBIHNvY2tldC5pbyBFbmNvZGVyIGluc3RhbmNlXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBFbmNvZGVyKCkge31cblxudmFyIEVSUk9SX1BBQ0tFVCA9IGV4cG9ydHMuRVJST1IgKyAnXCJlbmNvZGUgZXJyb3JcIic7XG5cbi8qKlxuICogRW5jb2RlIGEgcGFja2V0IGFzIGEgc2luZ2xlIHN0cmluZyBpZiBub24tYmluYXJ5LCBvciBhcyBhXG4gKiBidWZmZXIgc2VxdWVuY2UsIGRlcGVuZGluZyBvbiBwYWNrZXQgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gcGFja2V0IG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBmdW5jdGlvbiB0byBoYW5kbGUgZW5jb2RpbmdzIChsaWtlbHkgZW5naW5lLndyaXRlKVxuICogQHJldHVybiBDYWxscyBjYWxsYmFjayB3aXRoIEFycmF5IG9mIGVuY29kaW5nc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihvYmosIGNhbGxiYWNrKXtcbiAgZGVidWcoJ2VuY29kaW5nIHBhY2tldCAlaicsIG9iaik7XG5cbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09PSBvYmoudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT09IG9iai50eXBlKSB7XG4gICAgZW5jb2RlQXNCaW5hcnkob2JqLCBjYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVuY29kaW5nID0gZW5jb2RlQXNTdHJpbmcob2JqKTtcbiAgICBjYWxsYmFjayhbZW5jb2RpbmddKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGFzIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IGVuY29kZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFzU3RyaW5nKG9iaikge1xuXG4gIC8vIGZpcnN0IGlzIHR5cGVcbiAgdmFyIHN0ciA9ICcnICsgb2JqLnR5cGU7XG5cbiAgLy8gYXR0YWNobWVudHMgaWYgd2UgaGF2ZSB0aGVtXG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PT0gb2JqLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09PSBvYmoudHlwZSkge1xuICAgIHN0ciArPSBvYmouYXR0YWNobWVudHMgKyAnLSc7XG4gIH1cblxuICAvLyBpZiB3ZSBoYXZlIGEgbmFtZXNwYWNlIG90aGVyIHRoYW4gYC9gXG4gIC8vIHdlIGFwcGVuZCBpdCBmb2xsb3dlZCBieSBhIGNvbW1hIGAsYFxuICBpZiAob2JqLm5zcCAmJiAnLycgIT09IG9iai5uc3ApIHtcbiAgICBzdHIgKz0gb2JqLm5zcCArICcsJztcbiAgfVxuXG4gIC8vIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IHRoZSBpZFxuICBpZiAobnVsbCAhPSBvYmouaWQpIHtcbiAgICBzdHIgKz0gb2JqLmlkO1xuICB9XG5cbiAgLy8ganNvbiBkYXRhXG4gIGlmIChudWxsICE9IG9iai5kYXRhKSB7XG4gICAgdmFyIHBheWxvYWQgPSB0cnlTdHJpbmdpZnkob2JqLmRhdGEpO1xuICAgIGlmIChwYXlsb2FkICE9PSBmYWxzZSkge1xuICAgICAgc3RyICs9IHBheWxvYWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBFUlJPUl9QQUNLRVQ7XG4gICAgfVxuICB9XG5cbiAgZGVidWcoJ2VuY29kZWQgJWogYXMgJXMnLCBvYmosIHN0cik7XG4gIHJldHVybiBzdHI7XG59XG5cbmZ1bmN0aW9uIHRyeVN0cmluZ2lmeShzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RyKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGFzICdidWZmZXIgc2VxdWVuY2UnIGJ5IHJlbW92aW5nIGJsb2JzLCBhbmRcbiAqIGRlY29uc3RydWN0aW5nIHBhY2tldCBpbnRvIG9iamVjdCB3aXRoIHBsYWNlaG9sZGVycyBhbmRcbiAqIGEgbGlzdCBvZiBidWZmZXJzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge0J1ZmZlcn0gZW5jb2RlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXNCaW5hcnkob2JqLCBjYWxsYmFjaykge1xuXG4gIGZ1bmN0aW9uIHdyaXRlRW5jb2RpbmcoYmxvYmxlc3NEYXRhKSB7XG4gICAgdmFyIGRlY29uc3RydWN0aW9uID0gYmluYXJ5LmRlY29uc3RydWN0UGFja2V0KGJsb2JsZXNzRGF0YSk7XG4gICAgdmFyIHBhY2sgPSBlbmNvZGVBc1N0cmluZyhkZWNvbnN0cnVjdGlvbi5wYWNrZXQpO1xuICAgIHZhciBidWZmZXJzID0gZGVjb25zdHJ1Y3Rpb24uYnVmZmVycztcblxuICAgIGJ1ZmZlcnMudW5zaGlmdChwYWNrKTsgLy8gYWRkIHBhY2tldCBpbmZvIHRvIGJlZ2lubmluZyBvZiBkYXRhIGxpc3RcbiAgICBjYWxsYmFjayhidWZmZXJzKTsgLy8gd3JpdGUgYWxsIHRoZSBidWZmZXJzXG4gIH1cblxuICBiaW5hcnkucmVtb3ZlQmxvYnMob2JqLCB3cml0ZUVuY29kaW5nKTtcbn1cblxuLyoqXG4gKiBBIHNvY2tldC5pbyBEZWNvZGVyIGluc3RhbmNlXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBkZWNvZGVyXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIERlY29kZXIoKSB7XG4gIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYCB3aXRoIERlY29kZXIuXG4gKi9cblxuRW1pdHRlcihEZWNvZGVyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogRGVjb2RlcyBhbiBlY29kZWQgcGFja2V0IHN0cmluZyBpbnRvIHBhY2tldCBKU09OLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvYmogLSBlbmNvZGVkIHBhY2tldFxuICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRGVjb2Rlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ob2JqKSB7XG4gIHZhciBwYWNrZXQ7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIHBhY2tldCA9IGRlY29kZVN0cmluZyhvYmopO1xuICAgIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PT0gcGFja2V0LnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09PSBwYWNrZXQudHlwZSkgeyAvLyBiaW5hcnkgcGFja2V0J3MganNvblxuICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbmV3IEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KTtcblxuICAgICAgLy8gbm8gYXR0YWNobWVudHMsIGxhYmVsZWQgYmluYXJ5IGJ1dCBubyBiaW5hcnkgZGF0YSB0byBmb2xsb3dcbiAgICAgIGlmICh0aGlzLnJlY29uc3RydWN0b3IucmVjb25QYWNrLmF0dGFjaG1lbnRzID09PSAwKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gbm9uLWJpbmFyeSBmdWxsIHBhY2tldFxuICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoaXNCdWYob2JqKSB8fCBvYmouYmFzZTY0KSB7IC8vIHJhdyBiaW5hcnkgZGF0YVxuICAgIGlmICghdGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dvdCBiaW5hcnkgZGF0YSB3aGVuIG5vdCByZWNvbnN0cnVjdGluZyBhIHBhY2tldCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWNrZXQgPSB0aGlzLnJlY29uc3RydWN0b3IudGFrZUJpbmFyeURhdGEob2JqKTtcbiAgICAgIGlmIChwYWNrZXQpIHsgLy8gcmVjZWl2ZWQgZmluYWwgYnVmZmVyXG4gICAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlOiAnICsgb2JqKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZWNvZGUgYSBwYWNrZXQgU3RyaW5nIChKU09OIGRhdGEpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGRlY29kZVN0cmluZyhzdHIpIHtcbiAgdmFyIGkgPSAwO1xuICAvLyBsb29rIHVwIHR5cGVcbiAgdmFyIHAgPSB7XG4gICAgdHlwZTogTnVtYmVyKHN0ci5jaGFyQXQoMCkpXG4gIH07XG5cbiAgaWYgKG51bGwgPT0gZXhwb3J0cy50eXBlc1twLnR5cGVdKSB7XG4gICAgcmV0dXJuIGVycm9yKCd1bmtub3duIHBhY2tldCB0eXBlICcgKyBwLnR5cGUpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBhdHRhY2htZW50cyBpZiB0eXBlIGJpbmFyeVxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT09IHAudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT09IHAudHlwZSkge1xuICAgIHZhciBidWYgPSAnJztcbiAgICB3aGlsZSAoc3RyLmNoYXJBdCgrK2kpICE9PSAnLScpIHtcbiAgICAgIGJ1ZiArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICAgIGlmIChidWYgIT0gTnVtYmVyKGJ1ZikgfHwgc3RyLmNoYXJBdChpKSAhPT0gJy0nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgYXR0YWNobWVudHMnKTtcbiAgICB9XG4gICAgcC5hdHRhY2htZW50cyA9IE51bWJlcihidWYpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBuYW1lc3BhY2UgKGlmIGFueSlcbiAgaWYgKCcvJyA9PT0gc3RyLmNoYXJBdChpICsgMSkpIHtcbiAgICBwLm5zcCA9ICcnO1xuICAgIHdoaWxlICgrK2kpIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmICgnLCcgPT09IGMpIGJyZWFrO1xuICAgICAgcC5uc3AgKz0gYztcbiAgICAgIGlmIChpID09PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcC5uc3AgPSAnLyc7XG4gIH1cblxuICAvLyBsb29rIHVwIGlkXG4gIHZhciBuZXh0ID0gc3RyLmNoYXJBdChpICsgMSk7XG4gIGlmICgnJyAhPT0gbmV4dCAmJiBOdW1iZXIobmV4dCkgPT0gbmV4dCkge1xuICAgIHAuaWQgPSAnJztcbiAgICB3aGlsZSAoKytpKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAobnVsbCA9PSBjIHx8IE51bWJlcihjKSAhPSBjKSB7XG4gICAgICAgIC0taTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBwLmlkICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICAgIHAuaWQgPSBOdW1iZXIocC5pZCk7XG4gIH1cblxuICAvLyBsb29rIHVwIGpzb24gZGF0YVxuICBpZiAoc3RyLmNoYXJBdCgrK2kpKSB7XG4gICAgdmFyIHBheWxvYWQgPSB0cnlQYXJzZShzdHIuc3Vic3RyKGkpKTtcbiAgICB2YXIgaXNQYXlsb2FkVmFsaWQgPSBwYXlsb2FkICE9PSBmYWxzZSAmJiAocC50eXBlID09PSBleHBvcnRzLkVSUk9SIHx8IGlzQXJyYXkocGF5bG9hZCkpO1xuICAgIGlmIChpc1BheWxvYWRWYWxpZCkge1xuICAgICAgcC5kYXRhID0gcGF5bG9hZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVycm9yKCdpbnZhbGlkIHBheWxvYWQnKTtcbiAgICB9XG4gIH1cblxuICBkZWJ1ZygnZGVjb2RlZCAlcyBhcyAlaicsIHN0ciwgcCk7XG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiB0cnlQYXJzZShzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdHIpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIERlYWxsb2NhdGVzIGEgcGFyc2VyJ3MgcmVzb3VyY2VzXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICB0aGlzLnJlY29uc3RydWN0b3IuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICB9XG59O1xuXG4vKipcbiAqIEEgbWFuYWdlciBvZiBhIGJpbmFyeSBldmVudCdzICdidWZmZXIgc2VxdWVuY2UnLiBTaG91bGRcbiAqIGJlIGNvbnN0cnVjdGVkIHdoZW5ldmVyIGEgcGFja2V0IG9mIHR5cGUgQklOQVJZX0VWRU5UIGlzXG4gKiBkZWNvZGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge0JpbmFyeVJlY29uc3RydWN0b3J9IGluaXRpYWxpemVkIHJlY29uc3RydWN0b3JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KSB7XG4gIHRoaXMucmVjb25QYWNrID0gcGFja2V0O1xuICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gYmluYXJ5IGRhdGEgcmVjZWl2ZWQgZnJvbSBjb25uZWN0aW9uXG4gKiBhZnRlciBhIEJJTkFSWV9FVkVOVCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXIgfCBBcnJheUJ1ZmZlcn0gYmluRGF0YSAtIHRoZSByYXcgYmluYXJ5IGRhdGEgcmVjZWl2ZWRcbiAqIEByZXR1cm4ge251bGwgfCBPYmplY3R9IHJldHVybnMgbnVsbCBpZiBtb3JlIGJpbmFyeSBkYXRhIGlzIGV4cGVjdGVkIG9yXG4gKiAgIGEgcmVjb25zdHJ1Y3RlZCBwYWNrZXQgb2JqZWN0IGlmIGFsbCBidWZmZXJzIGhhdmUgYmVlbiByZWNlaXZlZC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLnRha2VCaW5hcnlEYXRhID0gZnVuY3Rpb24oYmluRGF0YSkge1xuICB0aGlzLmJ1ZmZlcnMucHVzaChiaW5EYXRhKTtcbiAgaWYgKHRoaXMuYnVmZmVycy5sZW5ndGggPT09IHRoaXMucmVjb25QYWNrLmF0dGFjaG1lbnRzKSB7IC8vIGRvbmUgd2l0aCBidWZmZXIgbGlzdFxuICAgIHZhciBwYWNrZXQgPSBiaW5hcnkucmVjb25zdHJ1Y3RQYWNrZXQodGhpcy5yZWNvblBhY2ssIHRoaXMuYnVmZmVycyk7XG4gICAgdGhpcy5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gICAgcmV0dXJuIHBhY2tldDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQ2xlYW5zIHVwIGJpbmFyeSBwYWNrZXQgcmVjb25zdHJ1Y3Rpb24gdmFyaWFibGVzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZWNvblBhY2sgPSBudWxsO1xuICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbn07XG5cbmZ1bmN0aW9uIGVycm9yKG1zZykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGV4cG9ydHMuRVJST1IsXG4gICAgZGF0YTogJ3BhcnNlciBlcnJvcjogJyArIG1zZ1xuICB9O1xufVxuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmO1xuXG52YXIgd2l0aE5hdGl2ZUJ1ZmZlciA9IHR5cGVvZiBnbG9iYWwuQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nO1xudmFyIHdpdGhOYXRpdmVBcnJheUJ1ZmZlciA9IHR5cGVvZiBnbG9iYWwuQXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbic7XG5cbnZhciBpc1ZpZXcgPSAoZnVuY3Rpb24gKCkge1xuICBpZiAod2l0aE5hdGl2ZUFycmF5QnVmZmVyICYmIHR5cGVvZiBnbG9iYWwuQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5BcnJheUJ1ZmZlci5pc1ZpZXc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iai5idWZmZXIgaW5zdGFuY2VvZiBnbG9iYWwuQXJyYXlCdWZmZXI7IH07XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iaiBpcyBhIGJ1ZmZlciBvciBhbiBhcnJheWJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0J1ZihvYmopIHtcbiAgcmV0dXJuICh3aXRoTmF0aXZlQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAgICAgICAod2l0aE5hdGl2ZUFycmF5QnVmZmVyICYmIChvYmogaW5zdGFuY2VvZiBnbG9iYWwuQXJyYXlCdWZmZXIgfHwgaXNWaWV3KG9iaikpKTtcbn1cbiIsIi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZVxuICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXG4gICAgICAgICAgICAgICAgICA/IGNocm9tZS5zdG9yYWdlLmxvY2FsXG4gICAgICAgICAgICAgICAgICA6IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcbiAgJyMwMDAwQ0MnLCAnIzAwMDBGRicsICcjMDAzM0NDJywgJyMwMDMzRkYnLCAnIzAwNjZDQycsICcjMDA2NkZGJywgJyMwMDk5Q0MnLFxuICAnIzAwOTlGRicsICcjMDBDQzAwJywgJyMwMENDMzMnLCAnIzAwQ0M2NicsICcjMDBDQzk5JywgJyMwMENDQ0MnLCAnIzAwQ0NGRicsXG4gICcjMzMwMENDJywgJyMzMzAwRkYnLCAnIzMzMzNDQycsICcjMzMzM0ZGJywgJyMzMzY2Q0MnLCAnIzMzNjZGRicsICcjMzM5OUNDJyxcbiAgJyMzMzk5RkYnLCAnIzMzQ0MwMCcsICcjMzNDQzMzJywgJyMzM0NDNjYnLCAnIzMzQ0M5OScsICcjMzNDQ0NDJywgJyMzM0NDRkYnLFxuICAnIzY2MDBDQycsICcjNjYwMEZGJywgJyM2NjMzQ0MnLCAnIzY2MzNGRicsICcjNjZDQzAwJywgJyM2NkNDMzMnLCAnIzk5MDBDQycsXG4gICcjOTkwMEZGJywgJyM5OTMzQ0MnLCAnIzk5MzNGRicsICcjOTlDQzAwJywgJyM5OUNDMzMnLCAnI0NDMDAwMCcsICcjQ0MwMDMzJyxcbiAgJyNDQzAwNjYnLCAnI0NDMDA5OScsICcjQ0MwMENDJywgJyNDQzAwRkYnLCAnI0NDMzMwMCcsICcjQ0MzMzMzJywgJyNDQzMzNjYnLFxuICAnI0NDMzM5OScsICcjQ0MzM0NDJywgJyNDQzMzRkYnLCAnI0NDNjYwMCcsICcjQ0M2NjMzJywgJyNDQzk5MDAnLCAnI0NDOTkzMycsXG4gICcjQ0NDQzAwJywgJyNDQ0NDMzMnLCAnI0ZGMDAwMCcsICcjRkYwMDMzJywgJyNGRjAwNjYnLCAnI0ZGMDA5OScsICcjRkYwMENDJyxcbiAgJyNGRjAwRkYnLCAnI0ZGMzMwMCcsICcjRkYzMzMzJywgJyNGRjMzNjYnLCAnI0ZGMzM5OScsICcjRkYzM0NDJywgJyNGRjMzRkYnLFxuICAnI0ZGNjYwMCcsICcjRkY2NjMzJywgJyNGRjk5MDAnLCAnI0ZGOTkzMycsICcjRkZDQzAwJywgJyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAvLyBleHBsaWNpdGx5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiB3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG4gIHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuICAgIC8vIGRvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnIubWVzc2FnZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICsgYXJnc1swXVxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm47XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKVxuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuICAgICYmIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cblxuICAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG4gIGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuICAgIHIgPSBwcm9jZXNzLmVudi5ERUJVRztcbiAgfVxuXG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Z1snZGVmYXVsdCddID0gY3JlYXRlRGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBBY3RpdmUgYGRlYnVnYCBpbnN0YW5jZXMuXG4gKi9cbmV4cG9ydHMuaW5zdGFuY2VzID0gW107XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcbiAgdmFyIGhhc2ggPSAwLCBpO1xuXG4gIGZvciAoaSBpbiBuYW1lc3BhY2UpIHtcbiAgICBoYXNoICA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgfVxuXG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXG4gIHZhciBwcmV2VGltZTtcblxuICBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICAvLyBkaXNhYmxlZD9cbiAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHJldHVybjtcblxuICAgIHZhciBzZWxmID0gZGVidWc7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIHR1cm4gdGhlIGBhcmd1bWVudHNgIGludG8gYSBwcm9wZXIgQXJyYXlcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cbiAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgLy8gYXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcbiAgICBleHBvcnRzLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuICAgIHZhciBsb2dGbiA9IGRlYnVnLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG5cbiAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICBkZWJ1Zy5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gIGRlYnVnLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gIGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcbiAgZGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cbiAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmluaXQpIHtcbiAgICBleHBvcnRzLmluaXQoZGVidWcpO1xuICB9XG5cbiAgZXhwb3J0cy5pbnN0YW5jZXMucHVzaChkZWJ1Zyk7XG5cbiAgcmV0dXJuIGRlYnVnO1xufVxuXG5mdW5jdGlvbiBkZXN0cm95ICgpIHtcbiAgdmFyIGluZGV4ID0gZXhwb3J0cy5pbnN0YW5jZXMuaW5kZXhPZih0aGlzKTtcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIGV4cG9ydHMuaW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgZXhwb3J0cy5uYW1lcyA9IFtdO1xuICBleHBvcnRzLnNraXBzID0gW107XG5cbiAgdmFyIGk7XG4gIHZhciBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBleHBvcnRzLmluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpbnN0YW5jZSA9IGV4cG9ydHMuaW5zdGFuY2VzW2ldO1xuICAgIGluc3RhbmNlLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQoaW5zdGFuY2UubmFtZXNwYWNlKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gdG9BcnJheVxuXG5mdW5jdGlvbiB0b0FycmF5KGxpc3QsIGluZGV4KSB7XG4gICAgdmFyIGFycmF5ID0gW11cblxuICAgIGluZGV4ID0gaW5kZXggfHwgMFxuXG4gICAgZm9yICh2YXIgaSA9IGluZGV4IHx8IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5W2kgLSBpbmRleF0gPSBsaXN0W2ldXG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5XG59XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSwgZXZhbCkoXCJ0aGlzXCIpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFN0cmluZ3MgPSByZXF1aXJlKFwiLi9TdHJpbmdzXCIpO1xudmFyIEJyb3dzZXJfMSA9IHJlcXVpcmUoXCIuL3NoYXJlZC91dGlscy9Ccm93c2VyXCIpO1xudmFyIFJlbmRlckRlYm91bmNlcl8xID0gcmVxdWlyZShcIi4vdWkvUmVuZGVyRGVib3VuY2VyXCIpO1xudmFyIExpZmVjeWNsZV8xID0gcmVxdWlyZShcIi4vdWkvTGlmZWN5Y2xlXCIpO1xudmFyIExpZmVjeWNsZV8yID0gcmVxdWlyZShcIi4vY29tbW9uL0xpZmVjeWNsZVwiKTtcbnZhciBNQVhfUk9XU19UT19SRUFEID0gMjA7XG52YXIgQWNjZXNzaWJpbGl0eU1hbmFnZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBY2Nlc3NpYmlsaXR5TWFuYWdlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY2Nlc3NpYmlsaXR5TWFuYWdlcihfdGVybWluYWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3Rlcm1pbmFsID0gX3Rlcm1pbmFsO1xuICAgICAgICBfdGhpcy5fbGl2ZVJlZ2lvbkxpbmVDb3VudCA9IDA7XG4gICAgICAgIF90aGlzLl9jaGFyc1RvQ29uc3VtZSA9IFtdO1xuICAgICAgICBfdGhpcy5fYWNjZXNzaWJpbGl0eVRyZWVSb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIF90aGlzLl9hY2Nlc3NpYmlsaXR5VHJlZVJvb3QuY2xhc3NMaXN0LmFkZCgneHRlcm0tYWNjZXNzaWJpbGl0eScpO1xuICAgICAgICBfdGhpcy5fcm93Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIF90aGlzLl9yb3dDb250YWluZXIuY2xhc3NMaXN0LmFkZCgneHRlcm0tYWNjZXNzaWJpbGl0eS10cmVlJyk7XG4gICAgICAgIF90aGlzLl9yb3dFbGVtZW50cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLl90ZXJtaW5hbC5yb3dzOyBpKyspIHtcbiAgICAgICAgICAgIF90aGlzLl9yb3dFbGVtZW50c1tpXSA9IF90aGlzLl9jcmVhdGVBY2Nlc3NpYmlsaXR5VHJlZU5vZGUoKTtcbiAgICAgICAgICAgIF90aGlzLl9yb3dDb250YWluZXIuYXBwZW5kQ2hpbGQoX3RoaXMuX3Jvd0VsZW1lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5fdG9wQm91bmRhcnlGb2N1c0xpc3RlbmVyID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLl9vbkJvdW5kYXJ5Rm9jdXMoZSwgMCk7IH07XG4gICAgICAgIF90aGlzLl9ib3R0b21Cb3VuZGFyeUZvY3VzTGlzdGVuZXIgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3RoaXMuX29uQm91bmRhcnlGb2N1cyhlLCAxKTsgfTtcbiAgICAgICAgX3RoaXMuX3Jvd0VsZW1lbnRzWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgX3RoaXMuX3RvcEJvdW5kYXJ5Rm9jdXNMaXN0ZW5lcik7XG4gICAgICAgIF90aGlzLl9yb3dFbGVtZW50c1tfdGhpcy5fcm93RWxlbWVudHMubGVuZ3RoIC0gMV0uYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBfdGhpcy5fYm90dG9tQm91bmRhcnlGb2N1c0xpc3RlbmVyKTtcbiAgICAgICAgX3RoaXMuX3JlZnJlc2hSb3dzRGltZW5zaW9ucygpO1xuICAgICAgICBfdGhpcy5fYWNjZXNzaWJpbGl0eVRyZWVSb290LmFwcGVuZENoaWxkKF90aGlzLl9yb3dDb250YWluZXIpO1xuICAgICAgICBfdGhpcy5fcmVuZGVyUm93c0RlYm91bmNlciA9IG5ldyBSZW5kZXJEZWJvdW5jZXJfMS5SZW5kZXJEZWJvdW5jZXIoX3RoaXMuX3Rlcm1pbmFsLCBfdGhpcy5fcmVuZGVyUm93cy5iaW5kKF90aGlzKSk7XG4gICAgICAgIF90aGlzLl9yZWZyZXNoUm93cygpO1xuICAgICAgICBfdGhpcy5fbGl2ZVJlZ2lvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBfdGhpcy5fbGl2ZVJlZ2lvbi5jbGFzc0xpc3QuYWRkKCdsaXZlLXJlZ2lvbicpO1xuICAgICAgICBfdGhpcy5fbGl2ZVJlZ2lvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsICdhc3NlcnRpdmUnKTtcbiAgICAgICAgX3RoaXMuX2FjY2Vzc2liaWxpdHlUcmVlUm9vdC5hcHBlbmRDaGlsZChfdGhpcy5fbGl2ZVJlZ2lvbik7XG4gICAgICAgIF90aGlzLl90ZXJtaW5hbC5lbGVtZW50Lmluc2VydEFkamFjZW50RWxlbWVudCgnYWZ0ZXJiZWdpbicsIF90aGlzLl9hY2Nlc3NpYmlsaXR5VHJlZVJvb3QpO1xuICAgICAgICBfdGhpcy5yZWdpc3RlcihfdGhpcy5fcmVuZGVyUm93c0RlYm91bmNlcik7XG4gICAgICAgIF90aGlzLnJlZ2lzdGVyKF90aGlzLl90ZXJtaW5hbC5hZGREaXNwb3NhYmxlTGlzdGVuZXIoJ3Jlc2l6ZScsIGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBfdGhpcy5fb25SZXNpemUoZGF0YS5yb3dzKTsgfSkpO1xuICAgICAgICBfdGhpcy5yZWdpc3RlcihfdGhpcy5fdGVybWluYWwuYWRkRGlzcG9zYWJsZUxpc3RlbmVyKCdyZWZyZXNoJywgZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIF90aGlzLl9yZWZyZXNoUm93cyhkYXRhLnN0YXJ0LCBkYXRhLmVuZCk7IH0pKTtcbiAgICAgICAgX3RoaXMucmVnaXN0ZXIoX3RoaXMuX3Rlcm1pbmFsLmFkZERpc3Bvc2FibGVMaXN0ZW5lcignc2Nyb2xsJywgZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIF90aGlzLl9yZWZyZXNoUm93cygpOyB9KSk7XG4gICAgICAgIF90aGlzLnJlZ2lzdGVyKF90aGlzLl90ZXJtaW5hbC5hZGREaXNwb3NhYmxlTGlzdGVuZXIoJ2ExMXkuY2hhcicsIGZ1bmN0aW9uIChjaGFyKSB7IHJldHVybiBfdGhpcy5fb25DaGFyKGNoYXIpOyB9KSk7XG4gICAgICAgIF90aGlzLnJlZ2lzdGVyKF90aGlzLl90ZXJtaW5hbC5hZGREaXNwb3NhYmxlTGlzdGVuZXIoJ2xpbmVmZWVkJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX29uQ2hhcignXFxuJyk7IH0pKTtcbiAgICAgICAgX3RoaXMucmVnaXN0ZXIoX3RoaXMuX3Rlcm1pbmFsLmFkZERpc3Bvc2FibGVMaXN0ZW5lcignYTExeS50YWInLCBmdW5jdGlvbiAoc3BhY2VDb3VudCkgeyByZXR1cm4gX3RoaXMuX29uVGFiKHNwYWNlQ291bnQpOyB9KSk7XG4gICAgICAgIF90aGlzLnJlZ2lzdGVyKF90aGlzLl90ZXJtaW5hbC5hZGREaXNwb3NhYmxlTGlzdGVuZXIoJ2tleScsIGZ1bmN0aW9uIChrZXlDaGFyKSB7IHJldHVybiBfdGhpcy5fb25LZXkoa2V5Q2hhcik7IH0pKTtcbiAgICAgICAgX3RoaXMucmVnaXN0ZXIoX3RoaXMuX3Rlcm1pbmFsLmFkZERpc3Bvc2FibGVMaXN0ZW5lcignYmx1cicsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9jbGVhckxpdmVSZWdpb24oKTsgfSkpO1xuICAgICAgICBfdGhpcy5yZWdpc3RlcihfdGhpcy5fdGVybWluYWwuYWRkRGlzcG9zYWJsZUxpc3RlbmVyKCdkcHJjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fcmVmcmVzaFJvd3NEaW1lbnNpb25zKCk7IH0pKTtcbiAgICAgICAgX3RoaXMucmVnaXN0ZXIoX3RoaXMuX3Rlcm1pbmFsLnJlbmRlcmVyLmFkZERpc3Bvc2FibGVMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3JlZnJlc2hSb3dzRGltZW5zaW9ucygpOyB9KSk7XG4gICAgICAgIF90aGlzLnJlZ2lzdGVyKExpZmVjeWNsZV8xLmFkZERpc3Bvc2FibGVEb21MaXN0ZW5lcih3aW5kb3csICdyZXNpemUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fcmVmcmVzaFJvd3NEaW1lbnNpb25zKCk7IH0pKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBY2Nlc3NpYmlsaXR5TWFuYWdlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsLmVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5fYWNjZXNzaWJpbGl0eVRyZWVSb290KTtcbiAgICAgICAgdGhpcy5fcm93RWxlbWVudHMubGVuZ3RoID0gMDtcbiAgICB9O1xuICAgIEFjY2Vzc2liaWxpdHlNYW5hZ2VyLnByb3RvdHlwZS5fb25Cb3VuZGFyeUZvY3VzID0gZnVuY3Rpb24gKGUsIHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBib3VuZGFyeUVsZW1lbnQgPSBlLnRhcmdldDtcbiAgICAgICAgdmFyIGJlZm9yZUJvdW5kYXJ5RWxlbWVudCA9IHRoaXMuX3Jvd0VsZW1lbnRzW3Bvc2l0aW9uID09PSAwID8gMSA6IHRoaXMuX3Jvd0VsZW1lbnRzLmxlbmd0aCAtIDJdO1xuICAgICAgICB2YXIgcG9zSW5TZXQgPSBib3VuZGFyeUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdhcmlhLXBvc2luc2V0Jyk7XG4gICAgICAgIHZhciBsYXN0Um93UG9zID0gcG9zaXRpb24gPT09IDAgPyAnMScgOiBcIlwiICsgdGhpcy5fdGVybWluYWwuYnVmZmVyLmxpbmVzLmxlbmd0aDtcbiAgICAgICAgaWYgKHBvc0luU2V0ID09PSBsYXN0Um93UG9zKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUucmVsYXRlZFRhcmdldCAhPT0gYmVmb3JlQm91bmRhcnlFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvcEJvdW5kYXJ5RWxlbWVudDtcbiAgICAgICAgdmFyIGJvdHRvbUJvdW5kYXJ5RWxlbWVudDtcbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKSB7XG4gICAgICAgICAgICB0b3BCb3VuZGFyeUVsZW1lbnQgPSBib3VuZGFyeUVsZW1lbnQ7XG4gICAgICAgICAgICBib3R0b21Cb3VuZGFyeUVsZW1lbnQgPSB0aGlzLl9yb3dFbGVtZW50cy5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvd0NvbnRhaW5lci5yZW1vdmVDaGlsZChib3R0b21Cb3VuZGFyeUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9wQm91bmRhcnlFbGVtZW50ID0gdGhpcy5fcm93RWxlbWVudHMuc2hpZnQoKTtcbiAgICAgICAgICAgIGJvdHRvbUJvdW5kYXJ5RWxlbWVudCA9IGJvdW5kYXJ5RWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuX3Jvd0NvbnRhaW5lci5yZW1vdmVDaGlsZCh0b3BCb3VuZGFyeUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRvcEJvdW5kYXJ5RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX3RvcEJvdW5kYXJ5Rm9jdXNMaXN0ZW5lcik7XG4gICAgICAgIGJvdHRvbUJvdW5kYXJ5RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX2JvdHRvbUJvdW5kYXJ5Rm9jdXNMaXN0ZW5lcik7XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIG5ld0VsZW1lbnQgPSB0aGlzLl9jcmVhdGVBY2Nlc3NpYmlsaXR5VHJlZU5vZGUoKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvd0VsZW1lbnRzLnVuc2hpZnQobmV3RWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLl9yb3dDb250YWluZXIuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdhZnRlcmJlZ2luJywgbmV3RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbmV3RWxlbWVudCA9IHRoaXMuX2NyZWF0ZUFjY2Vzc2liaWxpdHlUcmVlTm9kZSgpO1xuICAgICAgICAgICAgdGhpcy5fcm93RWxlbWVudHMucHVzaChuZXdFbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuX3Jvd0NvbnRhaW5lci5hcHBlbmRDaGlsZChuZXdFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yb3dFbGVtZW50c1swXS5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX3RvcEJvdW5kYXJ5Rm9jdXNMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuX3Jvd0VsZW1lbnRzW3RoaXMuX3Jvd0VsZW1lbnRzLmxlbmd0aCAtIDFdLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fYm90dG9tQm91bmRhcnlGb2N1c0xpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5fdGVybWluYWwuc2Nyb2xsTGluZXMocG9zaXRpb24gPT09IDAgPyAtMSA6IDEpO1xuICAgICAgICB0aGlzLl9yb3dFbGVtZW50c1twb3NpdGlvbiA9PT0gMCA/IDEgOiB0aGlzLl9yb3dFbGVtZW50cy5sZW5ndGggLSAyXS5mb2N1cygpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgfTtcbiAgICBBY2Nlc3NpYmlsaXR5TWFuYWdlci5wcm90b3R5cGUuX29uUmVzaXplID0gZnVuY3Rpb24gKHJvd3MpIHtcbiAgICAgICAgdGhpcy5fcm93RWxlbWVudHNbdGhpcy5fcm93RWxlbWVudHMubGVuZ3RoIC0gMV0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9ib3R0b21Cb3VuZGFyeUZvY3VzTGlzdGVuZXIpO1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5fcm93Q29udGFpbmVyLmNoaWxkcmVuLmxlbmd0aDsgaSA8IHRoaXMuX3Rlcm1pbmFsLnJvd3M7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fcm93RWxlbWVudHNbaV0gPSB0aGlzLl9jcmVhdGVBY2Nlc3NpYmlsaXR5VHJlZU5vZGUoKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvd0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9yb3dFbGVtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMuX3Jvd0VsZW1lbnRzLmxlbmd0aCA+IHJvd3MpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvd0NvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLl9yb3dFbGVtZW50cy5wb3AoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcm93RWxlbWVudHNbdGhpcy5fcm93RWxlbWVudHMubGVuZ3RoIC0gMV0uYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9ib3R0b21Cb3VuZGFyeUZvY3VzTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLl9yZWZyZXNoUm93c0RpbWVuc2lvbnMoKTtcbiAgICB9O1xuICAgIEFjY2Vzc2liaWxpdHlNYW5hZ2VyLnByb3RvdHlwZS5fY3JlYXRlQWNjZXNzaWJpbGl0eVRyZWVOb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdsaXN0aXRlbScpO1xuICAgICAgICBlbGVtZW50LnRhYkluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuX3JlZnJlc2hSb3dEaW1lbnNpb25zKGVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9O1xuICAgIEFjY2Vzc2liaWxpdHlNYW5hZ2VyLnByb3RvdHlwZS5fb25UYWIgPSBmdW5jdGlvbiAoc3BhY2VDb3VudCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYWNlQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fb25DaGFyKCcgJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFjY2Vzc2liaWxpdHlNYW5hZ2VyLnByb3RvdHlwZS5fb25DaGFyID0gZnVuY3Rpb24gKGNoYXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2xpdmVSZWdpb25MaW5lQ291bnQgPCBNQVhfUk9XU19UT19SRUFEICsgMSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NoYXJzVG9Db25zdW1lLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgc2hpZnRlZENoYXIgPSB0aGlzLl9jaGFyc1RvQ29uc3VtZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGlmIChzaGlmdGVkQ2hhciAhPT0gY2hhcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbm5vdW5jZUNoYXJhY3RlcihjaGFyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hbm5vdW5jZUNoYXJhY3RlcihjaGFyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFyID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpdmVSZWdpb25MaW5lQ291bnQrKztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGl2ZVJlZ2lvbkxpbmVDb3VudCA9PT0gTUFYX1JPV1NfVE9fUkVBRCArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGl2ZVJlZ2lvbi50ZXh0Q29udGVudCArPSBTdHJpbmdzLnRvb011Y2hPdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJyb3dzZXJfMS5pc01hYykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9saXZlUmVnaW9uLnRleHRDb250ZW50ICYmIHRoaXMuX2xpdmVSZWdpb24udGV4dENvbnRlbnQubGVuZ3RoID4gMCAmJiAhdGhpcy5fbGl2ZVJlZ2lvbi5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FjY2Vzc2liaWxpdHlUcmVlUm9vdC5hcHBlbmRDaGlsZChfdGhpcy5fbGl2ZVJlZ2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQWNjZXNzaWJpbGl0eU1hbmFnZXIucHJvdG90eXBlLl9jbGVhckxpdmVSZWdpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xpdmVSZWdpb24udGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgdGhpcy5fbGl2ZVJlZ2lvbkxpbmVDb3VudCA9IDA7XG4gICAgICAgIGlmIChCcm93c2VyXzEuaXNNYWMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9saXZlUmVnaW9uLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY2Nlc3NpYmlsaXR5VHJlZVJvb3QucmVtb3ZlQ2hpbGQodGhpcy5fbGl2ZVJlZ2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFjY2Vzc2liaWxpdHlNYW5hZ2VyLnByb3RvdHlwZS5fb25LZXkgPSBmdW5jdGlvbiAoa2V5Q2hhcikge1xuICAgICAgICB0aGlzLl9jbGVhckxpdmVSZWdpb24oKTtcbiAgICAgICAgdGhpcy5fY2hhcnNUb0NvbnN1bWUucHVzaChrZXlDaGFyKTtcbiAgICB9O1xuICAgIEFjY2Vzc2liaWxpdHlNYW5hZ2VyLnByb3RvdHlwZS5fcmVmcmVzaFJvd3MgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJSb3dzRGVib3VuY2VyLnJlZnJlc2goc3RhcnQsIGVuZCk7XG4gICAgfTtcbiAgICBBY2Nlc3NpYmlsaXR5TWFuYWdlci5wcm90b3R5cGUuX3JlbmRlclJvd3MgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5fdGVybWluYWwuYnVmZmVyO1xuICAgICAgICB2YXIgc2V0U2l6ZSA9IGJ1ZmZlci5saW5lcy5sZW5ndGgudG9TdHJpbmcoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGluZURhdGEgPSBidWZmZXIudHJhbnNsYXRlQnVmZmVyTGluZVRvU3RyaW5nKGJ1ZmZlci55ZGlzcCArIGksIHRydWUpO1xuICAgICAgICAgICAgdmFyIHBvc0luU2V0ID0gKGJ1ZmZlci55ZGlzcCArIGkgKyAxKS50b1N0cmluZygpO1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLl9yb3dFbGVtZW50c1tpXTtcbiAgICAgICAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSBsaW5lRGF0YS5sZW5ndGggPT09IDAgPyBTdHJpbmdzLmJsYW5rTGluZSA6IGxpbmVEYXRhO1xuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtcG9zaW5zZXQnLCBwb3NJblNldCk7XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1zZXRzaXplJywgc2V0U2l6ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFjY2Vzc2liaWxpdHlNYW5hZ2VyLnByb3RvdHlwZS5fcmVmcmVzaFJvd3NEaW1lbnNpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Rlcm1pbmFsLnJlbmRlcmVyLmRpbWVuc2lvbnMuYWN0dWFsQ2VsbEhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9yb3dFbGVtZW50cy5sZW5ndGggIT09IHRoaXMuX3Rlcm1pbmFsLnJvd3MpIHtcbiAgICAgICAgICAgIHRoaXMuX29uUmVzaXplKHRoaXMuX3Rlcm1pbmFsLnJvd3MpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdGVybWluYWwucm93czsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWZyZXNoUm93RGltZW5zaW9ucyh0aGlzLl9yb3dFbGVtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFjY2Vzc2liaWxpdHlNYW5hZ2VyLnByb3RvdHlwZS5fcmVmcmVzaFJvd0RpbWVuc2lvbnMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9IHRoaXMuX3Rlcm1pbmFsLnJlbmRlcmVyLmRpbWVuc2lvbnMuYWN0dWFsQ2VsbEhlaWdodCArIFwicHhcIjtcbiAgICB9O1xuICAgIEFjY2Vzc2liaWxpdHlNYW5hZ2VyLnByb3RvdHlwZS5fYW5ub3VuY2VDaGFyYWN0ZXIgPSBmdW5jdGlvbiAoY2hhcikge1xuICAgICAgICBpZiAoY2hhciA9PT0gJyAnKSB7XG4gICAgICAgICAgICB0aGlzLl9saXZlUmVnaW9uLmlubmVySFRNTCArPSAnJm5ic3A7JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2xpdmVSZWdpb24udGV4dENvbnRlbnQgKz0gY2hhcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFjY2Vzc2liaWxpdHlNYW5hZ2VyO1xufShMaWZlY3ljbGVfMi5EaXNwb3NhYmxlKSk7XG5leHBvcnRzLkFjY2Vzc2liaWxpdHlNYW5hZ2VyID0gQWNjZXNzaWJpbGl0eU1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BY2Nlc3NpYmlsaXR5TWFuYWdlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ2lyY3VsYXJMaXN0XzEgPSByZXF1aXJlKFwiLi9jb21tb24vQ2lyY3VsYXJMaXN0XCIpO1xudmFyIEV2ZW50RW1pdHRlcl8xID0gcmVxdWlyZShcIi4vY29tbW9uL0V2ZW50RW1pdHRlclwiKTtcbnZhciBCdWZmZXJMaW5lXzEgPSByZXF1aXJlKFwiLi9CdWZmZXJMaW5lXCIpO1xuZXhwb3J0cy5ERUZBVUxUX0FUVFIgPSAoMCA8PCAxOCkgfCAoMjU3IDw8IDkpIHwgKDI1NiA8PCAwKTtcbmV4cG9ydHMuQ0hBUl9EQVRBX0FUVFJfSU5ERVggPSAwO1xuZXhwb3J0cy5DSEFSX0RBVEFfQ0hBUl9JTkRFWCA9IDE7XG5leHBvcnRzLkNIQVJfREFUQV9XSURUSF9JTkRFWCA9IDI7XG5leHBvcnRzLkNIQVJfREFUQV9DT0RFX0lOREVYID0gMztcbmV4cG9ydHMuTUFYX0JVRkZFUl9TSVpFID0gNDI5NDk2NzI5NTtcbmV4cG9ydHMuTlVMTF9DRUxMX0NIQVIgPSAnICc7XG5leHBvcnRzLk5VTExfQ0VMTF9XSURUSCA9IDE7XG5leHBvcnRzLk5VTExfQ0VMTF9DT0RFID0gMzI7XG52YXIgQnVmZmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCdWZmZXIoX3Rlcm1pbmFsLCBfaGFzU2Nyb2xsYmFjaykge1xuICAgICAgICB0aGlzLl90ZXJtaW5hbCA9IF90ZXJtaW5hbDtcbiAgICAgICAgdGhpcy5faGFzU2Nyb2xsYmFjayA9IF9oYXNTY3JvbGxiYWNrO1xuICAgICAgICB0aGlzLm1hcmtlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgXCJoYXNTY3JvbGxiYWNrXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faGFzU2Nyb2xsYmFjayAmJiB0aGlzLmxpbmVzLm1heExlbmd0aCA+IHRoaXMuX3Rlcm1pbmFsLnJvd3M7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCBcImlzQ3Vyc29ySW5WaWV3cG9ydFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFic29sdXRlWSA9IHRoaXMueWJhc2UgKyB0aGlzLnk7XG4gICAgICAgICAgICB2YXIgcmVsYXRpdmVZID0gYWJzb2x1dGVZIC0gdGhpcy55ZGlzcDtcbiAgICAgICAgICAgIHJldHVybiAocmVsYXRpdmVZID49IDAgJiYgcmVsYXRpdmVZIDwgdGhpcy5fdGVybWluYWwucm93cyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEJ1ZmZlci5wcm90b3R5cGUuX2dldENvcnJlY3RCdWZmZXJMZW5ndGggPSBmdW5jdGlvbiAocm93cykge1xuICAgICAgICBpZiAoIXRoaXMuX2hhc1Njcm9sbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiByb3dzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb3JyZWN0QnVmZmVyTGVuZ3RoID0gcm93cyArIHRoaXMuX3Rlcm1pbmFsLm9wdGlvbnMuc2Nyb2xsYmFjaztcbiAgICAgICAgcmV0dXJuIGNvcnJlY3RCdWZmZXJMZW5ndGggPiBleHBvcnRzLk1BWF9CVUZGRVJfU0laRSA/IGV4cG9ydHMuTUFYX0JVRkZFUl9TSVpFIDogY29ycmVjdEJ1ZmZlckxlbmd0aDtcbiAgICB9O1xuICAgIEJ1ZmZlci5wcm90b3R5cGUuZmlsbFZpZXdwb3J0Um93cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubGluZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMuX3Rlcm1pbmFsLnJvd3M7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saW5lcy5wdXNoKEJ1ZmZlckxpbmVfMS5CdWZmZXJMaW5lLmJsYW5rTGluZSh0aGlzLl90ZXJtaW5hbC5jb2xzLCBleHBvcnRzLkRFRkFVTFRfQVRUUikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBCdWZmZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnlkaXNwID0gMDtcbiAgICAgICAgdGhpcy55YmFzZSA9IDA7XG4gICAgICAgIHRoaXMueSA9IDA7XG4gICAgICAgIHRoaXMueCA9IDA7XG4gICAgICAgIHRoaXMubGluZXMgPSBuZXcgQ2lyY3VsYXJMaXN0XzEuQ2lyY3VsYXJMaXN0KHRoaXMuX2dldENvcnJlY3RCdWZmZXJMZW5ndGgodGhpcy5fdGVybWluYWwucm93cykpO1xuICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IDA7XG4gICAgICAgIHRoaXMuc2Nyb2xsQm90dG9tID0gdGhpcy5fdGVybWluYWwucm93cyAtIDE7XG4gICAgICAgIHRoaXMuc2V0dXBUYWJTdG9wcygpO1xuICAgIH07XG4gICAgQnVmZmVyLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAobmV3Q29scywgbmV3Um93cykge1xuICAgICAgICB2YXIgbmV3TWF4TGVuZ3RoID0gdGhpcy5fZ2V0Q29ycmVjdEJ1ZmZlckxlbmd0aChuZXdSb3dzKTtcbiAgICAgICAgaWYgKG5ld01heExlbmd0aCA+IHRoaXMubGluZXMubWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVzLm1heExlbmd0aCA9IG5ld01heExlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5saW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdGVybWluYWwuY29scyA8IG5ld0NvbHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2ggPSBbZXhwb3J0cy5ERUZBVUxUX0FUVFIsIGV4cG9ydHMuTlVMTF9DRUxMX0NIQVIsIGV4cG9ydHMuTlVMTF9DRUxMX1dJRFRILCBleHBvcnRzLk5VTExfQ0VMTF9DT0RFXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMubGluZXMuZ2V0KGkpLmxlbmd0aCA8IG5ld0NvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGluZXMuZ2V0KGkpLnB1c2goY2gpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFkZFRvWSA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5fdGVybWluYWwucm93cyA8IG5ld1Jvd3MpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gdGhpcy5fdGVybWluYWwucm93czsgeSA8IG5ld1Jvd3M7IHkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5saW5lcy5sZW5ndGggPCBuZXdSb3dzICsgdGhpcy55YmFzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMueWJhc2UgPiAwICYmIHRoaXMubGluZXMubGVuZ3RoIDw9IHRoaXMueWJhc2UgKyB0aGlzLnkgKyBhZGRUb1kgKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55YmFzZS0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFRvWSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnlkaXNwID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnlkaXNwLS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lcy5wdXNoKEJ1ZmZlckxpbmVfMS5CdWZmZXJMaW5lLmJsYW5rTGluZShuZXdDb2xzLCBleHBvcnRzLkRFRkFVTFRfQVRUUikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IHRoaXMuX3Rlcm1pbmFsLnJvd3M7IHkgPiBuZXdSb3dzOyB5LS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGluZXMubGVuZ3RoID4gbmV3Um93cyArIHRoaXMueWJhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxpbmVzLmxlbmd0aCA+IHRoaXMueWJhc2UgKyB0aGlzLnkgKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueWJhc2UrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnlkaXNwKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3TWF4TGVuZ3RoIDwgdGhpcy5saW5lcy5tYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYW1vdW50VG9UcmltID0gdGhpcy5saW5lcy5sZW5ndGggLSBuZXdNYXhMZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGFtb3VudFRvVHJpbSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lcy50cmltU3RhcnQoYW1vdW50VG9UcmltKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55YmFzZSA9IE1hdGgubWF4KHRoaXMueWJhc2UgLSBhbW91bnRUb1RyaW0sIDApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnlkaXNwID0gTWF0aC5tYXgodGhpcy55ZGlzcCAtIGFtb3VudFRvVHJpbSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubGluZXMubWF4TGVuZ3RoID0gbmV3TWF4TGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy54ID0gTWF0aC5taW4odGhpcy54LCBuZXdDb2xzIC0gMSk7XG4gICAgICAgICAgICB0aGlzLnkgPSBNYXRoLm1pbih0aGlzLnksIG5ld1Jvd3MgLSAxKTtcbiAgICAgICAgICAgIGlmIChhZGRUb1kpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnkgKz0gYWRkVG9ZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zYXZlZFkgPSBNYXRoLm1pbih0aGlzLnNhdmVkWSwgbmV3Um93cyAtIDEpO1xuICAgICAgICAgICAgdGhpcy5zYXZlZFggPSBNYXRoLm1pbih0aGlzLnNhdmVkWCwgbmV3Q29scyAtIDEpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Nyb2xsQm90dG9tID0gbmV3Um93cyAtIDE7XG4gICAgfTtcbiAgICBCdWZmZXIucHJvdG90eXBlLnN0cmluZ0luZGV4VG9CdWZmZXJJbmRleCA9IGZ1bmN0aW9uIChsaW5lSW5kZXgsIHN0cmluZ0luZGV4KSB7XG4gICAgICAgIHdoaWxlIChzdHJpbmdJbmRleCkge1xuICAgICAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzLmdldChsaW5lSW5kZXgpO1xuICAgICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgICAgWy0xLCAtMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmdJbmRleCAtPSBsaW5lLmdldChpKVtleHBvcnRzLkNIQVJfREFUQV9DSEFSX0lOREVYXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmluZ0luZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2xpbmVJbmRleCwgaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGluZUluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtsaW5lSW5kZXgsIDBdO1xuICAgIH07XG4gICAgQnVmZmVyLnByb3RvdHlwZS50cmFuc2xhdGVCdWZmZXJMaW5lVG9TdHJpbmcgPSBmdW5jdGlvbiAobGluZUluZGV4LCB0cmltUmlnaHQsIHN0YXJ0Q29sLCBlbmRDb2wpIHtcbiAgICAgICAgaWYgKHN0YXJ0Q29sID09PSB2b2lkIDApIHsgc3RhcnRDb2wgPSAwOyB9XG4gICAgICAgIGlmIChlbmRDb2wgPT09IHZvaWQgMCkgeyBlbmRDb2wgPSBudWxsOyB9XG4gICAgICAgIHZhciBsaW5lU3RyaW5nID0gJyc7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5saW5lcy5nZXQobGluZUluZGV4KTtcbiAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBzdGFydENvbDtcbiAgICAgICAgaWYgKGVuZENvbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZW5kQ29sID0gbGluZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVuZEluZGV4ID0gZW5kQ29sO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGFyID0gbGluZS5nZXQoaSk7XG4gICAgICAgICAgICBsaW5lU3RyaW5nICs9IGNoYXJbZXhwb3J0cy5DSEFSX0RBVEFfQ0hBUl9JTkRFWF07XG4gICAgICAgICAgICBpZiAoY2hhcltleHBvcnRzLkNIQVJfREFUQV9XSURUSF9JTkRFWF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRDb2wgPj0gaSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydEluZGV4LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlbmRDb2wgPiBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZEluZGV4LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJbZXhwb3J0cy5DSEFSX0RBVEFfQ0hBUl9JTkRFWF0ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRDb2wgPiBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEluZGV4ICs9IGNoYXJbZXhwb3J0cy5DSEFSX0RBVEFfQ0hBUl9JTkRFWF0ubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kQ29sID4gaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kSW5kZXggKz0gY2hhcltleHBvcnRzLkNIQVJfREFUQV9DSEFSX0lOREVYXS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0cmltUmlnaHQpIHtcbiAgICAgICAgICAgIHZhciByaWdodFdoaXRlc3BhY2VJbmRleCA9IGxpbmVTdHJpbmcuc2VhcmNoKC9cXHMrJC8pO1xuICAgICAgICAgICAgaWYgKHJpZ2h0V2hpdGVzcGFjZUluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGVuZEluZGV4ID0gTWF0aC5taW4oZW5kSW5kZXgsIHJpZ2h0V2hpdGVzcGFjZUluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmRJbmRleCA8PSBzdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lU3RyaW5nLnN1YnN0cmluZyhzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gICAgfTtcbiAgICBCdWZmZXIucHJvdG90eXBlLmdldFdyYXBwZWRSYW5nZUZvckxpbmUgPSBmdW5jdGlvbiAoeSkge1xuICAgICAgICB2YXIgZmlyc3QgPSB5O1xuICAgICAgICB2YXIgbGFzdCA9IHk7XG4gICAgICAgIHdoaWxlIChmaXJzdCA+IDAgJiYgdGhpcy5saW5lcy5nZXQoZmlyc3QpLmlzV3JhcHBlZCkge1xuICAgICAgICAgICAgZmlyc3QtLTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobGFzdCArIDEgPCB0aGlzLmxpbmVzLmxlbmd0aCAmJiB0aGlzLmxpbmVzLmdldChsYXN0ICsgMSkuaXNXcmFwcGVkKSB7XG4gICAgICAgICAgICBsYXN0Kys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZmlyc3Q6IGZpcnN0LCBsYXN0OiBsYXN0IH07XG4gICAgfTtcbiAgICBCdWZmZXIucHJvdG90eXBlLnNldHVwVGFiU3RvcHMgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICBpZiAoaSAhPT0gbnVsbCAmJiBpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy50YWJzW2ldKSB7XG4gICAgICAgICAgICAgICAgaSA9IHRoaXMucHJldlN0b3AoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRhYnMgPSB7fTtcbiAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBpIDwgdGhpcy5fdGVybWluYWwuY29sczsgaSArPSB0aGlzLl90ZXJtaW5hbC5vcHRpb25zLnRhYlN0b3BXaWR0aCkge1xuICAgICAgICAgICAgdGhpcy50YWJzW2ldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQnVmZmVyLnByb3RvdHlwZS5wcmV2U3RvcCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmICh4ID09PSBudWxsIHx8IHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgeCA9IHRoaXMueDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoIXRoaXMudGFic1stLXhdICYmIHggPiAwKVxuICAgICAgICAgICAgO1xuICAgICAgICByZXR1cm4geCA+PSB0aGlzLl90ZXJtaW5hbC5jb2xzID8gdGhpcy5fdGVybWluYWwuY29scyAtIDEgOiB4IDwgMCA/IDAgOiB4O1xuICAgIH07XG4gICAgQnVmZmVyLnByb3RvdHlwZS5uZXh0U3RvcCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmICh4ID09PSBudWxsIHx8IHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgeCA9IHRoaXMueDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoIXRoaXMudGFic1srK3hdICYmIHggPCB0aGlzLl90ZXJtaW5hbC5jb2xzKVxuICAgICAgICAgICAgO1xuICAgICAgICByZXR1cm4geCA+PSB0aGlzLl90ZXJtaW5hbC5jb2xzID8gdGhpcy5fdGVybWluYWwuY29scyAtIDEgOiB4IDwgMCA/IDAgOiB4O1xuICAgIH07XG4gICAgQnVmZmVyLnByb3RvdHlwZS5hZGRNYXJrZXIgPSBmdW5jdGlvbiAoeSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbWFya2VyID0gbmV3IE1hcmtlcih5KTtcbiAgICAgICAgdGhpcy5tYXJrZXJzLnB1c2gobWFya2VyKTtcbiAgICAgICAgbWFya2VyLnJlZ2lzdGVyKHRoaXMubGluZXMuYWRkRGlzcG9zYWJsZUxpc3RlbmVyKCd0cmltJywgZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgbWFya2VyLmxpbmUgLT0gYW1vdW50O1xuICAgICAgICAgICAgaWYgKG1hcmtlci5saW5lIDwgMCkge1xuICAgICAgICAgICAgICAgIG1hcmtlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgbWFya2VyLnJlZ2lzdGVyKG1hcmtlci5hZGREaXNwb3NhYmxlTGlzdGVuZXIoJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fcmVtb3ZlTWFya2VyKG1hcmtlcik7IH0pKTtcbiAgICAgICAgcmV0dXJuIG1hcmtlcjtcbiAgICB9O1xuICAgIEJ1ZmZlci5wcm90b3R5cGUuX3JlbW92ZU1hcmtlciA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgdGhpcy5tYXJrZXJzLnNwbGljZSh0aGlzLm1hcmtlcnMuaW5kZXhPZihtYXJrZXIpLCAxKTtcbiAgICB9O1xuICAgIEJ1ZmZlci5wcm90b3R5cGUuaXRlcmF0b3IgPSBmdW5jdGlvbiAodHJpbVJpZ2h0LCBzdGFydEluZGV4LCBlbmRJbmRleCwgc3RhcnRPdmVyc2NhbiwgZW5kT3ZlcnNjYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJTdHJpbmdJdGVyYXRvcih0aGlzLCB0cmltUmlnaHQsIHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBzdGFydE92ZXJzY2FuLCBlbmRPdmVyc2Nhbik7XG4gICAgfTtcbiAgICByZXR1cm4gQnVmZmVyO1xufSgpKTtcbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyO1xudmFyIE1hcmtlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1hcmtlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYXJrZXIobGluZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5saW5lID0gbGluZTtcbiAgICAgICAgX3RoaXMuX2lkID0gTWFya2VyLl9uZXh0SWQrKztcbiAgICAgICAgX3RoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXJrZXIucHJvdG90eXBlLCBcImlkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9pZDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWFya2VyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KCdkaXNwb3NlJyk7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgTWFya2VyLl9uZXh0SWQgPSAxO1xuICAgIHJldHVybiBNYXJrZXI7XG59KEV2ZW50RW1pdHRlcl8xLkV2ZW50RW1pdHRlcikpO1xuZXhwb3J0cy5NYXJrZXIgPSBNYXJrZXI7XG52YXIgQnVmZmVyU3RyaW5nSXRlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJ1ZmZlclN0cmluZ0l0ZXJhdG9yKF9idWZmZXIsIF90cmltUmlnaHQsIF9zdGFydEluZGV4LCBfZW5kSW5kZXgsIF9zdGFydE92ZXJzY2FuLCBfZW5kT3ZlcnNjYW4pIHtcbiAgICAgICAgaWYgKF9zdGFydEluZGV4ID09PSB2b2lkIDApIHsgX3N0YXJ0SW5kZXggPSAwOyB9XG4gICAgICAgIGlmIChfZW5kSW5kZXggPT09IHZvaWQgMCkgeyBfZW5kSW5kZXggPSBfYnVmZmVyLmxpbmVzLmxlbmd0aDsgfVxuICAgICAgICBpZiAoX3N0YXJ0T3ZlcnNjYW4gPT09IHZvaWQgMCkgeyBfc3RhcnRPdmVyc2NhbiA9IDA7IH1cbiAgICAgICAgaWYgKF9lbmRPdmVyc2NhbiA9PT0gdm9pZCAwKSB7IF9lbmRPdmVyc2NhbiA9IDA7IH1cbiAgICAgICAgdGhpcy5fYnVmZmVyID0gX2J1ZmZlcjtcbiAgICAgICAgdGhpcy5fdHJpbVJpZ2h0ID0gX3RyaW1SaWdodDtcbiAgICAgICAgdGhpcy5fc3RhcnRJbmRleCA9IF9zdGFydEluZGV4O1xuICAgICAgICB0aGlzLl9lbmRJbmRleCA9IF9lbmRJbmRleDtcbiAgICAgICAgdGhpcy5fc3RhcnRPdmVyc2NhbiA9IF9zdGFydE92ZXJzY2FuO1xuICAgICAgICB0aGlzLl9lbmRPdmVyc2NhbiA9IF9lbmRPdmVyc2NhbjtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXJ0SW5kZXggPCAwKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydEluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZW5kSW5kZXggPiB0aGlzLl9idWZmZXIubGluZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9lbmRJbmRleCA9IHRoaXMuX2J1ZmZlci5saW5lcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY3VycmVudCA9IHRoaXMuX3N0YXJ0SW5kZXg7XG4gICAgfVxuICAgIEJ1ZmZlclN0cmluZ0l0ZXJhdG9yLnByb3RvdHlwZS5oYXNOZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudCA8IHRoaXMuX2VuZEluZGV4O1xuICAgIH07XG4gICAgQnVmZmVyU3RyaW5nSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuX2J1ZmZlci5nZXRXcmFwcGVkUmFuZ2VGb3JMaW5lKHRoaXMuX2N1cnJlbnQpO1xuICAgICAgICBpZiAocmFuZ2UuZmlyc3QgPCB0aGlzLl9zdGFydEluZGV4IC0gdGhpcy5fc3RhcnRPdmVyc2Nhbikge1xuICAgICAgICAgICAgcmFuZ2UuZmlyc3QgPSB0aGlzLl9zdGFydEluZGV4IC0gdGhpcy5fc3RhcnRPdmVyc2NhbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmFuZ2UubGFzdCA+IHRoaXMuX2VuZEluZGV4ICsgdGhpcy5fZW5kT3ZlcnNjYW4pIHtcbiAgICAgICAgICAgIHJhbmdlLmxhc3QgPSB0aGlzLl9lbmRJbmRleCArIHRoaXMuX2VuZE92ZXJzY2FuO1xuICAgICAgICB9XG4gICAgICAgIHJhbmdlLmZpcnN0ID0gTWF0aC5tYXgocmFuZ2UuZmlyc3QsIDApO1xuICAgICAgICByYW5nZS5sYXN0ID0gTWF0aC5taW4ocmFuZ2UubGFzdCwgdGhpcy5fYnVmZmVyLmxpbmVzLmxlbmd0aCk7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IHJhbmdlLmZpcnN0OyBpIDw9IHJhbmdlLmxhc3Q7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuX2J1ZmZlci50cmFuc2xhdGVCdWZmZXJMaW5lVG9TdHJpbmcoaSwgKHRoaXMuX3RyaW1SaWdodCkgPyBpID09PSByYW5nZS5sYXN0IDogZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N1cnJlbnQgPSByYW5nZS5sYXN0ICsgMTtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHJhbmdlLCBjb250ZW50OiByZXN1bHQgfTtcbiAgICB9O1xuICAgIHJldHVybiBCdWZmZXJTdHJpbmdJdGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLkJ1ZmZlclN0cmluZ0l0ZXJhdG9yID0gQnVmZmVyU3RyaW5nSXRlcmF0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CdWZmZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQnVmZmVyXzEgPSByZXF1aXJlKFwiLi9CdWZmZXJcIik7XG52YXIgQnVmZmVyTGluZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQnVmZmVyTGluZShjb2xzLCBjaCwgaXNXcmFwcGVkKSB7XG4gICAgICAgIHRoaXMuaXNXcmFwcGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLl9kYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvbHMpIHtcbiAgICAgICAgICAgIGlmICghY2gpIHtcbiAgICAgICAgICAgICAgICBjaCA9IFswLCBCdWZmZXJfMS5OVUxMX0NFTExfQ0hBUiwgQnVmZmVyXzEuTlVMTF9DRUxMX1dJRFRILCBCdWZmZXJfMS5OVUxMX0NFTExfQ09ERV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbHM7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaChjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzV3JhcHBlZCkge1xuICAgICAgICAgICAgdGhpcy5pc1dyYXBwZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIEJ1ZmZlckxpbmUuYmxhbmtMaW5lID0gZnVuY3Rpb24gKGNvbHMsIGF0dHIsIGlzV3JhcHBlZCkge1xuICAgICAgICB2YXIgY2ggPSBbYXR0ciwgQnVmZmVyXzEuTlVMTF9DRUxMX0NIQVIsIEJ1ZmZlcl8xLk5VTExfQ0VMTF9XSURUSCwgQnVmZmVyXzEuTlVMTF9DRUxMX0NPREVdO1xuICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlckxpbmUoY29scywgY2gsIGlzV3JhcHBlZCk7XG4gICAgfTtcbiAgICBCdWZmZXJMaW5lLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFbaW5kZXhdO1xuICAgIH07XG4gICAgQnVmZmVyTGluZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGluZGV4LCBkYXRhKSB7XG4gICAgICAgIHRoaXMuX2RhdGFbaW5kZXhdID0gZGF0YTtcbiAgICB9O1xuICAgIEJ1ZmZlckxpbmUucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhLnBvcCgpO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMuX2RhdGEubGVuZ3RoO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuICAgIEJ1ZmZlckxpbmUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLl9kYXRhLnB1c2goZGF0YSk7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5fZGF0YS5sZW5ndGg7XG4gICAgfTtcbiAgICBCdWZmZXJMaW5lLnByb3RvdHlwZS5zcGxpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGRlbGV0ZUNvdW50KSB7XG4gICAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgaXRlbXNbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IChfYSA9IHRoaXMuX2RhdGEpLnNwbGljZS5hcHBseShfYSwgW3N0YXJ0LCBkZWxldGVDb3VudF0uY29uY2F0KGl0ZW1zKSk7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5fZGF0YS5sZW5ndGg7XG4gICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH07XG4gICAgQnVmZmVyTGluZS5wcm90b3R5cGUuaW5zZXJ0Q2VsbHMgPSBmdW5jdGlvbiAocG9zLCBuLCBjaCkge1xuICAgICAgICB3aGlsZSAobi0tKSB7XG4gICAgICAgICAgICB0aGlzLnNwbGljZShwb3MsIDAsIGNoKTtcbiAgICAgICAgICAgIHRoaXMucG9wKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJ1ZmZlckxpbmUucHJvdG90eXBlLmRlbGV0ZUNlbGxzID0gZnVuY3Rpb24gKHBvcywgbiwgZmlsbCkge1xuICAgICAgICB3aGlsZSAobi0tKSB7XG4gICAgICAgICAgICB0aGlzLnNwbGljZShwb3MsIDEpO1xuICAgICAgICAgICAgdGhpcy5wdXNoKGZpbGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCdWZmZXJMaW5lLnByb3RvdHlwZS5yZXBsYWNlQ2VsbHMgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgZmlsbCkge1xuICAgICAgICB3aGlsZSAoc3RhcnQgPCBlbmQgJiYgc3RhcnQgPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zZXQoc3RhcnQrKywgZmlsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBCdWZmZXJMaW5lO1xufSgpKTtcbmV4cG9ydHMuQnVmZmVyTGluZSA9IEJ1ZmZlckxpbmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CdWZmZXJMaW5lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBCdWZmZXJfMSA9IHJlcXVpcmUoXCIuL0J1ZmZlclwiKTtcbnZhciBFdmVudEVtaXR0ZXJfMSA9IHJlcXVpcmUoXCIuL2NvbW1vbi9FdmVudEVtaXR0ZXJcIik7XG52YXIgQnVmZmVyU2V0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnVmZmVyU2V0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJ1ZmZlclNldChfdGVybWluYWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3Rlcm1pbmFsID0gX3Rlcm1pbmFsO1xuICAgICAgICBfdGhpcy5fbm9ybWFsID0gbmV3IEJ1ZmZlcl8xLkJ1ZmZlcihfdGhpcy5fdGVybWluYWwsIHRydWUpO1xuICAgICAgICBfdGhpcy5fbm9ybWFsLmZpbGxWaWV3cG9ydFJvd3MoKTtcbiAgICAgICAgX3RoaXMuX2FsdCA9IG5ldyBCdWZmZXJfMS5CdWZmZXIoX3RoaXMuX3Rlcm1pbmFsLCBmYWxzZSk7XG4gICAgICAgIF90aGlzLl9hY3RpdmVCdWZmZXIgPSBfdGhpcy5fbm9ybWFsO1xuICAgICAgICBfdGhpcy5zZXR1cFRhYlN0b3BzKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlclNldC5wcm90b3R5cGUsIFwiYWx0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWx0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyU2V0LnByb3RvdHlwZSwgXCJhY3RpdmVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmVCdWZmZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXJTZXQucHJvdG90eXBlLCBcIm5vcm1hbFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1hbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQnVmZmVyU2V0LnByb3RvdHlwZS5hY3RpdmF0ZU5vcm1hbEJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZUJ1ZmZlciA9PT0gdGhpcy5fbm9ybWFsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWx0LmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2FjdGl2ZUJ1ZmZlciA9IHRoaXMuX25vcm1hbDtcbiAgICAgICAgdGhpcy5lbWl0KCdhY3RpdmF0ZScsIHtcbiAgICAgICAgICAgIGFjdGl2ZUJ1ZmZlcjogdGhpcy5fbm9ybWFsLFxuICAgICAgICAgICAgaW5hY3RpdmVCdWZmZXI6IHRoaXMuX2FsdFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJ1ZmZlclNldC5wcm90b3R5cGUuYWN0aXZhdGVBbHRCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVCdWZmZXIgPT09IHRoaXMuX2FsdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FsdC5maWxsVmlld3BvcnRSb3dzKCk7XG4gICAgICAgIHRoaXMuX2FjdGl2ZUJ1ZmZlciA9IHRoaXMuX2FsdDtcbiAgICAgICAgdGhpcy5lbWl0KCdhY3RpdmF0ZScsIHtcbiAgICAgICAgICAgIGFjdGl2ZUJ1ZmZlcjogdGhpcy5fYWx0LFxuICAgICAgICAgICAgaW5hY3RpdmVCdWZmZXI6IHRoaXMuX25vcm1hbFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJ1ZmZlclNldC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKG5ld0NvbHMsIG5ld1Jvd3MpIHtcbiAgICAgICAgdGhpcy5fbm9ybWFsLnJlc2l6ZShuZXdDb2xzLCBuZXdSb3dzKTtcbiAgICAgICAgdGhpcy5fYWx0LnJlc2l6ZShuZXdDb2xzLCBuZXdSb3dzKTtcbiAgICB9O1xuICAgIEJ1ZmZlclNldC5wcm90b3R5cGUuc2V0dXBUYWJTdG9wcyA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHRoaXMuX25vcm1hbC5zZXR1cFRhYlN0b3BzKGkpO1xuICAgICAgICB0aGlzLl9hbHQuc2V0dXBUYWJTdG9wcyhpKTtcbiAgICB9O1xuICAgIHJldHVybiBCdWZmZXJTZXQ7XG59KEV2ZW50RW1pdHRlcl8xLkV2ZW50RW1pdHRlcikpO1xuZXhwb3J0cy5CdWZmZXJTZXQgPSBCdWZmZXJTZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CdWZmZXJTZXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndjd2lkdGggPSAoZnVuY3Rpb24gKG9wdHMpIHtcbiAgICB2YXIgQ09NQklOSU5HX0JNUCA9IFtcbiAgICAgICAgWzB4MDMwMCwgMHgwMzZGXSwgWzB4MDQ4MywgMHgwNDg2XSwgWzB4MDQ4OCwgMHgwNDg5XSxcbiAgICAgICAgWzB4MDU5MSwgMHgwNUJEXSwgWzB4MDVCRiwgMHgwNUJGXSwgWzB4MDVDMSwgMHgwNUMyXSxcbiAgICAgICAgWzB4MDVDNCwgMHgwNUM1XSwgWzB4MDVDNywgMHgwNUM3XSwgWzB4MDYwMCwgMHgwNjAzXSxcbiAgICAgICAgWzB4MDYxMCwgMHgwNjE1XSwgWzB4MDY0QiwgMHgwNjVFXSwgWzB4MDY3MCwgMHgwNjcwXSxcbiAgICAgICAgWzB4MDZENiwgMHgwNkU0XSwgWzB4MDZFNywgMHgwNkU4XSwgWzB4MDZFQSwgMHgwNkVEXSxcbiAgICAgICAgWzB4MDcwRiwgMHgwNzBGXSwgWzB4MDcxMSwgMHgwNzExXSwgWzB4MDczMCwgMHgwNzRBXSxcbiAgICAgICAgWzB4MDdBNiwgMHgwN0IwXSwgWzB4MDdFQiwgMHgwN0YzXSwgWzB4MDkwMSwgMHgwOTAyXSxcbiAgICAgICAgWzB4MDkzQywgMHgwOTNDXSwgWzB4MDk0MSwgMHgwOTQ4XSwgWzB4MDk0RCwgMHgwOTREXSxcbiAgICAgICAgWzB4MDk1MSwgMHgwOTU0XSwgWzB4MDk2MiwgMHgwOTYzXSwgWzB4MDk4MSwgMHgwOTgxXSxcbiAgICAgICAgWzB4MDlCQywgMHgwOUJDXSwgWzB4MDlDMSwgMHgwOUM0XSwgWzB4MDlDRCwgMHgwOUNEXSxcbiAgICAgICAgWzB4MDlFMiwgMHgwOUUzXSwgWzB4MEEwMSwgMHgwQTAyXSwgWzB4MEEzQywgMHgwQTNDXSxcbiAgICAgICAgWzB4MEE0MSwgMHgwQTQyXSwgWzB4MEE0NywgMHgwQTQ4XSwgWzB4MEE0QiwgMHgwQTREXSxcbiAgICAgICAgWzB4MEE3MCwgMHgwQTcxXSwgWzB4MEE4MSwgMHgwQTgyXSwgWzB4MEFCQywgMHgwQUJDXSxcbiAgICAgICAgWzB4MEFDMSwgMHgwQUM1XSwgWzB4MEFDNywgMHgwQUM4XSwgWzB4MEFDRCwgMHgwQUNEXSxcbiAgICAgICAgWzB4MEFFMiwgMHgwQUUzXSwgWzB4MEIwMSwgMHgwQjAxXSwgWzB4MEIzQywgMHgwQjNDXSxcbiAgICAgICAgWzB4MEIzRiwgMHgwQjNGXSwgWzB4MEI0MSwgMHgwQjQzXSwgWzB4MEI0RCwgMHgwQjREXSxcbiAgICAgICAgWzB4MEI1NiwgMHgwQjU2XSwgWzB4MEI4MiwgMHgwQjgyXSwgWzB4MEJDMCwgMHgwQkMwXSxcbiAgICAgICAgWzB4MEJDRCwgMHgwQkNEXSwgWzB4MEMzRSwgMHgwQzQwXSwgWzB4MEM0NiwgMHgwQzQ4XSxcbiAgICAgICAgWzB4MEM0QSwgMHgwQzREXSwgWzB4MEM1NSwgMHgwQzU2XSwgWzB4MENCQywgMHgwQ0JDXSxcbiAgICAgICAgWzB4MENCRiwgMHgwQ0JGXSwgWzB4MENDNiwgMHgwQ0M2XSwgWzB4MENDQywgMHgwQ0NEXSxcbiAgICAgICAgWzB4MENFMiwgMHgwQ0UzXSwgWzB4MEQ0MSwgMHgwRDQzXSwgWzB4MEQ0RCwgMHgwRDREXSxcbiAgICAgICAgWzB4MERDQSwgMHgwRENBXSwgWzB4MEREMiwgMHgwREQ0XSwgWzB4MERENiwgMHgwREQ2XSxcbiAgICAgICAgWzB4MEUzMSwgMHgwRTMxXSwgWzB4MEUzNCwgMHgwRTNBXSwgWzB4MEU0NywgMHgwRTRFXSxcbiAgICAgICAgWzB4MEVCMSwgMHgwRUIxXSwgWzB4MEVCNCwgMHgwRUI5XSwgWzB4MEVCQiwgMHgwRUJDXSxcbiAgICAgICAgWzB4MEVDOCwgMHgwRUNEXSwgWzB4MEYxOCwgMHgwRjE5XSwgWzB4MEYzNSwgMHgwRjM1XSxcbiAgICAgICAgWzB4MEYzNywgMHgwRjM3XSwgWzB4MEYzOSwgMHgwRjM5XSwgWzB4MEY3MSwgMHgwRjdFXSxcbiAgICAgICAgWzB4MEY4MCwgMHgwRjg0XSwgWzB4MEY4NiwgMHgwRjg3XSwgWzB4MEY5MCwgMHgwRjk3XSxcbiAgICAgICAgWzB4MEY5OSwgMHgwRkJDXSwgWzB4MEZDNiwgMHgwRkM2XSwgWzB4MTAyRCwgMHgxMDMwXSxcbiAgICAgICAgWzB4MTAzMiwgMHgxMDMyXSwgWzB4MTAzNiwgMHgxMDM3XSwgWzB4MTAzOSwgMHgxMDM5XSxcbiAgICAgICAgWzB4MTA1OCwgMHgxMDU5XSwgWzB4MTE2MCwgMHgxMUZGXSwgWzB4MTM1RiwgMHgxMzVGXSxcbiAgICAgICAgWzB4MTcxMiwgMHgxNzE0XSwgWzB4MTczMiwgMHgxNzM0XSwgWzB4MTc1MiwgMHgxNzUzXSxcbiAgICAgICAgWzB4MTc3MiwgMHgxNzczXSwgWzB4MTdCNCwgMHgxN0I1XSwgWzB4MTdCNywgMHgxN0JEXSxcbiAgICAgICAgWzB4MTdDNiwgMHgxN0M2XSwgWzB4MTdDOSwgMHgxN0QzXSwgWzB4MTdERCwgMHgxN0REXSxcbiAgICAgICAgWzB4MTgwQiwgMHgxODBEXSwgWzB4MThBOSwgMHgxOEE5XSwgWzB4MTkyMCwgMHgxOTIyXSxcbiAgICAgICAgWzB4MTkyNywgMHgxOTI4XSwgWzB4MTkzMiwgMHgxOTMyXSwgWzB4MTkzOSwgMHgxOTNCXSxcbiAgICAgICAgWzB4MUExNywgMHgxQTE4XSwgWzB4MUIwMCwgMHgxQjAzXSwgWzB4MUIzNCwgMHgxQjM0XSxcbiAgICAgICAgWzB4MUIzNiwgMHgxQjNBXSwgWzB4MUIzQywgMHgxQjNDXSwgWzB4MUI0MiwgMHgxQjQyXSxcbiAgICAgICAgWzB4MUI2QiwgMHgxQjczXSwgWzB4MURDMCwgMHgxRENBXSwgWzB4MURGRSwgMHgxREZGXSxcbiAgICAgICAgWzB4MjAwQiwgMHgyMDBGXSwgWzB4MjAyQSwgMHgyMDJFXSwgWzB4MjA2MCwgMHgyMDYzXSxcbiAgICAgICAgWzB4MjA2QSwgMHgyMDZGXSwgWzB4MjBEMCwgMHgyMEVGXSwgWzB4MzAyQSwgMHgzMDJGXSxcbiAgICAgICAgWzB4MzA5OSwgMHgzMDlBXSwgWzB4QTgwNiwgMHhBODA2XSwgWzB4QTgwQiwgMHhBODBCXSxcbiAgICAgICAgWzB4QTgyNSwgMHhBODI2XSwgWzB4RkIxRSwgMHhGQjFFXSwgWzB4RkUwMCwgMHhGRTBGXSxcbiAgICAgICAgWzB4RkUyMCwgMHhGRTIzXSwgWzB4RkVGRiwgMHhGRUZGXSwgWzB4RkZGOSwgMHhGRkZCXVxuICAgIF07XG4gICAgdmFyIENPTUJJTklOR19ISUdIID0gW1xuICAgICAgICBbMHgxMEEwMSwgMHgxMEEwM10sIFsweDEwQTA1LCAweDEwQTA2XSwgWzB4MTBBMEMsIDB4MTBBMEZdLFxuICAgICAgICBbMHgxMEEzOCwgMHgxMEEzQV0sIFsweDEwQTNGLCAweDEwQTNGXSwgWzB4MUQxNjcsIDB4MUQxNjldLFxuICAgICAgICBbMHgxRDE3MywgMHgxRDE4Ml0sIFsweDFEMTg1LCAweDFEMThCXSwgWzB4MUQxQUEsIDB4MUQxQURdLFxuICAgICAgICBbMHgxRDI0MiwgMHgxRDI0NF0sIFsweEUwMDAxLCAweEUwMDAxXSwgWzB4RTAwMjAsIDB4RTAwN0ZdLFxuICAgICAgICBbMHhFMDEwMCwgMHhFMDFFRl1cbiAgICBdO1xuICAgIGZ1bmN0aW9uIGJpc2VhcmNoKHVjcywgZGF0YSkge1xuICAgICAgICB2YXIgbWluID0gMDtcbiAgICAgICAgdmFyIG1heCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIG1pZDtcbiAgICAgICAgaWYgKHVjcyA8IGRhdGFbMF1bMF0gfHwgdWNzID4gZGF0YVttYXhdWzFdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKG1heCA+PSBtaW4pIHtcbiAgICAgICAgICAgIG1pZCA9IChtaW4gKyBtYXgpID4+IDE7XG4gICAgICAgICAgICBpZiAodWNzID4gZGF0YVttaWRdWzFdKSB7XG4gICAgICAgICAgICAgICAgbWluID0gbWlkICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVjcyA8IGRhdGFbbWlkXVswXSkge1xuICAgICAgICAgICAgICAgIG1heCA9IG1pZCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdjd2lkdGhCTVAodWNzKSB7XG4gICAgICAgIGlmICh1Y3MgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRzLm51bDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodWNzIDwgMzIgfHwgKHVjcyA+PSAweDdmICYmIHVjcyA8IDB4YTApKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0cy5jb250cm9sO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiaXNlYXJjaCh1Y3MsIENPTUJJTklOR19CTVApKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNXaWRlQk1QKHVjcykpIHtcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1dpZGVCTVAodWNzKSB7XG4gICAgICAgIHJldHVybiAodWNzID49IDB4MTEwMCAmJiAodWNzIDw9IDB4MTE1ZiB8fFxuICAgICAgICAgICAgdWNzID09PSAweDIzMjkgfHxcbiAgICAgICAgICAgIHVjcyA9PT0gMHgyMzJhIHx8XG4gICAgICAgICAgICAodWNzID49IDB4MmU4MCAmJiB1Y3MgPD0gMHhhNGNmICYmIHVjcyAhPT0gMHgzMDNmKSB8fFxuICAgICAgICAgICAgKHVjcyA+PSAweGFjMDAgJiYgdWNzIDw9IDB4ZDdhMykgfHxcbiAgICAgICAgICAgICh1Y3MgPj0gMHhmOTAwICYmIHVjcyA8PSAweGZhZmYpIHx8XG4gICAgICAgICAgICAodWNzID49IDB4ZmUxMCAmJiB1Y3MgPD0gMHhmZTE5KSB8fFxuICAgICAgICAgICAgKHVjcyA+PSAweGZlMzAgJiYgdWNzIDw9IDB4ZmU2ZikgfHxcbiAgICAgICAgICAgICh1Y3MgPj0gMHhmZjAwICYmIHVjcyA8PSAweGZmNjApIHx8XG4gICAgICAgICAgICAodWNzID49IDB4ZmZlMCAmJiB1Y3MgPD0gMHhmZmU2KSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3Y3dpZHRoSGlnaCh1Y3MpIHtcbiAgICAgICAgaWYgKGJpc2VhcmNoKHVjcywgQ09NQklOSU5HX0hJR0gpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHVjcyA+PSAweDIwMDAwICYmIHVjcyA8PSAweDJmZmZkKSB8fCAodWNzID49IDB4MzAwMDAgJiYgdWNzIDw9IDB4M2ZmZmQpKSB7XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgdmFyIGNvbnRyb2wgPSBvcHRzLmNvbnRyb2wgfCAwO1xuICAgIHZhciB0YWJsZSA9IG51bGw7XG4gICAgZnVuY3Rpb24gaW5pdFRhYmxlKCkge1xuICAgICAgICB2YXIgQ09ERVBPSU5UUyA9IDY1NTM2O1xuICAgICAgICB2YXIgQklUV0lEVEggPSAyO1xuICAgICAgICB2YXIgSVRFTVNJWkUgPSAzMjtcbiAgICAgICAgdmFyIENPTlRBSU5FUlNJWkUgPSBDT0RFUE9JTlRTICogQklUV0lEVEggLyBJVEVNU0laRTtcbiAgICAgICAgdmFyIENPREVQT0lOVFNfUEVSX0lURU0gPSBJVEVNU0laRSAvIEJJVFdJRFRIO1xuICAgICAgICB0YWJsZSA9ICh0eXBlb2YgVWludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgPyBuZXcgQXJyYXkoQ09OVEFJTkVSU0laRSlcbiAgICAgICAgICAgIDogbmV3IFVpbnQzMkFycmF5KENPTlRBSU5FUlNJWkUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IENPTlRBSU5FUlNJWkU7ICsraSkge1xuICAgICAgICAgICAgdmFyIG51bSA9IDA7XG4gICAgICAgICAgICB2YXIgcG9zID0gQ09ERVBPSU5UU19QRVJfSVRFTTtcbiAgICAgICAgICAgIHdoaWxlIChwb3MtLSkge1xuICAgICAgICAgICAgICAgIG51bSA9IChudW0gPDwgMikgfCB3Y3dpZHRoQk1QKENPREVQT0lOVFNfUEVSX0lURU0gKiBpICsgcG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhYmxlW2ldID0gbnVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWJsZTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChudW0pIHtcbiAgICAgICAgbnVtID0gbnVtIHwgMDtcbiAgICAgICAgaWYgKG51bSA8IDMyKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bSA8IDEyNykge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHQgPSB0YWJsZSB8fCBpbml0VGFibGUoKTtcbiAgICAgICAgaWYgKG51bSA8IDY1NTM2KSB7XG4gICAgICAgICAgICByZXR1cm4gdFtudW0gPj4gNF0gPj4gKChudW0gJiAxNSkgPDwgMSkgJiAzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3Y3dpZHRoSGlnaChudW0pO1xuICAgIH07XG59KSh7IG51bDogMCwgY29udHJvbDogMCB9KTtcbmZ1bmN0aW9uIGdldFN0cmluZ0NlbGxXaWR0aChzKSB7XG4gICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjb2RlID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoMHhEODAwIDw9IGNvZGUgJiYgY29kZSA8PSAweERCRkYpIHtcbiAgICAgICAgICAgIHZhciBsb3cgPSBzLmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgICAgICAgaWYgKGlzTmFOKGxvdykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29kZSA9ICgoY29kZSAtIDB4RDgwMCkgKiAweDQwMCkgKyAobG93IC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKDB4REMwMCA8PSBjb2RlICYmIGNvZGUgPD0gMHhERkZGKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gZXhwb3J0cy53Y3dpZHRoKGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5nZXRTdHJpbmdDZWxsV2lkdGggPSBnZXRTdHJpbmdDZWxsV2lkdGg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DaGFyV2lkdGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ29tcG9zaXRpb25IZWxwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBvc2l0aW9uSGVscGVyKF90ZXh0YXJlYSwgX2NvbXBvc2l0aW9uVmlldywgX3Rlcm1pbmFsKSB7XG4gICAgICAgIHRoaXMuX3RleHRhcmVhID0gX3RleHRhcmVhO1xuICAgICAgICB0aGlzLl9jb21wb3NpdGlvblZpZXcgPSBfY29tcG9zaXRpb25WaWV3O1xuICAgICAgICB0aGlzLl90ZXJtaW5hbCA9IF90ZXJtaW5hbDtcbiAgICAgICAgdGhpcy5faXNDb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNTZW5kaW5nQ29tcG9zaXRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY29tcG9zaXRpb25Qb3NpdGlvbiA9IHsgc3RhcnQ6IG51bGwsIGVuZDogbnVsbCB9O1xuICAgIH1cbiAgICBDb21wb3NpdGlvbkhlbHBlci5wcm90b3R5cGUuY29tcG9zaXRpb25zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faXNDb21wb3NpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLl9jb21wb3NpdGlvblBvc2l0aW9uLnN0YXJ0ID0gdGhpcy5fdGV4dGFyZWEudmFsdWUubGVuZ3RoO1xuICAgICAgICB0aGlzLl9jb21wb3NpdGlvblZpZXcudGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgdGhpcy5fY29tcG9zaXRpb25WaWV3LmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgIH07XG4gICAgQ29tcG9zaXRpb25IZWxwZXIucHJvdG90eXBlLmNvbXBvc2l0aW9udXBkYXRlID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2NvbXBvc2l0aW9uVmlldy50ZXh0Q29udGVudCA9IGV2LmRhdGE7XG4gICAgICAgIHRoaXMudXBkYXRlQ29tcG9zaXRpb25FbGVtZW50cygpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9jb21wb3NpdGlvblBvc2l0aW9uLmVuZCA9IF90aGlzLl90ZXh0YXJlYS52YWx1ZS5sZW5ndGg7XG4gICAgICAgIH0sIDApO1xuICAgIH07XG4gICAgQ29tcG9zaXRpb25IZWxwZXIucHJvdG90eXBlLmNvbXBvc2l0aW9uZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9maW5hbGl6ZUNvbXBvc2l0aW9uKHRydWUpO1xuICAgIH07XG4gICAgQ29tcG9zaXRpb25IZWxwZXIucHJvdG90eXBlLmtleWRvd24gPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzQ29tcG9zaW5nIHx8IHRoaXMuX2lzU2VuZGluZ0NvbXBvc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZXYua2V5Q29kZSA9PT0gMjI5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXYua2V5Q29kZSA9PT0gMTYgfHwgZXYua2V5Q29kZSA9PT0gMTcgfHwgZXYua2V5Q29kZSA9PT0gMTgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9maW5hbGl6ZUNvbXBvc2l0aW9uKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXYua2V5Q29kZSA9PT0gMjI5KSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVBbnlUZXh0YXJlYUNoYW5nZXMoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIENvbXBvc2l0aW9uSGVscGVyLnByb3RvdHlwZS5fZmluYWxpemVDb21wb3NpdGlvbiA9IGZ1bmN0aW9uICh3YWl0Rm9yUHJvcG9nYXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fY29tcG9zaXRpb25WaWV3LmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgICB0aGlzLl9pc0NvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jbGVhclRleHRhcmVhUG9zaXRpb24oKTtcbiAgICAgICAgaWYgKCF3YWl0Rm9yUHJvcG9nYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU2VuZGluZ0NvbXBvc2l0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLl90ZXh0YXJlYS52YWx1ZS5zdWJzdHJpbmcodGhpcy5fY29tcG9zaXRpb25Qb3NpdGlvbi5zdGFydCwgdGhpcy5fY29tcG9zaXRpb25Qb3NpdGlvbi5lbmQpO1xuICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuaGFuZGxlcihpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudENvbXBvc2l0aW9uUG9zaXRpb25fMSA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5fY29tcG9zaXRpb25Qb3NpdGlvbi5zdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IHRoaXMuX2NvbXBvc2l0aW9uUG9zaXRpb24uZW5kXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5faXNTZW5kaW5nQ29tcG9zaXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9pc1NlbmRpbmdDb21wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faXNTZW5kaW5nQ29tcG9zaXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2lzQ29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dCA9IF90aGlzLl90ZXh0YXJlYS52YWx1ZS5zdWJzdHJpbmcoY3VycmVudENvbXBvc2l0aW9uUG9zaXRpb25fMS5zdGFydCwgY3VycmVudENvbXBvc2l0aW9uUG9zaXRpb25fMS5lbmQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQgPSBfdGhpcy5fdGV4dGFyZWEudmFsdWUuc3Vic3RyaW5nKGN1cnJlbnRDb21wb3NpdGlvblBvc2l0aW9uXzEuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl90ZXJtaW5hbC5oYW5kbGVyKGlucHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tcG9zaXRpb25IZWxwZXIucHJvdG90eXBlLl9oYW5kbGVBbnlUZXh0YXJlYUNoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMuX3RleHRhcmVhLnZhbHVlO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuX2lzQ29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gX3RoaXMuX3RleHRhcmVhLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBkaWZmID0gbmV3VmFsdWUucmVwbGFjZShvbGRWYWx1ZSwgJycpO1xuICAgICAgICAgICAgICAgIGlmIChkaWZmLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Rlcm1pbmFsLmhhbmRsZXIoZGlmZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICB9O1xuICAgIENvbXBvc2l0aW9uSGVscGVyLnByb3RvdHlwZS51cGRhdGVDb21wb3NpdGlvbkVsZW1lbnRzID0gZnVuY3Rpb24gKGRvbnRSZWN1cnNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5faXNDb21wb3NpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdGVybWluYWwuYnVmZmVyLmlzQ3Vyc29ySW5WaWV3cG9ydCkge1xuICAgICAgICAgICAgdmFyIGNlbGxIZWlnaHQgPSBNYXRoLmNlaWwodGhpcy5fdGVybWluYWwuY2hhck1lYXN1cmUuaGVpZ2h0ICogdGhpcy5fdGVybWluYWwub3B0aW9ucy5saW5lSGVpZ2h0KTtcbiAgICAgICAgICAgIHZhciBjdXJzb3JUb3AgPSB0aGlzLl90ZXJtaW5hbC5idWZmZXIueSAqIGNlbGxIZWlnaHQ7XG4gICAgICAgICAgICB2YXIgY3Vyc29yTGVmdCA9IHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci54ICogdGhpcy5fdGVybWluYWwuY2hhck1lYXN1cmUud2lkdGg7XG4gICAgICAgICAgICB0aGlzLl9jb21wb3NpdGlvblZpZXcuc3R5bGUubGVmdCA9IGN1cnNvckxlZnQgKyAncHgnO1xuICAgICAgICAgICAgdGhpcy5fY29tcG9zaXRpb25WaWV3LnN0eWxlLnRvcCA9IGN1cnNvclRvcCArICdweCc7XG4gICAgICAgICAgICB0aGlzLl9jb21wb3NpdGlvblZpZXcuc3R5bGUuaGVpZ2h0ID0gY2VsbEhlaWdodCArICdweCc7XG4gICAgICAgICAgICB0aGlzLl9jb21wb3NpdGlvblZpZXcuc3R5bGUubGluZUhlaWdodCA9IGNlbGxIZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgdmFyIGNvbXBvc2l0aW9uVmlld0JvdW5kcyA9IHRoaXMuX2NvbXBvc2l0aW9uVmlldy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHRoaXMuX3RleHRhcmVhLnN0eWxlLmxlZnQgPSBjdXJzb3JMZWZ0ICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMuX3RleHRhcmVhLnN0eWxlLnRvcCA9IGN1cnNvclRvcCArICdweCc7XG4gICAgICAgICAgICB0aGlzLl90ZXh0YXJlYS5zdHlsZS53aWR0aCA9IGNvbXBvc2l0aW9uVmlld0JvdW5kcy53aWR0aCArICdweCc7XG4gICAgICAgICAgICB0aGlzLl90ZXh0YXJlYS5zdHlsZS5oZWlnaHQgPSBjb21wb3NpdGlvblZpZXdCb3VuZHMuaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMuX3RleHRhcmVhLnN0eWxlLmxpbmVIZWlnaHQgPSBjb21wb3NpdGlvblZpZXdCb3VuZHMuaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRvbnRSZWN1cnNlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnVwZGF0ZUNvbXBvc2l0aW9uRWxlbWVudHModHJ1ZSk7IH0sIDApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb21wb3NpdGlvbkhlbHBlci5wcm90b3R5cGUuX2NsZWFyVGV4dGFyZWFQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdGV4dGFyZWEuc3R5bGUubGVmdCA9ICcnO1xuICAgICAgICB0aGlzLl90ZXh0YXJlYS5zdHlsZS50b3AgPSAnJztcbiAgICB9O1xuICAgIHJldHVybiBDb21wb3NpdGlvbkhlbHBlcjtcbn0oKSk7XG5leHBvcnRzLkNvbXBvc2l0aW9uSGVscGVyID0gQ29tcG9zaXRpb25IZWxwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db21wb3NpdGlvbkhlbHBlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTGlmZWN5Y2xlXzEgPSByZXF1aXJlKFwiLi9jb21tb24vTGlmZWN5Y2xlXCIpO1xuZnVuY3Rpb24gcihsb3csIGhpZ2gpIHtcbiAgICB2YXIgYyA9IGhpZ2ggLSBsb3c7XG4gICAgdmFyIGFyciA9IG5ldyBBcnJheShjKTtcbiAgICB3aGlsZSAoYy0tKSB7XG4gICAgICAgIGFycltjXSA9IC0taGlnaDtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbnZhciBUcmFuc2l0aW9uVGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyYW5zaXRpb25UYWJsZShsZW5ndGgpIHtcbiAgICAgICAgdGhpcy50YWJsZSA9ICh0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICA/IG5ldyBBcnJheShsZW5ndGgpXG4gICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgfVxuICAgIFRyYW5zaXRpb25UYWJsZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGNvZGUsIHN0YXRlLCBhY3Rpb24sIG5leHQpIHtcbiAgICAgICAgdGhpcy50YWJsZVtzdGF0ZSA8PCA4IHwgY29kZV0gPSAoKGFjdGlvbiB8IDApIDw8IDQpIHwgKChuZXh0ID09PSB1bmRlZmluZWQpID8gc3RhdGUgOiBuZXh0KTtcbiAgICB9O1xuICAgIFRyYW5zaXRpb25UYWJsZS5wcm90b3R5cGUuYWRkTWFueSA9IGZ1bmN0aW9uIChjb2Rlcywgc3RhdGUsIGFjdGlvbiwgbmV4dCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmFkZChjb2Rlc1tpXSwgc3RhdGUsIGFjdGlvbiwgbmV4dCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUcmFuc2l0aW9uVGFibGU7XG59KCkpO1xuZXhwb3J0cy5UcmFuc2l0aW9uVGFibGUgPSBUcmFuc2l0aW9uVGFibGU7XG52YXIgUFJJTlRBQkxFUyA9IHIoMHgyMCwgMHg3Zik7XG52YXIgRVhFQ1VUQUJMRVMgPSByKDB4MDAsIDB4MTgpO1xuRVhFQ1VUQUJMRVMucHVzaCgweDE5KTtcbkVYRUNVVEFCTEVTLmNvbmNhdChyKDB4MWMsIDB4MjApKTtcbnZhciBERUZBVUxUX1RSQU5TSVRJT04gPSAxIDw8IDQgfCAwO1xuZXhwb3J0cy5WVDUwMF9UUkFOU0lUSU9OX1RBQkxFID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGFibGUgPSBuZXcgVHJhbnNpdGlvblRhYmxlKDQwOTUpO1xuICAgIHZhciBzdGF0ZXMgPSByKDAsIDEzICsgMSk7XG4gICAgdmFyIHN0YXRlO1xuICAgIGZvciAoc3RhdGUgaW4gc3RhdGVzKSB7XG4gICAgICAgIGZvciAodmFyIGNvZGUgPSAwOyBjb2RlIDwgMTYwOyArK2NvZGUpIHtcbiAgICAgICAgICAgIHRhYmxlLmFkZChjb2RlLCBzdGF0ZSwgMSwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGFibGUuYWRkTWFueShQUklOVEFCTEVTLCAwLCAyLCAwKTtcbiAgICBmb3IgKHN0YXRlIGluIHN0YXRlcykge1xuICAgICAgICB0YWJsZS5hZGRNYW55KFsweDE4LCAweDFhLCAweDk5LCAweDlhXSwgc3RhdGUsIDMsIDApO1xuICAgICAgICB0YWJsZS5hZGRNYW55KHIoMHg4MCwgMHg5MCksIHN0YXRlLCAzLCAwKTtcbiAgICAgICAgdGFibGUuYWRkTWFueShyKDB4OTAsIDB4OTgpLCBzdGF0ZSwgMywgMCk7XG4gICAgICAgIHRhYmxlLmFkZCgweDljLCBzdGF0ZSwgMCwgMCk7XG4gICAgICAgIHRhYmxlLmFkZCgweDFiLCBzdGF0ZSwgMTEsIDEpO1xuICAgICAgICB0YWJsZS5hZGQoMHg5ZCwgc3RhdGUsIDQsIDgpO1xuICAgICAgICB0YWJsZS5hZGRNYW55KFsweDk4LCAweDllLCAweDlmXSwgc3RhdGUsIDAsIDcpO1xuICAgICAgICB0YWJsZS5hZGQoMHg5Yiwgc3RhdGUsIDExLCAzKTtcbiAgICAgICAgdGFibGUuYWRkKDB4OTAsIHN0YXRlLCAxMSwgOSk7XG4gICAgfVxuICAgIHRhYmxlLmFkZE1hbnkoRVhFQ1VUQUJMRVMsIDAsIDMsIDApO1xuICAgIHRhYmxlLmFkZE1hbnkoRVhFQ1VUQUJMRVMsIDEsIDMsIDEpO1xuICAgIHRhYmxlLmFkZCgweDdmLCAxLCAwLCAxKTtcbiAgICB0YWJsZS5hZGRNYW55KEVYRUNVVEFCTEVTLCA4LCAwLCA4KTtcbiAgICB0YWJsZS5hZGRNYW55KEVYRUNVVEFCTEVTLCAzLCAzLCAzKTtcbiAgICB0YWJsZS5hZGQoMHg3ZiwgMywgMCwgMyk7XG4gICAgdGFibGUuYWRkTWFueShFWEVDVVRBQkxFUywgNCwgMywgNCk7XG4gICAgdGFibGUuYWRkKDB4N2YsIDQsIDAsIDQpO1xuICAgIHRhYmxlLmFkZE1hbnkoRVhFQ1VUQUJMRVMsIDYsIDMsIDYpO1xuICAgIHRhYmxlLmFkZE1hbnkoRVhFQ1VUQUJMRVMsIDUsIDMsIDUpO1xuICAgIHRhYmxlLmFkZCgweDdmLCA1LCAwLCA1KTtcbiAgICB0YWJsZS5hZGRNYW55KEVYRUNVVEFCTEVTLCAyLCAzLCAyKTtcbiAgICB0YWJsZS5hZGQoMHg3ZiwgMiwgMCwgMik7XG4gICAgdGFibGUuYWRkKDB4NWQsIDEsIDQsIDgpO1xuICAgIHRhYmxlLmFkZE1hbnkoUFJJTlRBQkxFUywgOCwgNSwgOCk7XG4gICAgdGFibGUuYWRkKDB4N2YsIDgsIDUsIDgpO1xuICAgIHRhYmxlLmFkZE1hbnkoWzB4OWMsIDB4MWIsIDB4MTgsIDB4MWEsIDB4MDddLCA4LCA2LCAwKTtcbiAgICB0YWJsZS5hZGRNYW55KHIoMHgxYywgMHgyMCksIDgsIDAsIDgpO1xuICAgIHRhYmxlLmFkZE1hbnkoWzB4NTgsIDB4NWUsIDB4NWZdLCAxLCAwLCA3KTtcbiAgICB0YWJsZS5hZGRNYW55KFBSSU5UQUJMRVMsIDcsIDAsIDcpO1xuICAgIHRhYmxlLmFkZE1hbnkoRVhFQ1VUQUJMRVMsIDcsIDAsIDcpO1xuICAgIHRhYmxlLmFkZCgweDljLCA3LCAwLCAwKTtcbiAgICB0YWJsZS5hZGQoMHg1YiwgMSwgMTEsIDMpO1xuICAgIHRhYmxlLmFkZE1hbnkocigweDQwLCAweDdmKSwgMywgNywgMCk7XG4gICAgdGFibGUuYWRkTWFueShyKDB4MzAsIDB4M2EpLCAzLCA4LCA0KTtcbiAgICB0YWJsZS5hZGQoMHgzYiwgMywgOCwgNCk7XG4gICAgdGFibGUuYWRkTWFueShbMHgzYywgMHgzZCwgMHgzZSwgMHgzZl0sIDMsIDksIDQpO1xuICAgIHRhYmxlLmFkZE1hbnkocigweDMwLCAweDNhKSwgNCwgOCwgNCk7XG4gICAgdGFibGUuYWRkKDB4M2IsIDQsIDgsIDQpO1xuICAgIHRhYmxlLmFkZE1hbnkocigweDQwLCAweDdmKSwgNCwgNywgMCk7XG4gICAgdGFibGUuYWRkTWFueShbMHgzYSwgMHgzYywgMHgzZCwgMHgzZSwgMHgzZl0sIDQsIDAsIDYpO1xuICAgIHRhYmxlLmFkZE1hbnkocigweDIwLCAweDQwKSwgNiwgMCwgNik7XG4gICAgdGFibGUuYWRkKDB4N2YsIDYsIDAsIDYpO1xuICAgIHRhYmxlLmFkZE1hbnkocigweDQwLCAweDdmKSwgNiwgMCwgMCk7XG4gICAgdGFibGUuYWRkKDB4M2EsIDMsIDAsIDYpO1xuICAgIHRhYmxlLmFkZE1hbnkocigweDIwLCAweDMwKSwgMywgOSwgNSk7XG4gICAgdGFibGUuYWRkTWFueShyKDB4MjAsIDB4MzApLCA1LCA5LCA1KTtcbiAgICB0YWJsZS5hZGRNYW55KHIoMHgzMCwgMHg0MCksIDUsIDAsIDYpO1xuICAgIHRhYmxlLmFkZE1hbnkocigweDQwLCAweDdmKSwgNSwgNywgMCk7XG4gICAgdGFibGUuYWRkTWFueShyKDB4MjAsIDB4MzApLCA0LCA5LCA1KTtcbiAgICB0YWJsZS5hZGRNYW55KHIoMHgyMCwgMHgzMCksIDEsIDksIDIpO1xuICAgIHRhYmxlLmFkZE1hbnkocigweDIwLCAweDMwKSwgMiwgOSwgMik7XG4gICAgdGFibGUuYWRkTWFueShyKDB4MzAsIDB4N2YpLCAyLCAxMCwgMCk7XG4gICAgdGFibGUuYWRkTWFueShyKDB4MzAsIDB4NTApLCAxLCAxMCwgMCk7XG4gICAgdGFibGUuYWRkTWFueShyKDB4NTEsIDB4NTgpLCAxLCAxMCwgMCk7XG4gICAgdGFibGUuYWRkTWFueShbMHg1OSwgMHg1YSwgMHg1Y10sIDEsIDEwLCAwKTtcbiAgICB0YWJsZS5hZGRNYW55KHIoMHg2MCwgMHg3ZiksIDEsIDEwLCAwKTtcbiAgICB0YWJsZS5hZGQoMHg1MCwgMSwgMTEsIDkpO1xuICAgIHRhYmxlLmFkZE1hbnkoRVhFQ1VUQUJMRVMsIDksIDAsIDkpO1xuICAgIHRhYmxlLmFkZCgweDdmLCA5LCAwLCA5KTtcbiAgICB0YWJsZS5hZGRNYW55KHIoMHgxYywgMHgyMCksIDksIDAsIDkpO1xuICAgIHRhYmxlLmFkZE1hbnkocigweDIwLCAweDMwKSwgOSwgOSwgMTIpO1xuICAgIHRhYmxlLmFkZCgweDNhLCA5LCAwLCAxMSk7XG4gICAgdGFibGUuYWRkTWFueShyKDB4MzAsIDB4M2EpLCA5LCA4LCAxMCk7XG4gICAgdGFibGUuYWRkKDB4M2IsIDksIDgsIDEwKTtcbiAgICB0YWJsZS5hZGRNYW55KFsweDNjLCAweDNkLCAweDNlLCAweDNmXSwgOSwgOSwgMTApO1xuICAgIHRhYmxlLmFkZE1hbnkoRVhFQ1VUQUJMRVMsIDExLCAwLCAxMSk7XG4gICAgdGFibGUuYWRkTWFueShyKDB4MjAsIDB4ODApLCAxMSwgMCwgMTEpO1xuICAgIHRhYmxlLmFkZE1hbnkocigweDFjLCAweDIwKSwgMTEsIDAsIDExKTtcbiAgICB0YWJsZS5hZGRNYW55KEVYRUNVVEFCTEVTLCAxMCwgMCwgMTApO1xuICAgIHRhYmxlLmFkZCgweDdmLCAxMCwgMCwgMTApO1xuICAgIHRhYmxlLmFkZE1hbnkocigweDFjLCAweDIwKSwgMTAsIDAsIDEwKTtcbiAgICB0YWJsZS5hZGRNYW55KHIoMHgzMCwgMHgzYSksIDEwLCA4LCAxMCk7XG4gICAgdGFibGUuYWRkKDB4M2IsIDEwLCA4LCAxMCk7XG4gICAgdGFibGUuYWRkTWFueShbMHgzYSwgMHgzYywgMHgzZCwgMHgzZSwgMHgzZl0sIDEwLCAwLCAxMSk7XG4gICAgdGFibGUuYWRkTWFueShyKDB4MjAsIDB4MzApLCAxMCwgOSwgMTIpO1xuICAgIHRhYmxlLmFkZE1hbnkoRVhFQ1VUQUJMRVMsIDEyLCAwLCAxMik7XG4gICAgdGFibGUuYWRkKDB4N2YsIDEyLCAwLCAxMik7XG4gICAgdGFibGUuYWRkTWFueShyKDB4MWMsIDB4MjApLCAxMiwgMCwgMTIpO1xuICAgIHRhYmxlLmFkZE1hbnkocigweDIwLCAweDMwKSwgMTIsIDksIDEyKTtcbiAgICB0YWJsZS5hZGRNYW55KHIoMHgzMCwgMHg0MCksIDEyLCAwLCAxMSk7XG4gICAgdGFibGUuYWRkTWFueShyKDB4NDAsIDB4N2YpLCAxMiwgMTIsIDEzKTtcbiAgICB0YWJsZS5hZGRNYW55KHIoMHg0MCwgMHg3ZiksIDEwLCAxMiwgMTMpO1xuICAgIHRhYmxlLmFkZE1hbnkocigweDQwLCAweDdmKSwgOSwgMTIsIDEzKTtcbiAgICB0YWJsZS5hZGRNYW55KEVYRUNVVEFCTEVTLCAxMywgMTMsIDEzKTtcbiAgICB0YWJsZS5hZGRNYW55KFBSSU5UQUJMRVMsIDEzLCAxMywgMTMpO1xuICAgIHRhYmxlLmFkZCgweDdmLCAxMywgMCwgMTMpO1xuICAgIHRhYmxlLmFkZE1hbnkoWzB4MWIsIDB4OWNdLCAxMywgMTQsIDApO1xuICAgIHJldHVybiB0YWJsZTtcbn0pKCk7XG52YXIgRGNzRHVtbXkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERjc0R1bW15KCkge1xuICAgIH1cbiAgICBEY3NEdW1teS5wcm90b3R5cGUuaG9vayA9IGZ1bmN0aW9uIChjb2xsZWN0LCBwYXJhbXMsIGZsYWcpIHsgfTtcbiAgICBEY3NEdW1teS5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKGRhdGEsIHN0YXJ0LCBlbmQpIHsgfTtcbiAgICBEY3NEdW1teS5wcm90b3R5cGUudW5ob29rID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIHJldHVybiBEY3NEdW1teTtcbn0oKSk7XG52YXIgRXNjYXBlU2VxdWVuY2VQYXJzZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFc2NhcGVTZXF1ZW5jZVBhcnNlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFc2NhcGVTZXF1ZW5jZVBhcnNlcihUUkFOU0lUSU9OUykge1xuICAgICAgICBpZiAoVFJBTlNJVElPTlMgPT09IHZvaWQgMCkgeyBUUkFOU0lUSU9OUyA9IGV4cG9ydHMuVlQ1MDBfVFJBTlNJVElPTl9UQUJMRTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5UUkFOU0lUSU9OUyA9IFRSQU5TSVRJT05TO1xuICAgICAgICBfdGhpcy5pbml0aWFsU3RhdGUgPSAwO1xuICAgICAgICBfdGhpcy5jdXJyZW50U3RhdGUgPSBfdGhpcy5pbml0aWFsU3RhdGU7XG4gICAgICAgIF90aGlzLl9vc2MgPSAnJztcbiAgICAgICAgX3RoaXMuX3BhcmFtcyA9IFswXTtcbiAgICAgICAgX3RoaXMuX2NvbGxlY3QgPSAnJztcbiAgICAgICAgX3RoaXMuX3ByaW50SGFuZGxlckZiID0gZnVuY3Rpb24gKGRhdGEsIHN0YXJ0LCBlbmQpIHsgfTtcbiAgICAgICAgX3RoaXMuX2V4ZWN1dGVIYW5kbGVyRmIgPSBmdW5jdGlvbiAoY29kZSkgeyB9O1xuICAgICAgICBfdGhpcy5fY3NpSGFuZGxlckZiID0gZnVuY3Rpb24gKGNvbGxlY3QsIHBhcmFtcywgZmxhZykgeyB9O1xuICAgICAgICBfdGhpcy5fZXNjSGFuZGxlckZiID0gZnVuY3Rpb24gKGNvbGxlY3QsIGZsYWcpIHsgfTtcbiAgICAgICAgX3RoaXMuX29zY0hhbmRsZXJGYiA9IGZ1bmN0aW9uIChpZGVudGlmaWVyLCBkYXRhKSB7IH07XG4gICAgICAgIF90aGlzLl9kY3NIYW5kbGVyRmIgPSBuZXcgRGNzRHVtbXkoKTtcbiAgICAgICAgX3RoaXMuX2Vycm9ySGFuZGxlckZiID0gZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBzdGF0ZTsgfTtcbiAgICAgICAgX3RoaXMuX3ByaW50SGFuZGxlciA9IF90aGlzLl9wcmludEhhbmRsZXJGYjtcbiAgICAgICAgX3RoaXMuX2V4ZWN1dGVIYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIF90aGlzLl9jc2lIYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIF90aGlzLl9lc2NIYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIF90aGlzLl9vc2NIYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIF90aGlzLl9kY3NIYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIF90aGlzLl9hY3RpdmVEY3NIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX2Vycm9ySGFuZGxlciA9IF90aGlzLl9lcnJvckhhbmRsZXJGYjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFc2NhcGVTZXF1ZW5jZVBhcnNlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcHJpbnRIYW5kbGVyRmIgPSBudWxsO1xuICAgICAgICB0aGlzLl9leGVjdXRlSGFuZGxlckZiID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY3NpSGFuZGxlckZiID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZXNjSGFuZGxlckZiID0gbnVsbDtcbiAgICAgICAgdGhpcy5fb3NjSGFuZGxlckZiID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZGNzSGFuZGxlckZiID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZXJyb3JIYW5kbGVyRmIgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcmludEhhbmRsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9leGVjdXRlSGFuZGxlcnMgPSBudWxsO1xuICAgICAgICB0aGlzLl9jc2lIYW5kbGVycyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2VzY0hhbmRsZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fb3NjSGFuZGxlcnMgPSBudWxsO1xuICAgICAgICB0aGlzLl9kY3NIYW5kbGVycyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2FjdGl2ZURjc0hhbmRsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9lcnJvckhhbmRsZXIgPSBudWxsO1xuICAgIH07XG4gICAgRXNjYXBlU2VxdWVuY2VQYXJzZXIucHJvdG90eXBlLnNldFByaW50SGFuZGxlciA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9wcmludEhhbmRsZXIgPSBjYWxsYmFjaztcbiAgICB9O1xuICAgIEVzY2FwZVNlcXVlbmNlUGFyc2VyLnByb3RvdHlwZS5jbGVhclByaW50SGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcHJpbnRIYW5kbGVyID0gdGhpcy5fcHJpbnRIYW5kbGVyRmI7XG4gICAgfTtcbiAgICBFc2NhcGVTZXF1ZW5jZVBhcnNlci5wcm90b3R5cGUuc2V0RXhlY3V0ZUhhbmRsZXIgPSBmdW5jdGlvbiAoZmxhZywgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fZXhlY3V0ZUhhbmRsZXJzW2ZsYWcuY2hhckNvZGVBdCgwKV0gPSBjYWxsYmFjaztcbiAgICB9O1xuICAgIEVzY2FwZVNlcXVlbmNlUGFyc2VyLnByb3RvdHlwZS5jbGVhckV4ZWN1dGVIYW5kbGVyID0gZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgICAgaWYgKHRoaXMuX2V4ZWN1dGVIYW5kbGVyc1tmbGFnLmNoYXJDb2RlQXQoMCldKVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V4ZWN1dGVIYW5kbGVyc1tmbGFnLmNoYXJDb2RlQXQoMCldO1xuICAgIH07XG4gICAgRXNjYXBlU2VxdWVuY2VQYXJzZXIucHJvdG90eXBlLnNldEV4ZWN1dGVIYW5kbGVyRmFsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fZXhlY3V0ZUhhbmRsZXJGYiA9IGNhbGxiYWNrO1xuICAgIH07XG4gICAgRXNjYXBlU2VxdWVuY2VQYXJzZXIucHJvdG90eXBlLnNldENzaUhhbmRsZXIgPSBmdW5jdGlvbiAoZmxhZywgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fY3NpSGFuZGxlcnNbZmxhZy5jaGFyQ29kZUF0KDApXSA9IGNhbGxiYWNrO1xuICAgIH07XG4gICAgRXNjYXBlU2VxdWVuY2VQYXJzZXIucHJvdG90eXBlLmNsZWFyQ3NpSGFuZGxlciA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICAgIGlmICh0aGlzLl9jc2lIYW5kbGVyc1tmbGFnLmNoYXJDb2RlQXQoMCldKVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NzaUhhbmRsZXJzW2ZsYWcuY2hhckNvZGVBdCgwKV07XG4gICAgfTtcbiAgICBFc2NhcGVTZXF1ZW5jZVBhcnNlci5wcm90b3R5cGUuc2V0Q3NpSGFuZGxlckZhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2NzaUhhbmRsZXJGYiA9IGNhbGxiYWNrO1xuICAgIH07XG4gICAgRXNjYXBlU2VxdWVuY2VQYXJzZXIucHJvdG90eXBlLnNldEVzY0hhbmRsZXIgPSBmdW5jdGlvbiAoY29sbGVjdEFuZEZsYWcsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2VzY0hhbmRsZXJzW2NvbGxlY3RBbmRGbGFnXSA9IGNhbGxiYWNrO1xuICAgIH07XG4gICAgRXNjYXBlU2VxdWVuY2VQYXJzZXIucHJvdG90eXBlLmNsZWFyRXNjSGFuZGxlciA9IGZ1bmN0aW9uIChjb2xsZWN0QW5kRmxhZykge1xuICAgICAgICBpZiAodGhpcy5fZXNjSGFuZGxlcnNbY29sbGVjdEFuZEZsYWddKVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2VzY0hhbmRsZXJzW2NvbGxlY3RBbmRGbGFnXTtcbiAgICB9O1xuICAgIEVzY2FwZVNlcXVlbmNlUGFyc2VyLnByb3RvdHlwZS5zZXRFc2NIYW5kbGVyRmFsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fZXNjSGFuZGxlckZiID0gY2FsbGJhY2s7XG4gICAgfTtcbiAgICBFc2NhcGVTZXF1ZW5jZVBhcnNlci5wcm90b3R5cGUuc2V0T3NjSGFuZGxlciA9IGZ1bmN0aW9uIChpZGVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb3NjSGFuZGxlcnNbaWRlbnRdID0gY2FsbGJhY2s7XG4gICAgfTtcbiAgICBFc2NhcGVTZXF1ZW5jZVBhcnNlci5wcm90b3R5cGUuY2xlYXJPc2NIYW5kbGVyID0gZnVuY3Rpb24gKGlkZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9vc2NIYW5kbGVyc1tpZGVudF0pXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fb3NjSGFuZGxlcnNbaWRlbnRdO1xuICAgIH07XG4gICAgRXNjYXBlU2VxdWVuY2VQYXJzZXIucHJvdG90eXBlLnNldE9zY0hhbmRsZXJGYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vc2NIYW5kbGVyRmIgPSBjYWxsYmFjaztcbiAgICB9O1xuICAgIEVzY2FwZVNlcXVlbmNlUGFyc2VyLnByb3RvdHlwZS5zZXREY3NIYW5kbGVyID0gZnVuY3Rpb24gKGNvbGxlY3RBbmRGbGFnLCBoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX2Rjc0hhbmRsZXJzW2NvbGxlY3RBbmRGbGFnXSA9IGhhbmRsZXI7XG4gICAgfTtcbiAgICBFc2NhcGVTZXF1ZW5jZVBhcnNlci5wcm90b3R5cGUuY2xlYXJEY3NIYW5kbGVyID0gZnVuY3Rpb24gKGNvbGxlY3RBbmRGbGFnKSB7XG4gICAgICAgIGlmICh0aGlzLl9kY3NIYW5kbGVyc1tjb2xsZWN0QW5kRmxhZ10pXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fZGNzSGFuZGxlcnNbY29sbGVjdEFuZEZsYWddO1xuICAgIH07XG4gICAgRXNjYXBlU2VxdWVuY2VQYXJzZXIucHJvdG90eXBlLnNldERjc0hhbmRsZXJGYWxsYmFjayA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX2Rjc0hhbmRsZXJGYiA9IGhhbmRsZXI7XG4gICAgfTtcbiAgICBFc2NhcGVTZXF1ZW5jZVBhcnNlci5wcm90b3R5cGUuc2V0RXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2Vycm9ySGFuZGxlciA9IGNhbGxiYWNrO1xuICAgIH07XG4gICAgRXNjYXBlU2VxdWVuY2VQYXJzZXIucHJvdG90eXBlLmNsZWFyRXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9lcnJvckhhbmRsZXIgPSB0aGlzLl9lcnJvckhhbmRsZXJGYjtcbiAgICB9O1xuICAgIEVzY2FwZVNlcXVlbmNlUGFyc2VyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSB0aGlzLmluaXRpYWxTdGF0ZTtcbiAgICAgICAgdGhpcy5fb3NjID0gJyc7XG4gICAgICAgIHRoaXMuX3BhcmFtcyA9IFswXTtcbiAgICAgICAgdGhpcy5fY29sbGVjdCA9ICcnO1xuICAgICAgICB0aGlzLl9hY3RpdmVEY3NIYW5kbGVyID0gbnVsbDtcbiAgICB9O1xuICAgIEVzY2FwZVNlcXVlbmNlUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBjb2RlID0gMDtcbiAgICAgICAgdmFyIHRyYW5zaXRpb24gPSAwO1xuICAgICAgICB2YXIgZXJyb3IgPSBmYWxzZTtcbiAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHRoaXMuY3VycmVudFN0YXRlO1xuICAgICAgICB2YXIgcHJpbnQgPSAtMTtcbiAgICAgICAgdmFyIGRjcyA9IC0xO1xuICAgICAgICB2YXIgb3NjID0gdGhpcy5fb3NjO1xuICAgICAgICB2YXIgY29sbGVjdCA9IHRoaXMuX2NvbGxlY3Q7XG4gICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLl9wYXJhbXM7XG4gICAgICAgIHZhciB0YWJsZSA9IHRoaXMuVFJBTlNJVElPTlMudGFibGU7XG4gICAgICAgIHZhciBkY3NIYW5kbGVyID0gdGhpcy5fYWN0aXZlRGNzSGFuZGxlcjtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdmFyIGwgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIGNvZGUgPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFN0YXRlID09PSAwICYmIGNvZGUgPiAweDFmICYmIGNvZGUgPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgcHJpbnQgPSAofnByaW50KSA/IHByaW50IDogaTtcbiAgICAgICAgICAgICAgICBkb1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBsICYmIGRhdGEuY2hhckNvZGVBdChpKSA+IDB4MWYgJiYgZGF0YS5jaGFyQ29kZUF0KGkpIDwgMHg4MCk7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gNCAmJiAoY29kZSA+IDB4MmYgJiYgY29kZSA8IDB4MzkpKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zW3BhcmFtcy5sZW5ndGggLSAxXSA9IHBhcmFtc1twYXJhbXMubGVuZ3RoIC0gMV0gKiAxMCArIGNvZGUgLSA0ODtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYW5zaXRpb24gPSAoY29kZSA8IDB4YTApID8gKHRhYmxlW2N1cnJlbnRTdGF0ZSA8PCA4IHwgY29kZV0pIDogREVGQVVMVF9UUkFOU0lUSU9OO1xuICAgICAgICAgICAgc3dpdGNoICh0cmFuc2l0aW9uID4+IDQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHByaW50ID0gKH5wcmludCkgPyBwcmludCA6IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKH5wcmludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpbnRIYW5kbGVyKGRhdGEsIHByaW50LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW50ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSB0aGlzLl9leGVjdXRlSGFuZGxlcnNbY29kZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2V4ZWN1dGVIYW5kbGVyRmIoY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKH5wcmludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpbnRIYW5kbGVyKGRhdGEsIHByaW50LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW50ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAofmRjcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGNzSGFuZGxlci5wdXQoZGF0YSwgZGNzLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRjcyA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPiAweDlmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGN1cnJlbnRTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQgPSAofnByaW50KSA/IHByaW50IDogaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvc2MgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbiB8PSA4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24gfD0gNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbiB8PSAxMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGNzID0gKH5kY3MpID8gZGNzIDogaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbiB8PSAxMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluamVjdCA9IHRoaXMuX2Vycm9ySGFuZGxlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGU6IGN1cnJlbnRTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmludDogcHJpbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGNzOiBkY3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3NjOiBvc2MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdDogY29sbGVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluamVjdC5hYm9ydClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSB0aGlzLl9jc2lIYW5kbGVyc1tjb2RlXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socGFyYW1zLCBjb2xsZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3NpSGFuZGxlckZiKGNvbGxlY3QsIHBhcmFtcywgY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IDB4M2IpXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucHVzaCgwKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zW3BhcmFtcy5sZW5ndGggLSAxXSA9IHBhcmFtc1twYXJhbXMubGVuZ3RoIC0gMV0gKiAxMCArIGNvZGUgLSA0ODtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gdGhpcy5fZXNjSGFuZGxlcnNbY29sbGVjdCArIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhjb2xsZWN0LCBjb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXNjSGFuZGxlckZiKGNvbGxlY3QsIGNvZGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICBpZiAofnByaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmludEhhbmRsZXIoZGF0YSwgcHJpbnQsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvc2MgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gWzBdO1xuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGRjcyA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICBkY3NIYW5kbGVyID0gdGhpcy5fZGNzSGFuZGxlcnNbY29sbGVjdCArIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRjc0hhbmRsZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBkY3NIYW5kbGVyID0gdGhpcy5fZGNzSGFuZGxlckZiO1xuICAgICAgICAgICAgICAgICAgICBkY3NIYW5kbGVyLmhvb2soY29sbGVjdCwgcGFyYW1zLCBjb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgZGNzID0gKH5kY3MpID8gZGNzIDogaTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRjc0hhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh+ZGNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRjc0hhbmRsZXIucHV0KGRhdGEsIGRjcywgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkY3NIYW5kbGVyLnVuaG9vaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGNzSGFuZGxlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IDB4MWIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uIHw9IDE7XG4gICAgICAgICAgICAgICAgICAgIG9zYyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBbMF07XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3QgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgZGNzID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKH5wcmludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpbnRIYW5kbGVyKGRhdGEsIHByaW50LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW50ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3NjID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgb3NjICs9IGRhdGEuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIGlmIChvc2MgJiYgY29kZSAhPT0gMHgxOCAmJiBjb2RlICE9PSAweDFhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gb3NjLmluZGV4T2YoJzsnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3NjSGFuZGxlckZiKC0xLCBvc2MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkZW50aWZpZXIgPSBwYXJzZUludChvc2Muc3Vic3RyaW5nKDAsIGlkeCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gb3NjLnN1YnN0cmluZyhpZHggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHRoaXMuX29zY0hhbmRsZXJzW2lkZW50aWZpZXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vc2NIYW5kbGVyRmIoaWRlbnRpZmllciwgY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IDB4MWIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uIHw9IDE7XG4gICAgICAgICAgICAgICAgICAgIG9zYyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBbMF07XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3QgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgZGNzID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFN0YXRlID0gdHJhbnNpdGlvbiAmIDE1O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50U3RhdGUgPT09IDAgJiYgfnByaW50KSB7XG4gICAgICAgICAgICB0aGlzLl9wcmludEhhbmRsZXIoZGF0YSwgcHJpbnQsIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyZW50U3RhdGUgPT09IDEzICYmIH5kY3MgJiYgZGNzSGFuZGxlcikge1xuICAgICAgICAgICAgZGNzSGFuZGxlci5wdXQoZGF0YSwgZGNzLCBkYXRhLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb3NjID0gb3NjO1xuICAgICAgICB0aGlzLl9jb2xsZWN0ID0gY29sbGVjdDtcbiAgICAgICAgdGhpcy5fcGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB0aGlzLl9hY3RpdmVEY3NIYW5kbGVyID0gZGNzSGFuZGxlcjtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBjdXJyZW50U3RhdGU7XG4gICAgfTtcbiAgICByZXR1cm4gRXNjYXBlU2VxdWVuY2VQYXJzZXI7XG59KExpZmVjeWNsZV8xLkRpc3Bvc2FibGUpKTtcbmV4cG9ydHMuRXNjYXBlU2VxdWVuY2VQYXJzZXIgPSBFc2NhcGVTZXF1ZW5jZVBhcnNlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVzY2FwZVNlcXVlbmNlUGFyc2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBFc2NhcGVTZXF1ZW5jZXNfMSA9IHJlcXVpcmUoXCIuL2NvbW1vbi9kYXRhL0VzY2FwZVNlcXVlbmNlc1wiKTtcbnZhciBDaGFyc2V0c18xID0gcmVxdWlyZShcIi4vY29yZS9kYXRhL0NoYXJzZXRzXCIpO1xudmFyIEJ1ZmZlcl8xID0gcmVxdWlyZShcIi4vQnVmZmVyXCIpO1xudmFyIENoYXJXaWR0aF8xID0gcmVxdWlyZShcIi4vQ2hhcldpZHRoXCIpO1xudmFyIEVzY2FwZVNlcXVlbmNlUGFyc2VyXzEgPSByZXF1aXJlKFwiLi9Fc2NhcGVTZXF1ZW5jZVBhcnNlclwiKTtcbnZhciBMaWZlY3ljbGVfMSA9IHJlcXVpcmUoXCIuL2NvbW1vbi9MaWZlY3ljbGVcIik7XG52YXIgQnVmZmVyTGluZV8xID0gcmVxdWlyZShcIi4vQnVmZmVyTGluZVwiKTtcbnZhciBHTEVWRUwgPSB7ICcoJzogMCwgJyknOiAxLCAnKic6IDIsICcrJzogMywgJy0nOiAxLCAnLic6IDIgfTtcbnZhciBSZXF1ZXN0VGVybWluZm8gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlcXVlc3RUZXJtaW5mbyhfdGVybWluYWwpIHtcbiAgICAgICAgdGhpcy5fdGVybWluYWwgPSBfdGVybWluYWw7XG4gICAgfVxuICAgIFJlcXVlc3RUZXJtaW5mby5wcm90b3R5cGUuaG9vayA9IGZ1bmN0aW9uIChjb2xsZWN0LCBwYXJhbXMsIGZsYWcpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9ICcnO1xuICAgIH07XG4gICAgUmVxdWVzdFRlcm1pbmZvLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLl9kYXRhICs9IGRhdGEuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpO1xuICAgIH07XG4gICAgUmVxdWVzdFRlcm1pbmZvLnByb3RvdHlwZS51bmhvb2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsLmhhbmRsZXIoRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgXCJQMCtyXCIgKyB0aGlzLl9kYXRhICsgRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgXCJcXFxcXCIpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlcXVlc3RUZXJtaW5mbztcbn0oKSk7XG52YXIgREVDUlFTUyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gREVDUlFTUyhfdGVybWluYWwpIHtcbiAgICAgICAgdGhpcy5fdGVybWluYWwgPSBfdGVybWluYWw7XG4gICAgfVxuICAgIERFQ1JRU1MucHJvdG90eXBlLmhvb2sgPSBmdW5jdGlvbiAoY29sbGVjdCwgcGFyYW1zLCBmbGFnKSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSAnJztcbiAgICB9O1xuICAgIERFQ1JRU1MucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHRoaXMuX2RhdGEgKz0gZGF0YS5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgfTtcbiAgICBERUNSUVNTLnByb3RvdHlwZS51bmhvb2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fZGF0YSkge1xuICAgICAgICAgICAgY2FzZSAnXCJxJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGVybWluYWwuaGFuZGxlcihFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyBcIlAxJHIwXFxcInFcIiArIEVzY2FwZVNlcXVlbmNlc18xLkMwLkVTQyArIFwiXFxcXFwiKTtcbiAgICAgICAgICAgIGNhc2UgJ1wicCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Rlcm1pbmFsLmhhbmRsZXIoRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgXCJQMSRyNjFcXFwicFwiICsgRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgXCJcXFxcXCIpO1xuICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgICAgdmFyIHB0ID0gJycgKyAodGhpcy5fdGVybWluYWwuYnVmZmVyLnNjcm9sbFRvcCArIDEpICtcbiAgICAgICAgICAgICAgICAgICAgJzsnICsgKHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci5zY3JvbGxCb3R0b20gKyAxKSArICdyJztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGVybWluYWwuaGFuZGxlcihFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyBcIlAxJHJcIiArIHB0ICsgRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgXCJcXFxcXCIpO1xuICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Rlcm1pbmFsLmhhbmRsZXIoRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgXCJQMSRyMG1cIiArIEVzY2FwZVNlcXVlbmNlc18xLkMwLkVTQyArIFwiXFxcXFwiKTtcbiAgICAgICAgICAgIGNhc2UgJyBxJzpcbiAgICAgICAgICAgICAgICB2YXIgU1RZTEVTID0geyAnYmxvY2snOiAyLCAndW5kZXJsaW5lJzogNCwgJ2Jhcic6IDYgfTtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBTVFlMRVNbdGhpcy5fdGVybWluYWwuZ2V0T3B0aW9uKCdjdXJzb3JTdHlsZScpXTtcbiAgICAgICAgICAgICAgICBzdHlsZSAtPSB0aGlzLl90ZXJtaW5hbC5nZXRPcHRpb24oJ2N1cnNvckJsaW5rJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Rlcm1pbmFsLmhhbmRsZXIoRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgXCJQMSRyXCIgKyBzdHlsZSArIFwiIHFcIiArIEVzY2FwZVNlcXVlbmNlc18xLkMwLkVTQyArIFwiXFxcXFwiKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuZXJyb3IoJ1Vua25vd24gRENTICRxICVzJywgdGhpcy5fZGF0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuaGFuZGxlcihFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyBcIlAwJHJcIiArIHRoaXMuX2RhdGEgKyBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyBcIlxcXFxcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBERUNSUVNTO1xufSgpKTtcbnZhciBJbnB1dEhhbmRsZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbnB1dEhhbmRsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5wdXRIYW5kbGVyKF90ZXJtaW5hbCwgX3BhcnNlcikge1xuICAgICAgICBpZiAoX3BhcnNlciA9PT0gdm9pZCAwKSB7IF9wYXJzZXIgPSBuZXcgRXNjYXBlU2VxdWVuY2VQYXJzZXJfMS5Fc2NhcGVTZXF1ZW5jZVBhcnNlcigpOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl90ZXJtaW5hbCA9IF90ZXJtaW5hbDtcbiAgICAgICAgX3RoaXMuX3BhcnNlciA9IF9wYXJzZXI7XG4gICAgICAgIF90aGlzLnJlZ2lzdGVyKF90aGlzLl9wYXJzZXIpO1xuICAgICAgICBfdGhpcy5fc3Vycm9nYXRlSGlnaCA9ICcnO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldENzaUhhbmRsZXJGYWxsYmFjayhmdW5jdGlvbiAoY29sbGVjdCwgcGFyYW1zLCBmbGFnKSB7XG4gICAgICAgICAgICBfdGhpcy5fdGVybWluYWwuZXJyb3IoJ1Vua25vd24gQ1NJIGNvZGU6ICcsIHsgY29sbGVjdDogY29sbGVjdCwgcGFyYW1zOiBwYXJhbXMsIGZsYWc6IFN0cmluZy5mcm9tQ2hhckNvZGUoZmxhZykgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldEVzY0hhbmRsZXJGYWxsYmFjayhmdW5jdGlvbiAoY29sbGVjdCwgZmxhZykge1xuICAgICAgICAgICAgX3RoaXMuX3Rlcm1pbmFsLmVycm9yKCdVbmtub3duIEVTQyBjb2RlOiAnLCB7IGNvbGxlY3Q6IGNvbGxlY3QsIGZsYWc6IFN0cmluZy5mcm9tQ2hhckNvZGUoZmxhZykgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldEV4ZWN1dGVIYW5kbGVyRmFsbGJhY2soZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgICAgIF90aGlzLl90ZXJtaW5hbC5lcnJvcignVW5rbm93biBFWEVDVVRFIGNvZGU6ICcsIHsgY29kZTogY29kZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLl9wYXJzZXIuc2V0T3NjSGFuZGxlckZhbGxiYWNrKGZ1bmN0aW9uIChpZGVudGlmaWVyLCBkYXRhKSB7XG4gICAgICAgICAgICBfdGhpcy5fdGVybWluYWwuZXJyb3IoJ1Vua25vd24gT1NDIGNvZGU6ICcsIHsgaWRlbnRpZmllcjogaWRlbnRpZmllciwgZGF0YTogZGF0YSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLl9wYXJzZXIuc2V0UHJpbnRIYW5kbGVyKGZ1bmN0aW9uIChkYXRhLCBzdGFydCwgZW5kKSB7IHJldHVybiBfdGhpcy5wcmludChkYXRhLCBzdGFydCwgZW5kKTsgfSk7XG4gICAgICAgIF90aGlzLl9wYXJzZXIuc2V0Q3NpSGFuZGxlcignQCcsIGZ1bmN0aW9uIChwYXJhbXMsIGNvbGxlY3QpIHsgcmV0dXJuIF90aGlzLmluc2VydENoYXJzKHBhcmFtcyk7IH0pO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldENzaUhhbmRsZXIoJ0EnLCBmdW5jdGlvbiAocGFyYW1zLCBjb2xsZWN0KSB7IHJldHVybiBfdGhpcy5jdXJzb3JVcChwYXJhbXMpOyB9KTtcbiAgICAgICAgX3RoaXMuX3BhcnNlci5zZXRDc2lIYW5kbGVyKCdCJywgZnVuY3Rpb24gKHBhcmFtcywgY29sbGVjdCkgeyByZXR1cm4gX3RoaXMuY3Vyc29yRG93bihwYXJhbXMpOyB9KTtcbiAgICAgICAgX3RoaXMuX3BhcnNlci5zZXRDc2lIYW5kbGVyKCdDJywgZnVuY3Rpb24gKHBhcmFtcywgY29sbGVjdCkgeyByZXR1cm4gX3RoaXMuY3Vyc29yRm9yd2FyZChwYXJhbXMpOyB9KTtcbiAgICAgICAgX3RoaXMuX3BhcnNlci5zZXRDc2lIYW5kbGVyKCdEJywgZnVuY3Rpb24gKHBhcmFtcywgY29sbGVjdCkgeyByZXR1cm4gX3RoaXMuY3Vyc29yQmFja3dhcmQocGFyYW1zKTsgfSk7XG4gICAgICAgIF90aGlzLl9wYXJzZXIuc2V0Q3NpSGFuZGxlcignRScsIGZ1bmN0aW9uIChwYXJhbXMsIGNvbGxlY3QpIHsgcmV0dXJuIF90aGlzLmN1cnNvck5leHRMaW5lKHBhcmFtcyk7IH0pO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldENzaUhhbmRsZXIoJ0YnLCBmdW5jdGlvbiAocGFyYW1zLCBjb2xsZWN0KSB7IHJldHVybiBfdGhpcy5jdXJzb3JQcmVjZWRpbmdMaW5lKHBhcmFtcyk7IH0pO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldENzaUhhbmRsZXIoJ0cnLCBmdW5jdGlvbiAocGFyYW1zLCBjb2xsZWN0KSB7IHJldHVybiBfdGhpcy5jdXJzb3JDaGFyQWJzb2x1dGUocGFyYW1zKTsgfSk7XG4gICAgICAgIF90aGlzLl9wYXJzZXIuc2V0Q3NpSGFuZGxlcignSCcsIGZ1bmN0aW9uIChwYXJhbXMsIGNvbGxlY3QpIHsgcmV0dXJuIF90aGlzLmN1cnNvclBvc2l0aW9uKHBhcmFtcyk7IH0pO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldENzaUhhbmRsZXIoJ0knLCBmdW5jdGlvbiAocGFyYW1zLCBjb2xsZWN0KSB7IHJldHVybiBfdGhpcy5jdXJzb3JGb3J3YXJkVGFiKHBhcmFtcyk7IH0pO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldENzaUhhbmRsZXIoJ0onLCBmdW5jdGlvbiAocGFyYW1zLCBjb2xsZWN0KSB7IHJldHVybiBfdGhpcy5lcmFzZUluRGlzcGxheShwYXJhbXMpOyB9KTtcbiAgICAgICAgX3RoaXMuX3BhcnNlci5zZXRDc2lIYW5kbGVyKCdLJywgZnVuY3Rpb24gKHBhcmFtcywgY29sbGVjdCkgeyByZXR1cm4gX3RoaXMuZXJhc2VJbkxpbmUocGFyYW1zKTsgfSk7XG4gICAgICAgIF90aGlzLl9wYXJzZXIuc2V0Q3NpSGFuZGxlcignTCcsIGZ1bmN0aW9uIChwYXJhbXMsIGNvbGxlY3QpIHsgcmV0dXJuIF90aGlzLmluc2VydExpbmVzKHBhcmFtcyk7IH0pO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldENzaUhhbmRsZXIoJ00nLCBmdW5jdGlvbiAocGFyYW1zLCBjb2xsZWN0KSB7IHJldHVybiBfdGhpcy5kZWxldGVMaW5lcyhwYXJhbXMpOyB9KTtcbiAgICAgICAgX3RoaXMuX3BhcnNlci5zZXRDc2lIYW5kbGVyKCdQJywgZnVuY3Rpb24gKHBhcmFtcywgY29sbGVjdCkgeyByZXR1cm4gX3RoaXMuZGVsZXRlQ2hhcnMocGFyYW1zKTsgfSk7XG4gICAgICAgIF90aGlzLl9wYXJzZXIuc2V0Q3NpSGFuZGxlcignUycsIGZ1bmN0aW9uIChwYXJhbXMsIGNvbGxlY3QpIHsgcmV0dXJuIF90aGlzLnNjcm9sbFVwKHBhcmFtcyk7IH0pO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldENzaUhhbmRsZXIoJ1QnLCBmdW5jdGlvbiAocGFyYW1zLCBjb2xsZWN0KSB7IHJldHVybiBfdGhpcy5zY3JvbGxEb3duKHBhcmFtcywgY29sbGVjdCk7IH0pO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldENzaUhhbmRsZXIoJ1gnLCBmdW5jdGlvbiAocGFyYW1zLCBjb2xsZWN0KSB7IHJldHVybiBfdGhpcy5lcmFzZUNoYXJzKHBhcmFtcyk7IH0pO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldENzaUhhbmRsZXIoJ1onLCBmdW5jdGlvbiAocGFyYW1zLCBjb2xsZWN0KSB7IHJldHVybiBfdGhpcy5jdXJzb3JCYWNrd2FyZFRhYihwYXJhbXMpOyB9KTtcbiAgICAgICAgX3RoaXMuX3BhcnNlci5zZXRDc2lIYW5kbGVyKCdgJywgZnVuY3Rpb24gKHBhcmFtcywgY29sbGVjdCkgeyByZXR1cm4gX3RoaXMuY2hhclBvc0Fic29sdXRlKHBhcmFtcyk7IH0pO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldENzaUhhbmRsZXIoJ2EnLCBmdW5jdGlvbiAocGFyYW1zLCBjb2xsZWN0KSB7IHJldHVybiBfdGhpcy5oUG9zaXRpb25SZWxhdGl2ZShwYXJhbXMpOyB9KTtcbiAgICAgICAgX3RoaXMuX3BhcnNlci5zZXRDc2lIYW5kbGVyKCdiJywgZnVuY3Rpb24gKHBhcmFtcywgY29sbGVjdCkgeyByZXR1cm4gX3RoaXMucmVwZWF0UHJlY2VkaW5nQ2hhcmFjdGVyKHBhcmFtcyk7IH0pO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldENzaUhhbmRsZXIoJ2MnLCBmdW5jdGlvbiAocGFyYW1zLCBjb2xsZWN0KSB7IHJldHVybiBfdGhpcy5zZW5kRGV2aWNlQXR0cmlidXRlcyhwYXJhbXMsIGNvbGxlY3QpOyB9KTtcbiAgICAgICAgX3RoaXMuX3BhcnNlci5zZXRDc2lIYW5kbGVyKCdkJywgZnVuY3Rpb24gKHBhcmFtcywgY29sbGVjdCkgeyByZXR1cm4gX3RoaXMubGluZVBvc0Fic29sdXRlKHBhcmFtcyk7IH0pO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldENzaUhhbmRsZXIoJ2UnLCBmdW5jdGlvbiAocGFyYW1zLCBjb2xsZWN0KSB7IHJldHVybiBfdGhpcy52UG9zaXRpb25SZWxhdGl2ZShwYXJhbXMpOyB9KTtcbiAgICAgICAgX3RoaXMuX3BhcnNlci5zZXRDc2lIYW5kbGVyKCdmJywgZnVuY3Rpb24gKHBhcmFtcywgY29sbGVjdCkgeyByZXR1cm4gX3RoaXMuaFZQb3NpdGlvbihwYXJhbXMpOyB9KTtcbiAgICAgICAgX3RoaXMuX3BhcnNlci5zZXRDc2lIYW5kbGVyKCdnJywgZnVuY3Rpb24gKHBhcmFtcywgY29sbGVjdCkgeyByZXR1cm4gX3RoaXMudGFiQ2xlYXIocGFyYW1zKTsgfSk7XG4gICAgICAgIF90aGlzLl9wYXJzZXIuc2V0Q3NpSGFuZGxlcignaCcsIGZ1bmN0aW9uIChwYXJhbXMsIGNvbGxlY3QpIHsgcmV0dXJuIF90aGlzLnNldE1vZGUocGFyYW1zLCBjb2xsZWN0KTsgfSk7XG4gICAgICAgIF90aGlzLl9wYXJzZXIuc2V0Q3NpSGFuZGxlcignbCcsIGZ1bmN0aW9uIChwYXJhbXMsIGNvbGxlY3QpIHsgcmV0dXJuIF90aGlzLnJlc2V0TW9kZShwYXJhbXMsIGNvbGxlY3QpOyB9KTtcbiAgICAgICAgX3RoaXMuX3BhcnNlci5zZXRDc2lIYW5kbGVyKCdtJywgZnVuY3Rpb24gKHBhcmFtcywgY29sbGVjdCkgeyByZXR1cm4gX3RoaXMuY2hhckF0dHJpYnV0ZXMocGFyYW1zKTsgfSk7XG4gICAgICAgIF90aGlzLl9wYXJzZXIuc2V0Q3NpSGFuZGxlcignbicsIGZ1bmN0aW9uIChwYXJhbXMsIGNvbGxlY3QpIHsgcmV0dXJuIF90aGlzLmRldmljZVN0YXR1cyhwYXJhbXMsIGNvbGxlY3QpOyB9KTtcbiAgICAgICAgX3RoaXMuX3BhcnNlci5zZXRDc2lIYW5kbGVyKCdwJywgZnVuY3Rpb24gKHBhcmFtcywgY29sbGVjdCkgeyByZXR1cm4gX3RoaXMuc29mdFJlc2V0KHBhcmFtcywgY29sbGVjdCk7IH0pO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldENzaUhhbmRsZXIoJ3EnLCBmdW5jdGlvbiAocGFyYW1zLCBjb2xsZWN0KSB7IHJldHVybiBfdGhpcy5zZXRDdXJzb3JTdHlsZShwYXJhbXMsIGNvbGxlY3QpOyB9KTtcbiAgICAgICAgX3RoaXMuX3BhcnNlci5zZXRDc2lIYW5kbGVyKCdyJywgZnVuY3Rpb24gKHBhcmFtcywgY29sbGVjdCkgeyByZXR1cm4gX3RoaXMuc2V0U2Nyb2xsUmVnaW9uKHBhcmFtcywgY29sbGVjdCk7IH0pO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldENzaUhhbmRsZXIoJ3MnLCBmdW5jdGlvbiAocGFyYW1zLCBjb2xsZWN0KSB7IHJldHVybiBfdGhpcy5zYXZlQ3Vyc29yKHBhcmFtcyk7IH0pO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldENzaUhhbmRsZXIoJ3UnLCBmdW5jdGlvbiAocGFyYW1zLCBjb2xsZWN0KSB7IHJldHVybiBfdGhpcy5yZXN0b3JlQ3Vyc29yKHBhcmFtcyk7IH0pO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldEV4ZWN1dGVIYW5kbGVyKEVzY2FwZVNlcXVlbmNlc18xLkMwLkJFTCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuYmVsbCgpOyB9KTtcbiAgICAgICAgX3RoaXMuX3BhcnNlci5zZXRFeGVjdXRlSGFuZGxlcihFc2NhcGVTZXF1ZW5jZXNfMS5DMC5MRiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMubGluZUZlZWQoKTsgfSk7XG4gICAgICAgIF90aGlzLl9wYXJzZXIuc2V0RXhlY3V0ZUhhbmRsZXIoRXNjYXBlU2VxdWVuY2VzXzEuQzAuVlQsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmxpbmVGZWVkKCk7IH0pO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldEV4ZWN1dGVIYW5kbGVyKEVzY2FwZVNlcXVlbmNlc18xLkMwLkZGLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5saW5lRmVlZCgpOyB9KTtcbiAgICAgICAgX3RoaXMuX3BhcnNlci5zZXRFeGVjdXRlSGFuZGxlcihFc2NhcGVTZXF1ZW5jZXNfMS5DMC5DUiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY2FycmlhZ2VSZXR1cm4oKTsgfSk7XG4gICAgICAgIF90aGlzLl9wYXJzZXIuc2V0RXhlY3V0ZUhhbmRsZXIoRXNjYXBlU2VxdWVuY2VzXzEuQzAuQlMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmJhY2tzcGFjZSgpOyB9KTtcbiAgICAgICAgX3RoaXMuX3BhcnNlci5zZXRFeGVjdXRlSGFuZGxlcihFc2NhcGVTZXF1ZW5jZXNfMS5DMC5IVCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudGFiKCk7IH0pO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldEV4ZWN1dGVIYW5kbGVyKEVzY2FwZVNlcXVlbmNlc18xLkMwLlNPLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zaGlmdE91dCgpOyB9KTtcbiAgICAgICAgX3RoaXMuX3BhcnNlci5zZXRFeGVjdXRlSGFuZGxlcihFc2NhcGVTZXF1ZW5jZXNfMS5DMC5TSSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2hpZnRJbigpOyB9KTtcbiAgICAgICAgX3RoaXMuX3BhcnNlci5zZXRFeGVjdXRlSGFuZGxlcihFc2NhcGVTZXF1ZW5jZXNfMS5DMS5JTkQsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmluZGV4KCk7IH0pO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldEV4ZWN1dGVIYW5kbGVyKEVzY2FwZVNlcXVlbmNlc18xLkMxLk5FTCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMubmV4dExpbmUoKTsgfSk7XG4gICAgICAgIF90aGlzLl9wYXJzZXIuc2V0RXhlY3V0ZUhhbmRsZXIoRXNjYXBlU2VxdWVuY2VzXzEuQzEuSFRTLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy50YWJTZXQoKTsgfSk7XG4gICAgICAgIF90aGlzLl9wYXJzZXIuc2V0T3NjSGFuZGxlcigwLCBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gX3RoaXMuc2V0VGl0bGUoZGF0YSk7IH0pO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldE9zY0hhbmRsZXIoMiwgZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIF90aGlzLnNldFRpdGxlKGRhdGEpOyB9KTtcbiAgICAgICAgX3RoaXMuX3BhcnNlci5zZXRFc2NIYW5kbGVyKCc3JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2F2ZUN1cnNvcihbXSk7IH0pO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldEVzY0hhbmRsZXIoJzgnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5yZXN0b3JlQ3Vyc29yKFtdKTsgfSk7XG4gICAgICAgIF90aGlzLl9wYXJzZXIuc2V0RXNjSGFuZGxlcignRCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmluZGV4KCk7IH0pO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldEVzY0hhbmRsZXIoJ0UnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5uZXh0TGluZSgpOyB9KTtcbiAgICAgICAgX3RoaXMuX3BhcnNlci5zZXRFc2NIYW5kbGVyKCdIJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudGFiU2V0KCk7IH0pO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldEVzY0hhbmRsZXIoJ00nLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5yZXZlcnNlSW5kZXgoKTsgfSk7XG4gICAgICAgIF90aGlzLl9wYXJzZXIuc2V0RXNjSGFuZGxlcignPScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmtleXBhZEFwcGxpY2F0aW9uTW9kZSgpOyB9KTtcbiAgICAgICAgX3RoaXMuX3BhcnNlci5zZXRFc2NIYW5kbGVyKCc+JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMua2V5cGFkTnVtZXJpY01vZGUoKTsgfSk7XG4gICAgICAgIF90aGlzLl9wYXJzZXIuc2V0RXNjSGFuZGxlcignYycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnJlc2V0KCk7IH0pO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldEVzY0hhbmRsZXIoJ24nLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zZXRnTGV2ZWwoMik7IH0pO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldEVzY0hhbmRsZXIoJ28nLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zZXRnTGV2ZWwoMyk7IH0pO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldEVzY0hhbmRsZXIoJ3wnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zZXRnTGV2ZWwoMyk7IH0pO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldEVzY0hhbmRsZXIoJ30nLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zZXRnTGV2ZWwoMik7IH0pO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldEVzY0hhbmRsZXIoJ34nLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zZXRnTGV2ZWwoMSk7IH0pO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldEVzY0hhbmRsZXIoJyVAJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2VsZWN0RGVmYXVsdENoYXJzZXQoKTsgfSk7XG4gICAgICAgIF90aGlzLl9wYXJzZXIuc2V0RXNjSGFuZGxlcignJUcnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zZWxlY3REZWZhdWx0Q2hhcnNldCgpOyB9KTtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoZmxhZykge1xuICAgICAgICAgICAgdGhpc18xLl9wYXJzZXIuc2V0RXNjSGFuZGxlcignKCcgKyBmbGFnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zZWxlY3RDaGFyc2V0KCcoJyArIGZsYWcpOyB9KTtcbiAgICAgICAgICAgIHRoaXNfMS5fcGFyc2VyLnNldEVzY0hhbmRsZXIoJyknICsgZmxhZywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2VsZWN0Q2hhcnNldCgnKScgKyBmbGFnKTsgfSk7XG4gICAgICAgICAgICB0aGlzXzEuX3BhcnNlci5zZXRFc2NIYW5kbGVyKCcqJyArIGZsYWcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNlbGVjdENoYXJzZXQoJyonICsgZmxhZyk7IH0pO1xuICAgICAgICAgICAgdGhpc18xLl9wYXJzZXIuc2V0RXNjSGFuZGxlcignKycgKyBmbGFnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zZWxlY3RDaGFyc2V0KCcrJyArIGZsYWcpOyB9KTtcbiAgICAgICAgICAgIHRoaXNfMS5fcGFyc2VyLnNldEVzY0hhbmRsZXIoJy0nICsgZmxhZywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2VsZWN0Q2hhcnNldCgnLScgKyBmbGFnKTsgfSk7XG4gICAgICAgICAgICB0aGlzXzEuX3BhcnNlci5zZXRFc2NIYW5kbGVyKCcuJyArIGZsYWcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNlbGVjdENoYXJzZXQoJy4nICsgZmxhZyk7IH0pO1xuICAgICAgICAgICAgdGhpc18xLl9wYXJzZXIuc2V0RXNjSGFuZGxlcignLycgKyBmbGFnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zZWxlY3RDaGFyc2V0KCcvJyArIGZsYWcpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgIGZvciAodmFyIGZsYWcgaW4gQ2hhcnNldHNfMS5DSEFSU0VUUykge1xuICAgICAgICAgICAgX2xvb3BfMShmbGFnKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldEVycm9ySGFuZGxlcihmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICAgIF90aGlzLl90ZXJtaW5hbC5lcnJvcignUGFyc2luZyBlcnJvcjogJywgc3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMuX3BhcnNlci5zZXREY3NIYW5kbGVyKCckcScsIG5ldyBERUNSUVNTKF90aGlzLl90ZXJtaW5hbCkpO1xuICAgICAgICBfdGhpcy5fcGFyc2VyLnNldERjc0hhbmRsZXIoJytxJywgbmV3IFJlcXVlc3RUZXJtaW5mbyhfdGhpcy5fdGVybWluYWwpKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBJbnB1dEhhbmRsZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl90ZXJtaW5hbCA9IG51bGw7XG4gICAgfTtcbiAgICBJbnB1dEhhbmRsZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90ZXJtaW5hbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLl90ZXJtaW5hbC5idWZmZXI7XG4gICAgICAgIHZhciBjdXJzb3JTdGFydFggPSBidWZmZXIueDtcbiAgICAgICAgdmFyIGN1cnNvclN0YXJ0WSA9IGJ1ZmZlci55O1xuICAgICAgICBpZiAodGhpcy5fdGVybWluYWwuZGVidWcpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLmxvZygnZGF0YTogJyArIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zdXJyb2dhdGVIaWdoKSB7XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5fc3Vycm9nYXRlSGlnaCArIGRhdGE7XG4gICAgICAgICAgICB0aGlzLl9zdXJyb2dhdGVIaWdoID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGFyc2VyLnBhcnNlKGRhdGEpO1xuICAgICAgICBidWZmZXIgPSB0aGlzLl90ZXJtaW5hbC5idWZmZXI7XG4gICAgICAgIGlmIChidWZmZXIueCAhPT0gY3Vyc29yU3RhcnRYIHx8IGJ1ZmZlci55ICE9PSBjdXJzb3JTdGFydFkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLmVtaXQoJ2N1cnNvcm1vdmUnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5wdXRIYW5kbGVyLnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uIChkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHZhciBjaGFyO1xuICAgICAgICB2YXIgY29kZTtcbiAgICAgICAgdmFyIGxvdztcbiAgICAgICAgdmFyIGNoV2lkdGg7XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLl90ZXJtaW5hbC5idWZmZXI7XG4gICAgICAgIHZhciBjaGFyc2V0ID0gdGhpcy5fdGVybWluYWwuY2hhcnNldDtcbiAgICAgICAgdmFyIHNjcmVlblJlYWRlck1vZGUgPSB0aGlzLl90ZXJtaW5hbC5vcHRpb25zLnNjcmVlblJlYWRlck1vZGU7XG4gICAgICAgIHZhciBjb2xzID0gdGhpcy5fdGVybWluYWwuY29scztcbiAgICAgICAgdmFyIHdyYXBhcm91bmRNb2RlID0gdGhpcy5fdGVybWluYWwud3JhcGFyb3VuZE1vZGU7XG4gICAgICAgIHZhciBpbnNlcnRNb2RlID0gdGhpcy5fdGVybWluYWwuaW5zZXJ0TW9kZTtcbiAgICAgICAgdmFyIGN1ckF0dHIgPSB0aGlzLl90ZXJtaW5hbC5jdXJBdHRyO1xuICAgICAgICB2YXIgYnVmZmVyUm93ID0gYnVmZmVyLmxpbmVzLmdldChidWZmZXIueSArIGJ1ZmZlci55YmFzZSk7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsLnVwZGF0ZVJhbmdlKGJ1ZmZlci55KTtcbiAgICAgICAgZm9yICh2YXIgc3RyaW5nUG9zaXRpb24gPSBzdGFydDsgc3RyaW5nUG9zaXRpb24gPCBlbmQ7ICsrc3RyaW5nUG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNoYXIgPSBkYXRhLmNoYXJBdChzdHJpbmdQb3NpdGlvbik7XG4gICAgICAgICAgICBjb2RlID0gZGF0YS5jaGFyQ29kZUF0KHN0cmluZ1Bvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmICgweEQ4MDAgPD0gY29kZSAmJiBjb2RlIDw9IDB4REJGRikge1xuICAgICAgICAgICAgICAgIGxvdyA9IGRhdGEuY2hhckNvZGVBdChzdHJpbmdQb3NpdGlvbiArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihsb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N1cnJvZ2F0ZUhpZ2ggPSBjaGFyO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29kZSA9ICgoY29kZSAtIDB4RDgwMCkgKiAweDQwMCkgKyAobG93IC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gICAgICAgICAgICAgICAgY2hhciArPSBkYXRhLmNoYXJBdChzdHJpbmdQb3NpdGlvbiArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKDB4REMwMCA8PSBjb2RlICYmIGNvZGUgPD0gMHhERkZGKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaFdpZHRoID0gQ2hhcldpZHRoXzEud2N3aWR0aChjb2RlKTtcbiAgICAgICAgICAgIGlmIChjaGFyc2V0KSB7XG4gICAgICAgICAgICAgICAgY2hhciA9IGNoYXJzZXRbY2hhcl0gfHwgY2hhcjtcbiAgICAgICAgICAgICAgICBjb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjcmVlblJlYWRlck1vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC5lbWl0KCdhMTF5LmNoYXInLCBjaGFyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2hXaWR0aCAmJiBidWZmZXIueCkge1xuICAgICAgICAgICAgICAgIHZhciBjaE1pbnVzT25lID0gYnVmZmVyUm93LmdldChidWZmZXIueCAtIDEpO1xuICAgICAgICAgICAgICAgIGlmIChjaE1pbnVzT25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hNaW51c09uZVtCdWZmZXJfMS5DSEFSX0RBVEFfV0lEVEhfSU5ERVhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hNaW51c1R3byA9IGJ1ZmZlclJvdy5nZXQoYnVmZmVyLnggLSAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaE1pbnVzVHdvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hNaW51c1R3b1tCdWZmZXJfMS5DSEFSX0RBVEFfQ0hBUl9JTkRFWF0gKz0gY2hhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaE1pbnVzVHdvW0J1ZmZlcl8xLkNIQVJfREFUQV9DT0RFX0lOREVYXSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaE1pbnVzT25lW0J1ZmZlcl8xLkNIQVJfREFUQV9DSEFSX0lOREVYXSArPSBjaGFyO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hNaW51c09uZVtCdWZmZXJfMS5DSEFSX0RBVEFfQ09ERV9JTkRFWF0gPSBjb2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJ1ZmZlci54ICsgY2hXaWR0aCAtIDEgPj0gY29scykge1xuICAgICAgICAgICAgICAgIGlmICh3cmFwYXJvdW5kTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIueCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci55Kys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXIueSA+IGJ1ZmZlci5zY3JvbGxCb3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci55LS07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC5zY3JvbGwodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIubGluZXMuZ2V0KGJ1ZmZlci55KS5pc1dyYXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlclJvdyA9IGJ1ZmZlci5saW5lcy5nZXQoYnVmZmVyLnkgKyBidWZmZXIueWJhc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoV2lkdGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluc2VydE1vZGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBtb3ZlcyA9IDA7IG1vdmVzIDwgY2hXaWR0aDsgKyttb3Zlcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlZCA9IGJ1ZmZlclJvdy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoTWludXNUd28gPSBidWZmZXJSb3cuZ2V0KGJ1ZmZlci54IC0gMik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkW0J1ZmZlcl8xLkNIQVJfREFUQV9XSURUSF9JTkRFWF0gPT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIGNoTWludXNUd29cbiAgICAgICAgICAgICAgICAgICAgICAgICYmIGNoTWludXNUd29bQnVmZmVyXzEuQ0hBUl9EQVRBX1dJRFRIX0lOREVYXSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyUm93LnNldCh0aGlzLl90ZXJtaW5hbC5jb2xzIC0gMiwgW2N1ckF0dHIsIEJ1ZmZlcl8xLk5VTExfQ0VMTF9DSEFSLCBCdWZmZXJfMS5OVUxMX0NFTExfV0lEVEgsIEJ1ZmZlcl8xLk5VTExfQ0VMTF9DT0RFXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyUm93LnNwbGljZShidWZmZXIueCwgMCwgW2N1ckF0dHIsIEJ1ZmZlcl8xLk5VTExfQ0VMTF9DSEFSLCBCdWZmZXJfMS5OVUxMX0NFTExfV0lEVEgsIEJ1ZmZlcl8xLk5VTExfQ0VMTF9DT0RFXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyUm93LnNldChidWZmZXIueCsrLCBbY3VyQXR0ciwgY2hhciwgY2hXaWR0aCwgY29kZV0pO1xuICAgICAgICAgICAgaWYgKGNoV2lkdGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICBidWZmZXJSb3cuc2V0KGJ1ZmZlci54KyssIFtjdXJBdHRyLCAnJywgMCwgdW5kZWZpbmVkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGVybWluYWwudXBkYXRlUmFuZ2UoYnVmZmVyLnkpO1xuICAgIH07XG4gICAgSW5wdXRIYW5kbGVyLnByb3RvdHlwZS5iZWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90ZXJtaW5hbC5iZWxsKCk7XG4gICAgfTtcbiAgICBJbnB1dEhhbmRsZXIucHJvdG90eXBlLmxpbmVGZWVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5fdGVybWluYWwuYnVmZmVyO1xuICAgICAgICBpZiAodGhpcy5fdGVybWluYWwub3B0aW9ucy5jb252ZXJ0RW9sKSB7XG4gICAgICAgICAgICBidWZmZXIueCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyLnkrKztcbiAgICAgICAgaWYgKGJ1ZmZlci55ID4gYnVmZmVyLnNjcm9sbEJvdHRvbSkge1xuICAgICAgICAgICAgYnVmZmVyLnktLTtcbiAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLnNjcm9sbCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidWZmZXIueCA+PSB0aGlzLl90ZXJtaW5hbC5jb2xzKSB7XG4gICAgICAgICAgICBidWZmZXIueC0tO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsLmVtaXQoJ2xpbmVmZWVkJyk7XG4gICAgfTtcbiAgICBJbnB1dEhhbmRsZXIucHJvdG90eXBlLmNhcnJpYWdlUmV0dXJuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90ZXJtaW5hbC5idWZmZXIueCA9IDA7XG4gICAgfTtcbiAgICBJbnB1dEhhbmRsZXIucHJvdG90eXBlLmJhY2tzcGFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci54ID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuYnVmZmVyLngtLTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5wdXRIYW5kbGVyLnByb3RvdHlwZS50YWIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbFggPSB0aGlzLl90ZXJtaW5hbC5idWZmZXIueDtcbiAgICAgICAgdGhpcy5fdGVybWluYWwuYnVmZmVyLnggPSB0aGlzLl90ZXJtaW5hbC5idWZmZXIubmV4dFN0b3AoKTtcbiAgICAgICAgaWYgKHRoaXMuX3Rlcm1pbmFsLm9wdGlvbnMuc2NyZWVuUmVhZGVyTW9kZSkge1xuICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuZW1pdCgnYTExeS50YWInLCB0aGlzLl90ZXJtaW5hbC5idWZmZXIueCAtIG9yaWdpbmFsWCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElucHV0SGFuZGxlci5wcm90b3R5cGUuc2hpZnRPdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsLnNldGdMZXZlbCgxKTtcbiAgICB9O1xuICAgIElucHV0SGFuZGxlci5wcm90b3R5cGUuc2hpZnRJbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdGVybWluYWwuc2V0Z0xldmVsKDApO1xuICAgIH07XG4gICAgSW5wdXRIYW5kbGVyLnByb3RvdHlwZS5pbnNlcnRDaGFycyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5fdGVybWluYWwuYnVmZmVyLmxpbmVzLmdldCh0aGlzLl90ZXJtaW5hbC5idWZmZXIueSArIHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci55YmFzZSkuaW5zZXJ0Q2VsbHModGhpcy5fdGVybWluYWwuYnVmZmVyLngsIHBhcmFtc1swXSB8fCAxLCBbdGhpcy5fdGVybWluYWwuZXJhc2VBdHRyKCksIEJ1ZmZlcl8xLk5VTExfQ0VMTF9DSEFSLCBCdWZmZXJfMS5OVUxMX0NFTExfV0lEVEgsIEJ1ZmZlcl8xLk5VTExfQ0VMTF9DT0RFXSk7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsLnVwZGF0ZVJhbmdlKHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci55KTtcbiAgICB9O1xuICAgIElucHV0SGFuZGxlci5wcm90b3R5cGUuY3Vyc29yVXAgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBwYXJhbSA9IHBhcmFtc1swXTtcbiAgICAgICAgaWYgKHBhcmFtIDwgMSkge1xuICAgICAgICAgICAgcGFyYW0gPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci55IC09IHBhcmFtO1xuICAgICAgICBpZiAodGhpcy5fdGVybWluYWwuYnVmZmVyLnkgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC5idWZmZXIueSA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElucHV0SGFuZGxlci5wcm90b3R5cGUuY3Vyc29yRG93biA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gcGFyYW1zWzBdO1xuICAgICAgICBpZiAocGFyYW0gPCAxKSB7XG4gICAgICAgICAgICBwYXJhbSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGVybWluYWwuYnVmZmVyLnkgKz0gcGFyYW07XG4gICAgICAgIGlmICh0aGlzLl90ZXJtaW5hbC5idWZmZXIueSA+PSB0aGlzLl90ZXJtaW5hbC5yb3dzKSB7XG4gICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC5idWZmZXIueSA9IHRoaXMuX3Rlcm1pbmFsLnJvd3MgLSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl90ZXJtaW5hbC5idWZmZXIueCA+PSB0aGlzLl90ZXJtaW5hbC5jb2xzKSB7XG4gICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC5idWZmZXIueC0tO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbnB1dEhhbmRsZXIucHJvdG90eXBlLmN1cnNvckZvcndhcmQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBwYXJhbSA9IHBhcmFtc1swXTtcbiAgICAgICAgaWYgKHBhcmFtIDwgMSkge1xuICAgICAgICAgICAgcGFyYW0gPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci54ICs9IHBhcmFtO1xuICAgICAgICBpZiAodGhpcy5fdGVybWluYWwuYnVmZmVyLnggPj0gdGhpcy5fdGVybWluYWwuY29scykge1xuICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuYnVmZmVyLnggPSB0aGlzLl90ZXJtaW5hbC5jb2xzIC0gMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5wdXRIYW5kbGVyLnByb3RvdHlwZS5jdXJzb3JCYWNrd2FyZCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gcGFyYW1zWzBdO1xuICAgICAgICBpZiAocGFyYW0gPCAxKSB7XG4gICAgICAgICAgICBwYXJhbSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci54ID49IHRoaXMuX3Rlcm1pbmFsLmNvbHMpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci54LS07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGVybWluYWwuYnVmZmVyLnggLT0gcGFyYW07XG4gICAgICAgIGlmICh0aGlzLl90ZXJtaW5hbC5idWZmZXIueCA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci54ID0gMDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5wdXRIYW5kbGVyLnByb3RvdHlwZS5jdXJzb3JOZXh0TGluZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gcGFyYW1zWzBdO1xuICAgICAgICBpZiAocGFyYW0gPCAxKSB7XG4gICAgICAgICAgICBwYXJhbSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGVybWluYWwuYnVmZmVyLnkgKz0gcGFyYW07XG4gICAgICAgIGlmICh0aGlzLl90ZXJtaW5hbC5idWZmZXIueSA+PSB0aGlzLl90ZXJtaW5hbC5yb3dzKSB7XG4gICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC5idWZmZXIueSA9IHRoaXMuX3Rlcm1pbmFsLnJvd3MgLSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci54ID0gMDtcbiAgICB9O1xuICAgIElucHV0SGFuZGxlci5wcm90b3R5cGUuY3Vyc29yUHJlY2VkaW5nTGluZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gcGFyYW1zWzBdO1xuICAgICAgICBpZiAocGFyYW0gPCAxKSB7XG4gICAgICAgICAgICBwYXJhbSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGVybWluYWwuYnVmZmVyLnkgLT0gcGFyYW07XG4gICAgICAgIGlmICh0aGlzLl90ZXJtaW5hbC5idWZmZXIueSA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci55ID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90ZXJtaW5hbC5idWZmZXIueCA9IDA7XG4gICAgfTtcbiAgICBJbnB1dEhhbmRsZXIucHJvdG90eXBlLmN1cnNvckNoYXJBYnNvbHV0ZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gcGFyYW1zWzBdO1xuICAgICAgICBpZiAocGFyYW0gPCAxKSB7XG4gICAgICAgICAgICBwYXJhbSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGVybWluYWwuYnVmZmVyLnggPSBwYXJhbSAtIDE7XG4gICAgfTtcbiAgICBJbnB1dEhhbmRsZXIucHJvdG90eXBlLmN1cnNvclBvc2l0aW9uID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB2YXIgY29sO1xuICAgICAgICB2YXIgcm93ID0gcGFyYW1zWzBdIC0gMTtcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgY29sID0gcGFyYW1zWzFdIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvdyA8IDApIHtcbiAgICAgICAgICAgIHJvdyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocm93ID49IHRoaXMuX3Rlcm1pbmFsLnJvd3MpIHtcbiAgICAgICAgICAgIHJvdyA9IHRoaXMuX3Rlcm1pbmFsLnJvd3MgLSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2wgPCAwKSB7XG4gICAgICAgICAgICBjb2wgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbCA+PSB0aGlzLl90ZXJtaW5hbC5jb2xzKSB7XG4gICAgICAgICAgICBjb2wgPSB0aGlzLl90ZXJtaW5hbC5jb2xzIC0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90ZXJtaW5hbC5idWZmZXIueCA9IGNvbDtcbiAgICAgICAgdGhpcy5fdGVybWluYWwuYnVmZmVyLnkgPSByb3c7XG4gICAgfTtcbiAgICBJbnB1dEhhbmRsZXIucHJvdG90eXBlLmN1cnNvckZvcndhcmRUYWIgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBwYXJhbSA9IHBhcmFtc1swXSB8fCAxO1xuICAgICAgICB3aGlsZSAocGFyYW0tLSkge1xuICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuYnVmZmVyLnggPSB0aGlzLl90ZXJtaW5hbC5idWZmZXIubmV4dFN0b3AoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5wdXRIYW5kbGVyLnByb3RvdHlwZS5fZXJhc2VJbkJ1ZmZlckxpbmUgPSBmdW5jdGlvbiAoeSwgc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLl90ZXJtaW5hbC5idWZmZXIubGluZXMuZ2V0KHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci55YmFzZSArIHkpLnJlcGxhY2VDZWxscyhzdGFydCwgZW5kLCBbdGhpcy5fdGVybWluYWwuZXJhc2VBdHRyKCksIEJ1ZmZlcl8xLk5VTExfQ0VMTF9DSEFSLCBCdWZmZXJfMS5OVUxMX0NFTExfV0lEVEgsIEJ1ZmZlcl8xLk5VTExfQ0VMTF9DT0RFXSk7XG4gICAgfTtcbiAgICBJbnB1dEhhbmRsZXIucHJvdG90eXBlLmVyYXNlSW5EaXNwbGF5ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB2YXIgajtcbiAgICAgICAgc3dpdGNoIChwYXJhbXNbMF0pIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBqID0gdGhpcy5fdGVybWluYWwuYnVmZmVyLnk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGVybWluYWwudXBkYXRlUmFuZ2Uoaik7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJhc2VJbkJ1ZmZlckxpbmUoaisrLCB0aGlzLl90ZXJtaW5hbC5idWZmZXIueCwgdGhpcy5fdGVybWluYWwuY29scyk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGogPCB0aGlzLl90ZXJtaW5hbC5yb3dzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXJhc2VJbkJ1ZmZlckxpbmUoaiwgMCwgdGhpcy5fdGVybWluYWwuY29scyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLnVwZGF0ZVJhbmdlKGopO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGogPSB0aGlzLl90ZXJtaW5hbC5idWZmZXIueTtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC51cGRhdGVSYW5nZShqKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcmFzZUluQnVmZmVyTGluZShqLCAwLCB0aGlzLl90ZXJtaW5hbC5idWZmZXIueCArIDEpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXJhc2VJbkJ1ZmZlckxpbmUoaiwgMCwgdGhpcy5fdGVybWluYWwuY29scyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLnVwZGF0ZVJhbmdlKDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGogPSB0aGlzLl90ZXJtaW5hbC5yb3dzO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLnVwZGF0ZVJhbmdlKGogLSAxKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VyYXNlSW5CdWZmZXJMaW5lKGosIDAsIHRoaXMuX3Rlcm1pbmFsLmNvbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC51cGRhdGVSYW5nZSgwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsQmFja1NpemUgPSB0aGlzLl90ZXJtaW5hbC5idWZmZXIubGluZXMubGVuZ3RoIC0gdGhpcy5fdGVybWluYWwucm93cztcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsQmFja1NpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci5saW5lcy50cmltU3RhcnQoc2Nyb2xsQmFja1NpemUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC5idWZmZXIueWJhc2UgPSBNYXRoLm1heCh0aGlzLl90ZXJtaW5hbC5idWZmZXIueWJhc2UgLSBzY3JvbGxCYWNrU2l6ZSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci55ZGlzcCA9IE1hdGgubWF4KHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci55ZGlzcCAtIHNjcm9sbEJhY2tTaXplLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuZW1pdCgnc2Nyb2xsJywgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbnB1dEhhbmRsZXIucHJvdG90eXBlLmVyYXNlSW5MaW5lID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICBzd2l0Y2ggKHBhcmFtc1swXSkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHRoaXMuX2VyYXNlSW5CdWZmZXJMaW5lKHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci55LCB0aGlzLl90ZXJtaW5hbC5idWZmZXIueCwgdGhpcy5fdGVybWluYWwuY29scyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJhc2VJbkJ1ZmZlckxpbmUodGhpcy5fdGVybWluYWwuYnVmZmVyLnksIDAsIHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci54ICsgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJhc2VJbkJ1ZmZlckxpbmUodGhpcy5fdGVybWluYWwuYnVmZmVyLnksIDAsIHRoaXMuX3Rlcm1pbmFsLmNvbHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsLnVwZGF0ZVJhbmdlKHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci55KTtcbiAgICB9O1xuICAgIElucHV0SGFuZGxlci5wcm90b3R5cGUuaW5zZXJ0TGluZXMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBwYXJhbSA9IHBhcmFtc1swXTtcbiAgICAgICAgaWYgKHBhcmFtIDwgMSkge1xuICAgICAgICAgICAgcGFyYW0gPSAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLl90ZXJtaW5hbC5idWZmZXI7XG4gICAgICAgIHZhciByb3cgPSBidWZmZXIueSArIGJ1ZmZlci55YmFzZTtcbiAgICAgICAgdmFyIHNjcm9sbEJvdHRvbVJvd3NPZmZzZXQgPSB0aGlzLl90ZXJtaW5hbC5yb3dzIC0gMSAtIGJ1ZmZlci5zY3JvbGxCb3R0b207XG4gICAgICAgIHZhciBzY3JvbGxCb3R0b21BYnNvbHV0ZSA9IHRoaXMuX3Rlcm1pbmFsLnJvd3MgLSAxICsgYnVmZmVyLnliYXNlIC0gc2Nyb2xsQm90dG9tUm93c09mZnNldCArIDE7XG4gICAgICAgIHdoaWxlIChwYXJhbS0tKSB7XG4gICAgICAgICAgICBidWZmZXIubGluZXMuc3BsaWNlKHNjcm9sbEJvdHRvbUFic29sdXRlIC0gMSwgMSk7XG4gICAgICAgICAgICBidWZmZXIubGluZXMuc3BsaWNlKHJvdywgMCwgQnVmZmVyTGluZV8xLkJ1ZmZlckxpbmUuYmxhbmtMaW5lKHRoaXMuX3Rlcm1pbmFsLmNvbHMsIHRoaXMuX3Rlcm1pbmFsLmVyYXNlQXR0cigpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGVybWluYWwudXBkYXRlUmFuZ2UoYnVmZmVyLnkpO1xuICAgICAgICB0aGlzLl90ZXJtaW5hbC51cGRhdGVSYW5nZShidWZmZXIuc2Nyb2xsQm90dG9tKTtcbiAgICB9O1xuICAgIElucHV0SGFuZGxlci5wcm90b3R5cGUuZGVsZXRlTGluZXMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBwYXJhbSA9IHBhcmFtc1swXTtcbiAgICAgICAgaWYgKHBhcmFtIDwgMSkge1xuICAgICAgICAgICAgcGFyYW0gPSAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLl90ZXJtaW5hbC5idWZmZXI7XG4gICAgICAgIHZhciByb3cgPSBidWZmZXIueSArIGJ1ZmZlci55YmFzZTtcbiAgICAgICAgdmFyIGo7XG4gICAgICAgIGogPSB0aGlzLl90ZXJtaW5hbC5yb3dzIC0gMSAtIGJ1ZmZlci5zY3JvbGxCb3R0b207XG4gICAgICAgIGogPSB0aGlzLl90ZXJtaW5hbC5yb3dzIC0gMSArIGJ1ZmZlci55YmFzZSAtIGo7XG4gICAgICAgIHdoaWxlIChwYXJhbS0tKSB7XG4gICAgICAgICAgICBidWZmZXIubGluZXMuc3BsaWNlKHJvdywgMSk7XG4gICAgICAgICAgICBidWZmZXIubGluZXMuc3BsaWNlKGosIDAsIEJ1ZmZlckxpbmVfMS5CdWZmZXJMaW5lLmJsYW5rTGluZSh0aGlzLl90ZXJtaW5hbC5jb2xzLCB0aGlzLl90ZXJtaW5hbC5lcmFzZUF0dHIoKSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsLnVwZGF0ZVJhbmdlKGJ1ZmZlci55KTtcbiAgICAgICAgdGhpcy5fdGVybWluYWwudXBkYXRlUmFuZ2UoYnVmZmVyLnNjcm9sbEJvdHRvbSk7XG4gICAgfTtcbiAgICBJbnB1dEhhbmRsZXIucHJvdG90eXBlLmRlbGV0ZUNoYXJzID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB0aGlzLl90ZXJtaW5hbC5idWZmZXIubGluZXMuZ2V0KHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci55ICsgdGhpcy5fdGVybWluYWwuYnVmZmVyLnliYXNlKS5kZWxldGVDZWxscyh0aGlzLl90ZXJtaW5hbC5idWZmZXIueCwgcGFyYW1zWzBdIHx8IDEsIFt0aGlzLl90ZXJtaW5hbC5lcmFzZUF0dHIoKSwgQnVmZmVyXzEuTlVMTF9DRUxMX0NIQVIsIEJ1ZmZlcl8xLk5VTExfQ0VMTF9XSURUSCwgQnVmZmVyXzEuTlVMTF9DRUxMX0NPREVdKTtcbiAgICAgICAgdGhpcy5fdGVybWluYWwudXBkYXRlUmFuZ2UodGhpcy5fdGVybWluYWwuYnVmZmVyLnkpO1xuICAgIH07XG4gICAgSW5wdXRIYW5kbGVyLnByb3RvdHlwZS5zY3JvbGxVcCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gcGFyYW1zWzBdIHx8IDE7XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLl90ZXJtaW5hbC5idWZmZXI7XG4gICAgICAgIHdoaWxlIChwYXJhbS0tKSB7XG4gICAgICAgICAgICBidWZmZXIubGluZXMuc3BsaWNlKGJ1ZmZlci55YmFzZSArIGJ1ZmZlci5zY3JvbGxUb3AsIDEpO1xuICAgICAgICAgICAgYnVmZmVyLmxpbmVzLnNwbGljZShidWZmZXIueWJhc2UgKyBidWZmZXIuc2Nyb2xsQm90dG9tLCAwLCBCdWZmZXJMaW5lXzEuQnVmZmVyTGluZS5ibGFua0xpbmUodGhpcy5fdGVybWluYWwuY29scywgQnVmZmVyXzEuREVGQVVMVF9BVFRSKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGVybWluYWwudXBkYXRlUmFuZ2UoYnVmZmVyLnNjcm9sbFRvcCk7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsLnVwZGF0ZVJhbmdlKGJ1ZmZlci5zY3JvbGxCb3R0b20pO1xuICAgIH07XG4gICAgSW5wdXRIYW5kbGVyLnByb3RvdHlwZS5zY3JvbGxEb3duID0gZnVuY3Rpb24gKHBhcmFtcywgY29sbGVjdCkge1xuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA8IDIgJiYgIWNvbGxlY3QpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbSA9IHBhcmFtc1swXSB8fCAxO1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlcjtcbiAgICAgICAgICAgIHdoaWxlIChwYXJhbS0tKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyLmxpbmVzLnNwbGljZShidWZmZXIueWJhc2UgKyBidWZmZXIuc2Nyb2xsQm90dG9tLCAxKTtcbiAgICAgICAgICAgICAgICBidWZmZXIubGluZXMuc3BsaWNlKGJ1ZmZlci55YmFzZSArIGJ1ZmZlci5zY3JvbGxCb3R0b20sIDAsIEJ1ZmZlckxpbmVfMS5CdWZmZXJMaW5lLmJsYW5rTGluZSh0aGlzLl90ZXJtaW5hbC5jb2xzLCBCdWZmZXJfMS5ERUZBVUxUX0FUVFIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLnVwZGF0ZVJhbmdlKGJ1ZmZlci5zY3JvbGxUb3ApO1xuICAgICAgICAgICAgdGhpcy5fdGVybWluYWwudXBkYXRlUmFuZ2UoYnVmZmVyLnNjcm9sbEJvdHRvbSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElucHV0SGFuZGxlci5wcm90b3R5cGUuZXJhc2VDaGFycyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5fdGVybWluYWwuYnVmZmVyLmxpbmVzLmdldCh0aGlzLl90ZXJtaW5hbC5idWZmZXIueSArIHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci55YmFzZSkucmVwbGFjZUNlbGxzKHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci54LCB0aGlzLl90ZXJtaW5hbC5idWZmZXIueCArIChwYXJhbXNbMF0gfHwgMSksIFt0aGlzLl90ZXJtaW5hbC5lcmFzZUF0dHIoKSwgQnVmZmVyXzEuTlVMTF9DRUxMX0NIQVIsIEJ1ZmZlcl8xLk5VTExfQ0VMTF9XSURUSCwgQnVmZmVyXzEuTlVMTF9DRUxMX0NPREVdKTtcbiAgICB9O1xuICAgIElucHV0SGFuZGxlci5wcm90b3R5cGUuY3Vyc29yQmFja3dhcmRUYWIgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBwYXJhbSA9IHBhcmFtc1swXSB8fCAxO1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5fdGVybWluYWwuYnVmZmVyO1xuICAgICAgICB3aGlsZSAocGFyYW0tLSkge1xuICAgICAgICAgICAgYnVmZmVyLnggPSBidWZmZXIucHJldlN0b3AoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5wdXRIYW5kbGVyLnByb3RvdHlwZS5jaGFyUG9zQWJzb2x1dGUgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBwYXJhbSA9IHBhcmFtc1swXTtcbiAgICAgICAgaWYgKHBhcmFtIDwgMSkge1xuICAgICAgICAgICAgcGFyYW0gPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci54ID0gcGFyYW0gLSAxO1xuICAgICAgICBpZiAodGhpcy5fdGVybWluYWwuYnVmZmVyLnggPj0gdGhpcy5fdGVybWluYWwuY29scykge1xuICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuYnVmZmVyLnggPSB0aGlzLl90ZXJtaW5hbC5jb2xzIC0gMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5wdXRIYW5kbGVyLnByb3RvdHlwZS5oUG9zaXRpb25SZWxhdGl2ZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gcGFyYW1zWzBdO1xuICAgICAgICBpZiAocGFyYW0gPCAxKSB7XG4gICAgICAgICAgICBwYXJhbSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGVybWluYWwuYnVmZmVyLnggKz0gcGFyYW07XG4gICAgICAgIGlmICh0aGlzLl90ZXJtaW5hbC5idWZmZXIueCA+PSB0aGlzLl90ZXJtaW5hbC5jb2xzKSB7XG4gICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC5idWZmZXIueCA9IHRoaXMuX3Rlcm1pbmFsLmNvbHMgLSAxO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbnB1dEhhbmRsZXIucHJvdG90eXBlLnJlcGVhdFByZWNlZGluZ0NoYXJhY3RlciA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlcjtcbiAgICAgICAgdmFyIGxpbmUgPSBidWZmZXIubGluZXMuZ2V0KGJ1ZmZlci55YmFzZSArIGJ1ZmZlci55KTtcbiAgICAgICAgbGluZS5yZXBsYWNlQ2VsbHMoYnVmZmVyLngsIGJ1ZmZlci54ICsgKHBhcmFtc1swXSB8fCAxKSwgbGluZS5nZXQoYnVmZmVyLnggLSAxKSB8fCBbQnVmZmVyXzEuREVGQVVMVF9BVFRSLCBCdWZmZXJfMS5OVUxMX0NFTExfQ0hBUiwgQnVmZmVyXzEuTlVMTF9DRUxMX1dJRFRILCBCdWZmZXJfMS5OVUxMX0NFTExfQ09ERV0pO1xuICAgIH07XG4gICAgSW5wdXRIYW5kbGVyLnByb3RvdHlwZS5zZW5kRGV2aWNlQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChwYXJhbXMsIGNvbGxlY3QpIHtcbiAgICAgICAgaWYgKHBhcmFtc1swXSA+IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbGxlY3QpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl90ZXJtaW5hbC5pcygneHRlcm0nKSB8fCB0aGlzLl90ZXJtaW5hbC5pcygncnh2dC11bmljb2RlJykgfHwgdGhpcy5fdGVybWluYWwuaXMoJ3NjcmVlbicpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuaGFuZGxlcihFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnWz8xOzJjJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl90ZXJtaW5hbC5pcygnbGludXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLmhhbmRsZXIoRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgJ1s/NmMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2xsZWN0ID09PSAnPicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl90ZXJtaW5hbC5pcygneHRlcm0nKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLmhhbmRsZXIoRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgJ1s+MDsyNzY7MGMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3Rlcm1pbmFsLmlzKCdyeHZ0LXVuaWNvZGUnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLmhhbmRsZXIoRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgJ1s+ODU7OTU7MGMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3Rlcm1pbmFsLmlzKCdsaW51eCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuaGFuZGxlcihwYXJhbXNbMF0gKyAnYycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fdGVybWluYWwuaXMoJ3NjcmVlbicpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuaGFuZGxlcihFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnWz44Mzs0MDAwMzswYycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBJbnB1dEhhbmRsZXIucHJvdG90eXBlLmxpbmVQb3NBYnNvbHV0ZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gcGFyYW1zWzBdO1xuICAgICAgICBpZiAocGFyYW0gPCAxKSB7XG4gICAgICAgICAgICBwYXJhbSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGVybWluYWwuYnVmZmVyLnkgPSBwYXJhbSAtIDE7XG4gICAgICAgIGlmICh0aGlzLl90ZXJtaW5hbC5idWZmZXIueSA+PSB0aGlzLl90ZXJtaW5hbC5yb3dzKSB7XG4gICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC5idWZmZXIueSA9IHRoaXMuX3Rlcm1pbmFsLnJvd3MgLSAxO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbnB1dEhhbmRsZXIucHJvdG90eXBlLnZQb3NpdGlvblJlbGF0aXZlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB2YXIgcGFyYW0gPSBwYXJhbXNbMF07XG4gICAgICAgIGlmIChwYXJhbSA8IDEpIHtcbiAgICAgICAgICAgIHBhcmFtID0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90ZXJtaW5hbC5idWZmZXIueSArPSBwYXJhbTtcbiAgICAgICAgaWYgKHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci55ID49IHRoaXMuX3Rlcm1pbmFsLnJvd3MpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci55ID0gdGhpcy5fdGVybWluYWwucm93cyAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci54ID49IHRoaXMuX3Rlcm1pbmFsLmNvbHMpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci54LS07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElucHV0SGFuZGxlci5wcm90b3R5cGUuaFZQb3NpdGlvbiA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtc1swXSA8IDEpXG4gICAgICAgICAgICBwYXJhbXNbMF0gPSAxO1xuICAgICAgICBpZiAocGFyYW1zWzFdIDwgMSlcbiAgICAgICAgICAgIHBhcmFtc1sxXSA9IDE7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci55ID0gcGFyYW1zWzBdIC0gMTtcbiAgICAgICAgaWYgKHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci55ID49IHRoaXMuX3Rlcm1pbmFsLnJvd3MpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci55ID0gdGhpcy5fdGVybWluYWwucm93cyAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGVybWluYWwuYnVmZmVyLnggPSBwYXJhbXNbMV0gLSAxO1xuICAgICAgICBpZiAodGhpcy5fdGVybWluYWwuYnVmZmVyLnggPj0gdGhpcy5fdGVybWluYWwuY29scykge1xuICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuYnVmZmVyLnggPSB0aGlzLl90ZXJtaW5hbC5jb2xzIC0gMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5wdXRIYW5kbGVyLnByb3RvdHlwZS50YWJDbGVhciA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gcGFyYW1zWzBdO1xuICAgICAgICBpZiAocGFyYW0gPD0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci50YWJzW3RoaXMuX3Rlcm1pbmFsLmJ1ZmZlci54XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJhbSA9PT0gMykge1xuICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuYnVmZmVyLnRhYnMgPSB7fTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5wdXRIYW5kbGVyLnByb3RvdHlwZS5zZXRNb2RlID0gZnVuY3Rpb24gKHBhcmFtcywgY29sbGVjdCkge1xuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRNb2RlKFtwYXJhbXNbaV1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbGxlY3QpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocGFyYW1zWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC5pbnNlcnRNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29sbGVjdCA9PT0gJz8nKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcmFtc1swXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuYXBwbGljYXRpb25DdXJzb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLnNldGdDaGFyc2V0KDAsIENoYXJzZXRzXzEuREVGQVVMVF9DSEFSU0VUKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuc2V0Z0NoYXJzZXQoMSwgQ2hhcnNldHNfMS5ERUZBVUxUX0NIQVJTRVQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC5zZXRnQ2hhcnNldCgyLCBDaGFyc2V0c18xLkRFRkFVTFRfQ0hBUlNFVCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLnNldGdDaGFyc2V0KDMsIENoYXJzZXRzXzEuREVGQVVMVF9DSEFSU0VUKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC5zYXZlZENvbHMgPSB0aGlzLl90ZXJtaW5hbC5jb2xzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC5yZXNpemUoMTMyLCB0aGlzLl90ZXJtaW5hbC5yb3dzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC5vcmlnaW5Nb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC53cmFwYXJvdW5kTW9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjY6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLmxvZygnU2VyaWFsIHBvcnQgcmVxdWVzdGVkIGFwcGxpY2F0aW9uIGtleXBhZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuYXBwbGljYXRpb25LZXlwYWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC52aWV3cG9ydC5zeW5jU2Nyb2xsQXJlYSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgY2FzZSAxMDAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMTAwMjpcbiAgICAgICAgICAgICAgICBjYXNlIDEwMDM6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLngxME1vdXNlID0gcGFyYW1zWzBdID09PSA5O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC52dDIwME1vdXNlID0gcGFyYW1zWzBdID09PSAxMDAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC5ub3JtYWxNb3VzZSA9IHBhcmFtc1swXSA+IDEwMDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLm1vdXNlRXZlbnRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdlbmFibGUtbW91c2UtZXZlbnRzJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLnNlbGVjdGlvbk1hbmFnZXIuZGlzYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC5sb2coJ0JpbmRpbmcgdG8gbW91c2UgZXZlbnRzLicpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEwMDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLnNlbmRGb2N1cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTAwNTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVybWluYWwudXRmTW91c2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEwMDY6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLnNnck1vdXNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDE1OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC51cnh2dE1vdXNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuY3Vyc29ySGlkZGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA0OTpcbiAgICAgICAgICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgICAgICAgIGNhc2UgMTA0NzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuYnVmZmVycy5hY3RpdmF0ZUFsdEJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC52aWV3cG9ydC5zeW5jU2Nyb2xsQXJlYSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC5zaG93Q3Vyc29yKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjAwNDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuYnJhY2tldGVkUGFzdGVNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElucHV0SGFuZGxlci5wcm90b3R5cGUucmVzZXRNb2RlID0gZnVuY3Rpb24gKHBhcmFtcywgY29sbGVjdCkge1xuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldE1vZGUoW3BhcmFtc1tpXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29sbGVjdCkge1xuICAgICAgICAgICAgc3dpdGNoIChwYXJhbXNbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLmluc2VydE1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29sbGVjdCA9PT0gJz8nKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcmFtc1swXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuYXBwbGljYXRpb25DdXJzb3IgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdGVybWluYWwuY29scyA9PT0gMTMyICYmIHRoaXMuX3Rlcm1pbmFsLnNhdmVkQ29scykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVybWluYWwucmVzaXplKHRoaXMuX3Rlcm1pbmFsLnNhdmVkQ29scywgdGhpcy5fdGVybWluYWwucm93cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3Rlcm1pbmFsLnNhdmVkQ29scztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC5vcmlnaW5Nb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVybWluYWwud3JhcGFyb3VuZE1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2NjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVybWluYWwubG9nKCdTd2l0Y2hpbmcgYmFjayB0byBub3JtYWwga2V5cGFkLicpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC5hcHBsaWNhdGlvbktleXBhZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC52aWV3cG9ydC5zeW5jU2Nyb2xsQXJlYSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgY2FzZSAxMDAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMTAwMjpcbiAgICAgICAgICAgICAgICBjYXNlIDEwMDM6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLngxME1vdXNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLnZ0MjAwTW91c2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVybWluYWwubm9ybWFsTW91c2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVybWluYWwubW91c2VFdmVudHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdlbmFibGUtbW91c2UtZXZlbnRzJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLnNlbGVjdGlvbk1hbmFnZXIuZW5hYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTAwNDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuc2VuZEZvY3VzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTAwNTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVybWluYWwudXRmTW91c2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDA2OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC5zZ3JNb3VzZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEwMTU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLnVyeHZ0TW91c2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuY3Vyc29ySGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDQ5OlxuICAgICAgICAgICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgICAgICAgY2FzZSAxMDQ3OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC5idWZmZXJzLmFjdGl2YXRlTm9ybWFsQnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLnJlZnJlc2goMCwgdGhpcy5fdGVybWluYWwucm93cyAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC52aWV3cG9ydC5zeW5jU2Nyb2xsQXJlYSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC5zaG93Q3Vyc29yKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjAwNDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuYnJhY2tldGVkUGFzdGVNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBJbnB1dEhhbmRsZXIucHJvdG90eXBlLmNoYXJBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMSAmJiBwYXJhbXNbMF0gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLmN1ckF0dHIgPSBCdWZmZXJfMS5ERUZBVUxUX0FUVFI7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGwgPSBwYXJhbXMubGVuZ3RoO1xuICAgICAgICB2YXIgZmxhZ3MgPSB0aGlzLl90ZXJtaW5hbC5jdXJBdHRyID4+IDE4O1xuICAgICAgICB2YXIgZmcgPSAodGhpcy5fdGVybWluYWwuY3VyQXR0ciA+PiA5KSAmIDB4MWZmO1xuICAgICAgICB2YXIgYmcgPSB0aGlzLl90ZXJtaW5hbC5jdXJBdHRyICYgMHgxZmY7XG4gICAgICAgIHZhciBwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgcCA9IHBhcmFtc1tpXTtcbiAgICAgICAgICAgIGlmIChwID49IDMwICYmIHAgPD0gMzcpIHtcbiAgICAgICAgICAgICAgICBmZyA9IHAgLSAzMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHAgPj0gNDAgJiYgcCA8PSA0Nykge1xuICAgICAgICAgICAgICAgIGJnID0gcCAtIDQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocCA+PSA5MCAmJiBwIDw9IDk3KSB7XG4gICAgICAgICAgICAgICAgcCArPSA4O1xuICAgICAgICAgICAgICAgIGZnID0gcCAtIDkwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocCA+PSAxMDAgJiYgcCA8PSAxMDcpIHtcbiAgICAgICAgICAgICAgICBwICs9IDg7XG4gICAgICAgICAgICAgICAgYmcgPSBwIC0gMTAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGZsYWdzID0gQnVmZmVyXzEuREVGQVVMVF9BVFRSID4+IDE4O1xuICAgICAgICAgICAgICAgIGZnID0gKEJ1ZmZlcl8xLkRFRkFVTFRfQVRUUiA+PiA5KSAmIDB4MWZmO1xuICAgICAgICAgICAgICAgIGJnID0gQnVmZmVyXzEuREVGQVVMVF9BVFRSICYgMHgxZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHAgPT09IDMpIHtcbiAgICAgICAgICAgICAgICBmbGFncyB8PSA2NDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHAgPT09IDQpIHtcbiAgICAgICAgICAgICAgICBmbGFncyB8PSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocCA9PT0gNSkge1xuICAgICAgICAgICAgICAgIGZsYWdzIHw9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwID09PSA3KSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MgfD0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHAgPT09IDgpIHtcbiAgICAgICAgICAgICAgICBmbGFncyB8PSAxNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHAgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBmbGFncyB8PSAzMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHAgPT09IDIyKSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MgJj0gfjE7XG4gICAgICAgICAgICAgICAgZmxhZ3MgJj0gfjMyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocCA9PT0gMjMpIHtcbiAgICAgICAgICAgICAgICBmbGFncyAmPSB+NjQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwID09PSAyNCkge1xuICAgICAgICAgICAgICAgIGZsYWdzICY9IH4yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocCA9PT0gMjUpIHtcbiAgICAgICAgICAgICAgICBmbGFncyAmPSB+NDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHAgPT09IDI3KSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MgJj0gfjg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwID09PSAyOCkge1xuICAgICAgICAgICAgICAgIGZsYWdzICY9IH4xNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHAgPT09IDM5KSB7XG4gICAgICAgICAgICAgICAgZmcgPSAoQnVmZmVyXzEuREVGQVVMVF9BVFRSID4+IDkpICYgMHgxZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwID09PSA0OSkge1xuICAgICAgICAgICAgICAgIGJnID0gQnVmZmVyXzEuREVGQVVMVF9BVFRSICYgMHgxZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwID09PSAzOCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXNbaSArIDFdID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgZmcgPSB0aGlzLl90ZXJtaW5hbC5tYXRjaENvbG9yKHBhcmFtc1tpXSAmIDB4ZmYsIHBhcmFtc1tpICsgMV0gJiAweGZmLCBwYXJhbXNbaSArIDJdICYgMHhmZik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmZyA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICBmZyA9IDB4MWZmO1xuICAgICAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtc1tpICsgMV0gPT09IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgICAgICAgICBwID0gcGFyYW1zW2ldICYgMHhmZjtcbiAgICAgICAgICAgICAgICAgICAgZmcgPSBwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHAgPT09IDQ4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtc1tpICsgMV0gPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgICAgICAgICBiZyA9IHRoaXMuX3Rlcm1pbmFsLm1hdGNoQ29sb3IocGFyYW1zW2ldICYgMHhmZiwgcGFyYW1zW2kgKyAxXSAmIDB4ZmYsIHBhcmFtc1tpICsgMl0gJiAweGZmKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJnID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJnID0gMHgxZmY7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1zW2kgKyAxXSA9PT0gNSkge1xuICAgICAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwYXJhbXNbaV0gJiAweGZmO1xuICAgICAgICAgICAgICAgICAgICBiZyA9IHA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocCA9PT0gMTAwKSB7XG4gICAgICAgICAgICAgICAgZmcgPSAoQnVmZmVyXzEuREVGQVVMVF9BVFRSID4+IDkpICYgMHgxZmY7XG4gICAgICAgICAgICAgICAgYmcgPSBCdWZmZXJfMS5ERUZBVUxUX0FUVFIgJiAweDFmZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLmVycm9yKCdVbmtub3duIFNHUiBhdHRyaWJ1dGU6ICVkLicsIHApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsLmN1ckF0dHIgPSAoZmxhZ3MgPDwgMTgpIHwgKGZnIDw8IDkpIHwgYmc7XG4gICAgfTtcbiAgICBJbnB1dEhhbmRsZXIucHJvdG90eXBlLmRldmljZVN0YXR1cyA9IGZ1bmN0aW9uIChwYXJhbXMsIGNvbGxlY3QpIHtcbiAgICAgICAgaWYgKCFjb2xsZWN0KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcmFtc1swXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuZW1pdCgnZGF0YScsIEVzY2FwZVNlcXVlbmNlc18xLkMwLkVTQyArIFwiWzBuXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIHZhciB5ID0gdGhpcy5fdGVybWluYWwuYnVmZmVyLnkgKyAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci54ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuZW1pdCgnZGF0YScsIEVzY2FwZVNlcXVlbmNlc18xLkMwLkVTQyArIFwiW1wiICsgeSArIFwiO1wiICsgeCArIFwiUlwiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29sbGVjdCA9PT0gJz8nKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcmFtc1swXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSB0aGlzLl90ZXJtaW5hbC5idWZmZXIueSArIDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gdGhpcy5fdGVybWluYWwuYnVmZmVyLnggKyAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC5lbWl0KCdkYXRhJywgRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgXCJbP1wiICsgeSArIFwiO1wiICsgeCArIFwiUlwiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1MzpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElucHV0SGFuZGxlci5wcm90b3R5cGUuc29mdFJlc2V0ID0gZnVuY3Rpb24gKHBhcmFtcywgY29sbGVjdCkge1xuICAgICAgICBpZiAoY29sbGVjdCA9PT0gJyEnKSB7XG4gICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC5jdXJzb3JIaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLmluc2VydE1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLm9yaWdpbk1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLndyYXBhcm91bmRNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLmFwcGxpY2F0aW9uS2V5cGFkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC52aWV3cG9ydC5zeW5jU2Nyb2xsQXJlYSgpO1xuICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuYXBwbGljYXRpb25DdXJzb3IgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci5zY3JvbGxUb3AgPSAwO1xuICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuYnVmZmVyLnNjcm9sbEJvdHRvbSA9IHRoaXMuX3Rlcm1pbmFsLnJvd3MgLSAxO1xuICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuY3VyQXR0ciA9IEJ1ZmZlcl8xLkRFRkFVTFRfQVRUUjtcbiAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci54ID0gdGhpcy5fdGVybWluYWwuYnVmZmVyLnkgPSAwO1xuICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuY2hhcnNldCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC5nbGV2ZWwgPSAwO1xuICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuY2hhcnNldHMgPSBbbnVsbF07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElucHV0SGFuZGxlci5wcm90b3R5cGUuc2V0Q3Vyc29yU3R5bGUgPSBmdW5jdGlvbiAocGFyYW1zLCBjb2xsZWN0KSB7XG4gICAgICAgIGlmIChjb2xsZWN0ID09PSAnICcpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbSA9IHBhcmFtc1swXSA8IDEgPyAxIDogcGFyYW1zWzBdO1xuICAgICAgICAgICAgc3dpdGNoIChwYXJhbSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLnNldE9wdGlvbignY3Vyc29yU3R5bGUnLCAnYmxvY2snKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuc2V0T3B0aW9uKCdjdXJzb3JTdHlsZScsICd1bmRlcmxpbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuc2V0T3B0aW9uKCdjdXJzb3JTdHlsZScsICdiYXInKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaXNCbGlua2luZyA9IHBhcmFtICUgMiA9PT0gMTtcbiAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLnNldE9wdGlvbignY3Vyc29yQmxpbmsnLCBpc0JsaW5raW5nKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5wdXRIYW5kbGVyLnByb3RvdHlwZS5zZXRTY3JvbGxSZWdpb24gPSBmdW5jdGlvbiAocGFyYW1zLCBjb2xsZWN0KSB7XG4gICAgICAgIGlmIChjb2xsZWN0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl90ZXJtaW5hbC5idWZmZXIuc2Nyb2xsVG9wID0gKHBhcmFtc1swXSB8fCAxKSAtIDE7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci5zY3JvbGxCb3R0b20gPSAocGFyYW1zWzFdICYmIHBhcmFtc1sxXSA8PSB0aGlzLl90ZXJtaW5hbC5yb3dzID8gcGFyYW1zWzFdIDogdGhpcy5fdGVybWluYWwucm93cykgLSAxO1xuICAgICAgICB0aGlzLl90ZXJtaW5hbC5idWZmZXIueCA9IDA7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci55ID0gMDtcbiAgICB9O1xuICAgIElucHV0SGFuZGxlci5wcm90b3R5cGUuc2F2ZUN1cnNvciA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5fdGVybWluYWwuYnVmZmVyLnNhdmVkWCA9IHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci54O1xuICAgICAgICB0aGlzLl90ZXJtaW5hbC5idWZmZXIuc2F2ZWRZID0gdGhpcy5fdGVybWluYWwuYnVmZmVyLnk7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsLnNhdmVkQ3VyQXR0ciA9IHRoaXMuX3Rlcm1pbmFsLmN1ckF0dHI7XG4gICAgfTtcbiAgICBJbnB1dEhhbmRsZXIucHJvdG90eXBlLnJlc3RvcmVDdXJzb3IgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci54ID0gdGhpcy5fdGVybWluYWwuYnVmZmVyLnNhdmVkWCB8fCAwO1xuICAgICAgICB0aGlzLl90ZXJtaW5hbC5idWZmZXIueSA9IHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci5zYXZlZFkgfHwgMDtcbiAgICAgICAgdGhpcy5fdGVybWluYWwuY3VyQXR0ciA9IHRoaXMuX3Rlcm1pbmFsLnNhdmVkQ3VyQXR0ciB8fCBCdWZmZXJfMS5ERUZBVUxUX0FUVFI7XG4gICAgfTtcbiAgICBJbnB1dEhhbmRsZXIucHJvdG90eXBlLnNldFRpdGxlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fdGVybWluYWwuaGFuZGxlVGl0bGUoZGF0YSk7XG4gICAgfTtcbiAgICBJbnB1dEhhbmRsZXIucHJvdG90eXBlLm5leHRMaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90ZXJtaW5hbC5idWZmZXIueCA9IDA7XG4gICAgICAgIHRoaXMuaW5kZXgoKTtcbiAgICB9O1xuICAgIElucHV0SGFuZGxlci5wcm90b3R5cGUua2V5cGFkQXBwbGljYXRpb25Nb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90ZXJtaW5hbC5sb2coJ1NlcmlhbCBwb3J0IHJlcXVlc3RlZCBhcHBsaWNhdGlvbiBrZXlwYWQuJyk7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsLmFwcGxpY2F0aW9uS2V5cGFkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuX3Rlcm1pbmFsLnZpZXdwb3J0KSB7XG4gICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC52aWV3cG9ydC5zeW5jU2Nyb2xsQXJlYSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbnB1dEhhbmRsZXIucHJvdG90eXBlLmtleXBhZE51bWVyaWNNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90ZXJtaW5hbC5sb2coJ1N3aXRjaGluZyBiYWNrIHRvIG5vcm1hbCBrZXlwYWQuJyk7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsLmFwcGxpY2F0aW9uS2V5cGFkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl90ZXJtaW5hbC52aWV3cG9ydCkge1xuICAgICAgICAgICAgdGhpcy5fdGVybWluYWwudmlld3BvcnQuc3luY1Njcm9sbEFyZWEoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5wdXRIYW5kbGVyLnByb3RvdHlwZS5zZWxlY3REZWZhdWx0Q2hhcnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdGVybWluYWwuc2V0Z0xldmVsKDApO1xuICAgICAgICB0aGlzLl90ZXJtaW5hbC5zZXRnQ2hhcnNldCgwLCBDaGFyc2V0c18xLkRFRkFVTFRfQ0hBUlNFVCk7XG4gICAgfTtcbiAgICBJbnB1dEhhbmRsZXIucHJvdG90eXBlLnNlbGVjdENoYXJzZXQgPSBmdW5jdGlvbiAoY29sbGVjdEFuZEZsYWcpIHtcbiAgICAgICAgaWYgKGNvbGxlY3RBbmRGbGFnLmxlbmd0aCAhPT0gMilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdERlZmF1bHRDaGFyc2V0KCk7XG4gICAgICAgIGlmIChjb2xsZWN0QW5kRmxhZ1swXSA9PT0gJy8nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl90ZXJtaW5hbC5zZXRnQ2hhcnNldChHTEVWRUxbY29sbGVjdEFuZEZsYWdbMF1dLCBDaGFyc2V0c18xLkNIQVJTRVRTW2NvbGxlY3RBbmRGbGFnWzFdXSB8fCBDaGFyc2V0c18xLkRFRkFVTFRfQ0hBUlNFVCk7XG4gICAgfTtcbiAgICBJbnB1dEhhbmRsZXIucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90ZXJtaW5hbC5pbmRleCgpO1xuICAgIH07XG4gICAgSW5wdXRIYW5kbGVyLnByb3RvdHlwZS50YWJTZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsLnRhYlNldCgpO1xuICAgIH07XG4gICAgSW5wdXRIYW5kbGVyLnByb3RvdHlwZS5yZXZlcnNlSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsLnJldmVyc2VJbmRleCgpO1xuICAgIH07XG4gICAgSW5wdXRIYW5kbGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcGFyc2VyLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsLnJlc2V0KCk7XG4gICAgfTtcbiAgICBJbnB1dEhhbmRsZXIucHJvdG90eXBlLnNldGdMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICB0aGlzLl90ZXJtaW5hbC5zZXRnTGV2ZWwobGV2ZWwpO1xuICAgIH07XG4gICAgcmV0dXJuIElucHV0SGFuZGxlcjtcbn0oTGlmZWN5Y2xlXzEuRGlzcG9zYWJsZSkpO1xuZXhwb3J0cy5JbnB1dEhhbmRsZXIgPSBJbnB1dEhhbmRsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbnB1dEhhbmRsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE1vdXNlWm9uZU1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL3VpL01vdXNlWm9uZU1hbmFnZXJcIik7XG52YXIgRXZlbnRFbWl0dGVyXzEgPSByZXF1aXJlKFwiLi9jb21tb24vRXZlbnRFbWl0dGVyXCIpO1xudmFyIEJ1ZmZlcl8xID0gcmVxdWlyZShcIi4vQnVmZmVyXCIpO1xudmFyIENoYXJXaWR0aF8xID0gcmVxdWlyZShcIi4vQ2hhcldpZHRoXCIpO1xudmFyIExpbmtpZmllciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpbmtpZmllciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaW5raWZpZXIoX3Rlcm1pbmFsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl90ZXJtaW5hbCA9IF90ZXJtaW5hbDtcbiAgICAgICAgX3RoaXMuX2xpbmtNYXRjaGVycyA9IFtdO1xuICAgICAgICBfdGhpcy5fbmV4dExpbmtNYXRjaGVySWQgPSAwO1xuICAgICAgICBfdGhpcy5fcm93c1RvTGlua2lmeSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBudWxsLFxuICAgICAgICAgICAgZW5kOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTGlua2lmaWVyLnByb3RvdHlwZS5hdHRhY2hUb0RvbSA9IGZ1bmN0aW9uIChtb3VzZVpvbmVNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMuX21vdXNlWm9uZU1hbmFnZXIgPSBtb3VzZVpvbmVNYW5hZ2VyO1xuICAgIH07XG4gICAgTGlua2lmaWVyLnByb3RvdHlwZS5saW5raWZ5Um93cyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5fbW91c2Vab25lTWFuYWdlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9yb3dzVG9MaW5raWZ5LnN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9yb3dzVG9MaW5raWZ5LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICB0aGlzLl9yb3dzVG9MaW5raWZ5LmVuZCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvd3NUb0xpbmtpZnkuc3RhcnQgPSBNYXRoLm1pbih0aGlzLl9yb3dzVG9MaW5raWZ5LnN0YXJ0LCBzdGFydCk7XG4gICAgICAgICAgICB0aGlzLl9yb3dzVG9MaW5raWZ5LmVuZCA9IE1hdGgubWF4KHRoaXMuX3Jvd3NUb0xpbmtpZnkuZW5kLCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21vdXNlWm9uZU1hbmFnZXIuY2xlYXJBbGwoc3RhcnQsIGVuZCk7XG4gICAgICAgIGlmICh0aGlzLl9yb3dzVGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fcm93c1RpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcm93c1RpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2xpbmtpZnlSb3dzKCk7IH0sIExpbmtpZmllci5USU1FX0JFRk9SRV9MSU5LSUZZKTtcbiAgICB9O1xuICAgIExpbmtpZmllci5wcm90b3R5cGUuX2xpbmtpZnlSb3dzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yb3dzVGltZW91dElkID0gbnVsbDtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlcjtcbiAgICAgICAgdmFyIGFic29sdXRlUm93SW5kZXhTdGFydCA9IGJ1ZmZlci55ZGlzcCArIHRoaXMuX3Jvd3NUb0xpbmtpZnkuc3RhcnQ7XG4gICAgICAgIGlmIChhYnNvbHV0ZVJvd0luZGV4U3RhcnQgPj0gYnVmZmVyLmxpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhYnNvbHV0ZVJvd0luZGV4RW5kID0gYnVmZmVyLnlkaXNwICsgTWF0aC5taW4odGhpcy5fcm93c1RvTGlua2lmeS5lbmQsIHRoaXMuX3Rlcm1pbmFsLnJvd3MpICsgMTtcbiAgICAgICAgdmFyIG92ZXJzY2FuTGluZUxpbWl0ID0gTWF0aC5jZWlsKExpbmtpZmllci5PVkVSU0NBTl9DSEFSX0xJTUlUIC8gdGhpcy5fdGVybWluYWwuY29scyk7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci5pdGVyYXRvcihmYWxzZSwgYWJzb2x1dGVSb3dJbmRleFN0YXJ0LCBhYnNvbHV0ZVJvd0luZGV4RW5kLCBvdmVyc2NhbkxpbmVMaW1pdCwgb3ZlcnNjYW5MaW5lTGltaXQpO1xuICAgICAgICB3aGlsZSAoaXRlcmF0b3IuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgbGluZURhdGEgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xpbmtNYXRjaGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RvTGlua2lmeVJvdyhsaW5lRGF0YS5yYW5nZS5maXJzdCwgbGluZURhdGEuY29udGVudCwgdGhpcy5fbGlua01hdGNoZXJzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yb3dzVG9MaW5raWZ5LnN0YXJ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcm93c1RvTGlua2lmeS5lbmQgPSBudWxsO1xuICAgIH07XG4gICAgTGlua2lmaWVyLnByb3RvdHlwZS5yZWdpc3RlckxpbmtNYXRjaGVyID0gZnVuY3Rpb24gKHJlZ2V4LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYW5kbGVyIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXRjaGVyID0ge1xuICAgICAgICAgICAgaWQ6IHRoaXMuX25leHRMaW5rTWF0Y2hlcklkKyssXG4gICAgICAgICAgICByZWdleDogcmVnZXgsXG4gICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgICAgICAgbWF0Y2hJbmRleDogb3B0aW9ucy5tYXRjaEluZGV4LFxuICAgICAgICAgICAgdmFsaWRhdGlvbkNhbGxiYWNrOiBvcHRpb25zLnZhbGlkYXRpb25DYWxsYmFjayxcbiAgICAgICAgICAgIGhvdmVyVG9vbHRpcENhbGxiYWNrOiBvcHRpb25zLnRvb2x0aXBDYWxsYmFjayxcbiAgICAgICAgICAgIGhvdmVyTGVhdmVDYWxsYmFjazogb3B0aW9ucy5sZWF2ZUNhbGxiYWNrLFxuICAgICAgICAgICAgd2lsbExpbmtBY3RpdmF0ZTogb3B0aW9ucy53aWxsTGlua0FjdGl2YXRlLFxuICAgICAgICAgICAgcHJpb3JpdHk6IG9wdGlvbnMucHJpb3JpdHkgfHwgMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9hZGRMaW5rTWF0Y2hlclRvTGlzdChtYXRjaGVyKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXIuaWQ7XG4gICAgfTtcbiAgICBMaW5raWZpZXIucHJvdG90eXBlLl9hZGRMaW5rTWF0Y2hlclRvTGlzdCA9IGZ1bmN0aW9uIChtYXRjaGVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9saW5rTWF0Y2hlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5rTWF0Y2hlcnMucHVzaChtYXRjaGVyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5fbGlua01hdGNoZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2hlci5wcmlvcml0eSA8PSB0aGlzLl9saW5rTWF0Y2hlcnNbaV0ucHJpb3JpdHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5rTWF0Y2hlcnMuc3BsaWNlKGkgKyAxLCAwLCBtYXRjaGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGlua01hdGNoZXJzLnNwbGljZSgwLCAwLCBtYXRjaGVyKTtcbiAgICB9O1xuICAgIExpbmtpZmllci5wcm90b3R5cGUuZGVyZWdpc3RlckxpbmtNYXRjaGVyID0gZnVuY3Rpb24gKG1hdGNoZXJJZCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xpbmtNYXRjaGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xpbmtNYXRjaGVyc1tpXS5pZCA9PT0gbWF0Y2hlcklkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlua01hdGNoZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBMaW5raWZpZXIucHJvdG90eXBlLl9kb0xpbmtpZnlSb3cgPSBmdW5jdGlvbiAocm93SW5kZXgsIHRleHQsIG1hdGNoZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJleCA9IG5ldyBSZWdFeHAobWF0Y2hlci5yZWdleC5zb3VyY2UsIG1hdGNoZXIucmVnZXguZmxhZ3MgKyAnZycpO1xuICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgIHZhciBzdHJpbmdJbmRleCA9IC0xO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1cmkgPSBtYXRjaFt0eXBlb2YgbWF0Y2hlci5tYXRjaEluZGV4ICE9PSAnbnVtYmVyJyA/IDAgOiBtYXRjaGVyLm1hdGNoSW5kZXhdO1xuICAgICAgICAgICAgaWYgKCF1cmkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc18xLl90ZXJtaW5hbC5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh7IG1hdGNoOiBtYXRjaCwgbWF0Y2hlcjogbWF0Y2hlciB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXRjaCBmb3VuZCB3aXRob3V0IGNvcnJlc3BvbmRpbmcgbWF0Y2hJbmRleCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyaW5nSW5kZXggPSB0ZXh0LmluZGV4T2YodXJpLCBzdHJpbmdJbmRleCArIDEpO1xuICAgICAgICAgICAgcmV4Lmxhc3RJbmRleCA9IHN0cmluZ0luZGV4ICsgdXJpLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBidWZmZXJJbmRleCA9IHRoaXNfMS5fdGVybWluYWwuYnVmZmVyLnN0cmluZ0luZGV4VG9CdWZmZXJJbmRleChyb3dJbmRleCwgc3RyaW5nSW5kZXgpO1xuICAgICAgICAgICAgdmFyIGxpbmUgPSB0aGlzXzEuX3Rlcm1pbmFsLmJ1ZmZlci5saW5lcy5nZXQoYnVmZmVySW5kZXhbMF0pO1xuICAgICAgICAgICAgdmFyIGNoYXIgPSBsaW5lLmdldChidWZmZXJJbmRleFsxXSk7XG4gICAgICAgICAgICB2YXIgZmc7XG4gICAgICAgICAgICBpZiAoY2hhcikge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyID0gY2hhcltCdWZmZXJfMS5DSEFSX0RBVEFfQVRUUl9JTkRFWF07XG4gICAgICAgICAgICAgICAgZmcgPSAoYXR0ciA+PiA5KSAmIDB4MWZmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoZXIudmFsaWRhdGlvbkNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlci52YWxpZGF0aW9uQ2FsbGJhY2sodXJpLCBmdW5jdGlvbiAoaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX3Jvd3NUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FkZExpbmsoYnVmZmVySW5kZXhbMV0sIGJ1ZmZlckluZGV4WzBdIC0gX3RoaXMuX3Rlcm1pbmFsLmJ1ZmZlci55ZGlzcCwgdXJpLCBtYXRjaGVyLCBmZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNfMS5fYWRkTGluayhidWZmZXJJbmRleFsxXSwgYnVmZmVySW5kZXhbMF0gLSB0aGlzXzEuX3Rlcm1pbmFsLmJ1ZmZlci55ZGlzcCwgdXJpLCBtYXRjaGVyLCBmZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xuICAgICAgICB3aGlsZSAoKG1hdGNoID0gcmV4LmV4ZWModGV4dCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGVfMSA9IF9sb29wXzEoKTtcbiAgICAgICAgICAgIGlmIChzdGF0ZV8xID09PSBcImJyZWFrXCIpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExpbmtpZmllci5wcm90b3R5cGUuX2FkZExpbmsgPSBmdW5jdGlvbiAoeCwgeSwgdXJpLCBtYXRjaGVyLCBmZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgd2lkdGggPSBDaGFyV2lkdGhfMS5nZXRTdHJpbmdDZWxsV2lkdGgodXJpKTtcbiAgICAgICAgdmFyIHgxID0geCAlIHRoaXMuX3Rlcm1pbmFsLmNvbHM7XG4gICAgICAgIHZhciB5MSA9IHkgKyBNYXRoLmZsb29yKHggLyB0aGlzLl90ZXJtaW5hbC5jb2xzKTtcbiAgICAgICAgdmFyIHgyID0gKHgxICsgd2lkdGgpICUgdGhpcy5fdGVybWluYWwuY29scztcbiAgICAgICAgdmFyIHkyID0geTEgKyBNYXRoLmZsb29yKCh4MSArIHdpZHRoKSAvIHRoaXMuX3Rlcm1pbmFsLmNvbHMpO1xuICAgICAgICBpZiAoeDIgPT09IDApIHtcbiAgICAgICAgICAgIHgyID0gdGhpcy5fdGVybWluYWwuY29scztcbiAgICAgICAgICAgIHkyLS07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbW91c2Vab25lTWFuYWdlci5hZGQobmV3IE1vdXNlWm9uZU1hbmFnZXJfMS5Nb3VzZVpvbmUoeDEgKyAxLCB5MSArIDEsIHgyICsgMSwgeTIgKyAxLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKG1hdGNoZXIuaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVyLmhhbmRsZXIoZSwgdXJpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpbmRvdy5vcGVuKHVyaSwgJ19ibGFuaycpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgX3RoaXMuZW1pdChcImxpbmtob3ZlclwiLCBfdGhpcy5fY3JlYXRlTGlua0hvdmVyRXZlbnQoeDEsIHkxLCB4MiwgeTIsIGZnKSk7XG4gICAgICAgICAgICBfdGhpcy5fdGVybWluYWwuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCd4dGVybS1jdXJzb3ItcG9pbnRlcicpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgX3RoaXMuZW1pdChcImxpbmt0b29sdGlwXCIsIF90aGlzLl9jcmVhdGVMaW5rSG92ZXJFdmVudCh4MSwgeTEsIHgyLCB5MiwgZmcpKTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVyLmhvdmVyVG9vbHRpcENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlci5ob3ZlclRvb2x0aXBDYWxsYmFjayhlLCB1cmkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KFwibGlua2xlYXZlXCIsIF90aGlzLl9jcmVhdGVMaW5rSG92ZXJFdmVudCh4MSwgeTEsIHgyLCB5MiwgZmcpKTtcbiAgICAgICAgICAgIF90aGlzLl90ZXJtaW5hbC5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ3h0ZXJtLWN1cnNvci1wb2ludGVyJyk7XG4gICAgICAgICAgICBpZiAobWF0Y2hlci5ob3ZlckxlYXZlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVyLmhvdmVyTGVhdmVDYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKG1hdGNoZXIud2lsbExpbmtBY3RpdmF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVyLndpbGxMaW5rQWN0aXZhdGUoZSwgdXJpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICBMaW5raWZpZXIucHJvdG90eXBlLl9jcmVhdGVMaW5rSG92ZXJFdmVudCA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgZmcpIHtcbiAgICAgICAgcmV0dXJuIHsgeDE6IHgxLCB5MTogeTEsIHgyOiB4MiwgeTI6IHkyLCBjb2xzOiB0aGlzLl90ZXJtaW5hbC5jb2xzLCBmZzogZmcgfTtcbiAgICB9O1xuICAgIExpbmtpZmllci5USU1FX0JFRk9SRV9MSU5LSUZZID0gMjAwO1xuICAgIExpbmtpZmllci5PVkVSU0NBTl9DSEFSX0xJTUlUID0gMjAwMDtcbiAgICByZXR1cm4gTGlua2lmaWVyO1xufShFdmVudEVtaXR0ZXJfMS5FdmVudEVtaXR0ZXIpKTtcbmV4cG9ydHMuTGlua2lmaWVyID0gTGlua2lmaWVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGlua2lmaWVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBNb3VzZUhlbHBlcl8xID0gcmVxdWlyZShcIi4vdXRpbHMvTW91c2VIZWxwZXJcIik7XG52YXIgQnJvd3NlciA9IHJlcXVpcmUoXCIuL3NoYXJlZC91dGlscy9Ccm93c2VyXCIpO1xudmFyIEV2ZW50RW1pdHRlcl8xID0gcmVxdWlyZShcIi4vY29tbW9uL0V2ZW50RW1pdHRlclwiKTtcbnZhciBTZWxlY3Rpb25Nb2RlbF8xID0gcmVxdWlyZShcIi4vU2VsZWN0aW9uTW9kZWxcIik7XG52YXIgQnVmZmVyXzEgPSByZXF1aXJlKFwiLi9CdWZmZXJcIik7XG52YXIgQWx0Q2xpY2tIYW5kbGVyXzEgPSByZXF1aXJlKFwiLi9oYW5kbGVycy9BbHRDbGlja0hhbmRsZXJcIik7XG52YXIgRFJBR19TQ1JPTExfTUFYX1RIUkVTSE9MRCA9IDUwO1xudmFyIERSQUdfU0NST0xMX01BWF9TUEVFRCA9IDE1O1xudmFyIERSQUdfU0NST0xMX0lOVEVSVkFMID0gNTA7XG52YXIgQUxUX0NMSUNLX01PVkVfQ1VSU09SX1RJTUUgPSA1MDA7XG52YXIgV09SRF9TRVBBUkFUT1JTID0gJyAoKVtde31cXCdcIic7XG52YXIgTk9OX0JSRUFLSU5HX1NQQUNFX0NIQVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDE2MCk7XG52YXIgQUxMX05PTl9CUkVBS0lOR19TUEFDRV9SRUdFWCA9IG5ldyBSZWdFeHAoTk9OX0JSRUFLSU5HX1NQQUNFX0NIQVIsICdnJyk7XG52YXIgU2VsZWN0aW9uTWFuYWdlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlbGVjdGlvbk1hbmFnZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2VsZWN0aW9uTWFuYWdlcihfdGVybWluYWwsIF9jaGFyTWVhc3VyZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fdGVybWluYWwgPSBfdGVybWluYWw7XG4gICAgICAgIF90aGlzLl9jaGFyTWVhc3VyZSA9IF9jaGFyTWVhc3VyZTtcbiAgICAgICAgX3RoaXMuX2VuYWJsZWQgPSB0cnVlO1xuICAgICAgICBfdGhpcy5faW5pdExpc3RlbmVycygpO1xuICAgICAgICBfdGhpcy5lbmFibGUoKTtcbiAgICAgICAgX3RoaXMuX21vZGVsID0gbmV3IFNlbGVjdGlvbk1vZGVsXzEuU2VsZWN0aW9uTW9kZWwoX3Rlcm1pbmFsKTtcbiAgICAgICAgX3RoaXMuX2FjdGl2ZVNlbGVjdGlvbk1vZGUgPSAwO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9yZW1vdmVNb3VzZURvd25MaXN0ZW5lcnMoKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZSwgXCJfYnVmZmVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGVybWluYWwuYnVmZmVycy5hY3RpdmU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLl9pbml0TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9tb3VzZU1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gX3RoaXMuX29uTW91c2VNb3ZlKGV2ZW50KTsgfTtcbiAgICAgICAgdGhpcy5fbW91c2VVcExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBfdGhpcy5fb25Nb3VzZVVwKGV2ZW50KTsgfTtcbiAgICAgICAgdGhpcy5fdHJpbUxpc3RlbmVyID0gZnVuY3Rpb24gKGFtb3VudCkgeyByZXR1cm4gX3RoaXMuX29uVHJpbShhbW91bnQpOyB9O1xuICAgICAgICB0aGlzLmluaXRCdWZmZXJzTGlzdGVuZXJzKCk7XG4gICAgfTtcbiAgICBTZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5pbml0QnVmZmVyc0xpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fdGVybWluYWwuYnVmZmVyLmxpbmVzLm9uKCd0cmltJywgdGhpcy5fdHJpbUxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5fdGVybWluYWwuYnVmZmVycy5vbignYWN0aXZhdGUnLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3RoaXMuX29uQnVmZmVyQWN0aXZhdGUoZSk7IH0pO1xuICAgIH07XG4gICAgU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG4gICAgfTtcbiAgICBTZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLCBcInNlbGVjdGlvblN0YXJ0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tb2RlbC5maW5hbFNlbGVjdGlvblN0YXJ0OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUsIFwic2VsZWN0aW9uRW5kXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tb2RlbC5maW5hbFNlbGVjdGlvbkVuZDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLCBcImhhc1NlbGVjdGlvblwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fbW9kZWwuZmluYWxTZWxlY3Rpb25TdGFydDtcbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLl9tb2RlbC5maW5hbFNlbGVjdGlvbkVuZDtcbiAgICAgICAgICAgIGlmICghc3RhcnQgfHwgIWVuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdGFydFswXSAhPT0gZW5kWzBdIHx8IHN0YXJ0WzFdICE9PSBlbmRbMV07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZSwgXCJzZWxlY3Rpb25UZXh0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9tb2RlbC5maW5hbFNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgdmFyIGVuZCA9IHRoaXMuX21vZGVsLmZpbmFsU2VsZWN0aW9uRW5kO1xuICAgICAgICAgICAgaWYgKCFzdGFydCB8fCAhZW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZVNlbGVjdGlvbk1vZGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRbMF0gPT09IGVuZFswXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydFsxXTsgaSA8PSBlbmRbMV07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZVRleHQgPSB0aGlzLl9idWZmZXIudHJhbnNsYXRlQnVmZmVyTGluZVRvU3RyaW5nKGksIHRydWUsIHN0YXJ0WzBdLCBlbmRbMF0pO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsaW5lVGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0Um93RW5kQ29sID0gc3RhcnRbMV0gPT09IGVuZFsxXSA/IGVuZFswXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5fYnVmZmVyLnRyYW5zbGF0ZUJ1ZmZlckxpbmVUb1N0cmluZyhzdGFydFsxXSwgdHJ1ZSwgc3RhcnRbMF0sIHN0YXJ0Um93RW5kQ29sKSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0WzFdICsgMTsgaSA8PSBlbmRbMV0gLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1ZmZlckxpbmUgPSB0aGlzLl9idWZmZXIubGluZXMuZ2V0KGkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZVRleHQgPSB0aGlzLl9idWZmZXIudHJhbnNsYXRlQnVmZmVyTGluZVRvU3RyaW5nKGksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyTGluZS5pc1dyYXBwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gKz0gbGluZVRleHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsaW5lVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0WzFdICE9PSBlbmRbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1ZmZlckxpbmUgPSB0aGlzLl9idWZmZXIubGluZXMuZ2V0KGVuZFsxXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lVGV4dCA9IHRoaXMuX2J1ZmZlci50cmFuc2xhdGVCdWZmZXJMaW5lVG9TdHJpbmcoZW5kWzFdLCB0cnVlLCAwLCBlbmRbMF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyTGluZS5pc1dyYXBwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gKz0gbGluZVRleHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsaW5lVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVkUmVzdWx0ID0gcmVzdWx0Lm1hcChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsaW5lLnJlcGxhY2UoQUxMX05PTl9CUkVBS0lOR19TUEFDRV9SRUdFWCwgJyAnKTtcbiAgICAgICAgICAgIH0pLmpvaW4oQnJvd3Nlci5pc01TV2luZG93cyA/ICdcXHJcXG4nIDogJ1xcbicpO1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlZFJlc3VsdDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2xlYXJTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX21vZGVsLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZU1vdXNlRG93bkxpc3RlbmVycygpO1xuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoaXNOZXdTZWxlY3Rpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLl9yZWZyZXNoQW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlZnJlc2hBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3JlZnJlc2goKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJyb3dzZXIuaXNMaW51eCAmJiBpc05ld1NlbGVjdGlvbikge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvblRleHQgPSB0aGlzLnNlbGVjdGlvblRleHQ7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uVGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ25ld3NlbGVjdGlvbicsIHRoaXMuc2VsZWN0aW9uVGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLl9yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yZWZyZXNoQW5pbWF0aW9uRnJhbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmVtaXQoJ3JlZnJlc2gnLCB7XG4gICAgICAgICAgICBzdGFydDogdGhpcy5fbW9kZWwuZmluYWxTZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgIGVuZDogdGhpcy5fbW9kZWwuZmluYWxTZWxlY3Rpb25FbmQsXG4gICAgICAgICAgICBjb2x1bW5TZWxlY3RNb2RlOiB0aGlzLl9hY3RpdmVTZWxlY3Rpb25Nb2RlID09PSAzXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuaXNDbGlja0luU2VsZWN0aW9uID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBjb29yZHMgPSB0aGlzLl9nZXRNb3VzZUJ1ZmZlckNvb3JkcyhldmVudCk7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuX21vZGVsLmZpbmFsU2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLl9tb2RlbC5maW5hbFNlbGVjdGlvbkVuZDtcbiAgICAgICAgaWYgKCFzdGFydCB8fCAhZW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjb29yZHNbMV0gPiBzdGFydFsxXSAmJiBjb29yZHNbMV0gPCBlbmRbMV0pIHx8XG4gICAgICAgICAgICAoc3RhcnRbMV0gPT09IGVuZFsxXSAmJiBjb29yZHNbMV0gPT09IHN0YXJ0WzFdICYmIGNvb3Jkc1swXSA+IHN0YXJ0WzBdICYmIGNvb3Jkc1swXSA8IGVuZFswXSkgfHxcbiAgICAgICAgICAgIChzdGFydFsxXSA8IGVuZFsxXSAmJiBjb29yZHNbMV0gPT09IGVuZFsxXSAmJiBjb29yZHNbMF0gPCBlbmRbMF0pO1xuICAgIH07XG4gICAgU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2VsZWN0V29yZEF0Q3Vyc29yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBjb29yZHMgPSB0aGlzLl9nZXRNb3VzZUJ1ZmZlckNvb3JkcyhldmVudCk7XG4gICAgICAgIGlmIChjb29yZHMpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdFdvcmRBdChjb29yZHMsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuX21vZGVsLnNlbGVjdGlvbkVuZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2godHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNlbGVjdEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbW9kZWwuaXNTZWxlY3RBbGxBY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgdGhpcy5fdGVybWluYWwuZW1pdCgnc2VsZWN0aW9uJyk7XG4gICAgfTtcbiAgICBTZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZWxlY3RMaW5lcyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHRoaXMuX21vZGVsLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoc3RhcnQsIDApO1xuICAgICAgICBlbmQgPSBNYXRoLm1pbihlbmQsIHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci5saW5lcy5sZW5ndGggLSAxKTtcbiAgICAgICAgdGhpcy5fbW9kZWwuc2VsZWN0aW9uU3RhcnQgPSBbMCwgc3RhcnRdO1xuICAgICAgICB0aGlzLl9tb2RlbC5zZWxlY3Rpb25FbmQgPSBbdGhpcy5fdGVybWluYWwuY29scywgZW5kXTtcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsLmVtaXQoJ3NlbGVjdGlvbicpO1xuICAgIH07XG4gICAgU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuX29uVHJpbSA9IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgdmFyIG5lZWRzUmVmcmVzaCA9IHRoaXMuX21vZGVsLm9uVHJpbShhbW91bnQpO1xuICAgICAgICBpZiAobmVlZHNSZWZyZXNoKSB7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuX2dldE1vdXNlQnVmZmVyQ29vcmRzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBjb29yZHMgPSB0aGlzLl90ZXJtaW5hbC5tb3VzZUhlbHBlci5nZXRDb29yZHMoZXZlbnQsIHRoaXMuX3Rlcm1pbmFsLnNjcmVlbkVsZW1lbnQsIHRoaXMuX2NoYXJNZWFzdXJlLCB0aGlzLl90ZXJtaW5hbC5vcHRpb25zLmxpbmVIZWlnaHQsIHRoaXMuX3Rlcm1pbmFsLmNvbHMsIHRoaXMuX3Rlcm1pbmFsLnJvd3MsIHRydWUpO1xuICAgICAgICBpZiAoIWNvb3Jkcykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29vcmRzWzBdLS07XG4gICAgICAgIGNvb3Jkc1sxXS0tO1xuICAgICAgICBjb29yZHNbMV0gKz0gdGhpcy5fdGVybWluYWwuYnVmZmVyLnlkaXNwO1xuICAgICAgICByZXR1cm4gY29vcmRzO1xuICAgIH07XG4gICAgU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuX2dldE1vdXNlRXZlbnRTY3JvbGxBbW91bnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IE1vdXNlSGVscGVyXzEuTW91c2VIZWxwZXIuZ2V0Q29vcmRzUmVsYXRpdmVUb0VsZW1lbnQoZXZlbnQsIHRoaXMuX3Rlcm1pbmFsLnNjcmVlbkVsZW1lbnQpWzFdO1xuICAgICAgICB2YXIgdGVybWluYWxIZWlnaHQgPSB0aGlzLl90ZXJtaW5hbC5yb3dzICogTWF0aC5jZWlsKHRoaXMuX2NoYXJNZWFzdXJlLmhlaWdodCAqIHRoaXMuX3Rlcm1pbmFsLm9wdGlvbnMubGluZUhlaWdodCk7XG4gICAgICAgIGlmIChvZmZzZXQgPj0gMCAmJiBvZmZzZXQgPD0gdGVybWluYWxIZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgPiB0ZXJtaW5hbEhlaWdodCkge1xuICAgICAgICAgICAgb2Zmc2V0IC09IHRlcm1pbmFsSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCA9IE1hdGgubWluKE1hdGgubWF4KG9mZnNldCwgLURSQUdfU0NST0xMX01BWF9USFJFU0hPTEQpLCBEUkFHX1NDUk9MTF9NQVhfVEhSRVNIT0xEKTtcbiAgICAgICAgb2Zmc2V0IC89IERSQUdfU0NST0xMX01BWF9USFJFU0hPTEQ7XG4gICAgICAgIHJldHVybiAob2Zmc2V0IC8gTWF0aC5hYnMob2Zmc2V0KSkgKyBNYXRoLnJvdW5kKG9mZnNldCAqIChEUkFHX1NDUk9MTF9NQVhfU1BFRUQgLSAxKSk7XG4gICAgfTtcbiAgICBTZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zaG91bGRGb3JjZVNlbGVjdGlvbiA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoQnJvd3Nlci5pc01hYykge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50LmFsdEtleSAmJiB0aGlzLl90ZXJtaW5hbC5vcHRpb25zLm1hY09wdGlvbkNsaWNrRm9yY2VzU2VsZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudC5zaGlmdEtleTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLm9uTW91c2VEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX21vdXNlRG93blRpbWVTdGFtcCA9IGV2ZW50LnRpbWVTdGFtcDtcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gMiAmJiB0aGlzLmhhc1NlbGVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2VuYWJsZWQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zaG91bGRGb3JjZVNlbGVjdGlvbihldmVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLl9kcmFnU2Nyb2xsQW1vdW50ID0gMDtcbiAgICAgICAgaWYgKHRoaXMuX2VuYWJsZWQgJiYgZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIHRoaXMuX29uSW5jcmVtZW50YWxDbGljayhldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuZGV0YWlsID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TaW5nbGVDbGljayhldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5kZXRhaWwgPT09IDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkRvdWJsZUNsaWNrKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmRldGFpbCA9PT0gMykge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uVHJpcGxlQ2xpY2soZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FkZE1vdXNlRG93bkxpc3RlbmVycygpO1xuICAgICAgICB0aGlzLnJlZnJlc2godHJ1ZSk7XG4gICAgfTtcbiAgICBTZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5fYWRkTW91c2VEb3duTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl90ZXJtaW5hbC5lbGVtZW50Lm93bmVyRG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fbW91c2VNb3ZlTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLl90ZXJtaW5hbC5lbGVtZW50Lm93bmVyRG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX21vdXNlVXBMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuX2RyYWdTY3JvbGxJbnRlcnZhbFRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2RyYWdTY3JvbGwoKTsgfSwgRFJBR19TQ1JPTExfSU5URVJWQUwpO1xuICAgIH07XG4gICAgU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuX3JlbW92ZU1vdXNlRG93bkxpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Rlcm1pbmFsLmVsZW1lbnQub3duZXJEb2N1bWVudCkge1xuICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuZWxlbWVudC5vd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX21vdXNlTW92ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLmVsZW1lbnQub3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fbW91c2VVcExpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX2RyYWdTY3JvbGxJbnRlcnZhbFRpbWVyKTtcbiAgICAgICAgdGhpcy5fZHJhZ1Njcm9sbEludGVydmFsVGltZXIgPSBudWxsO1xuICAgIH07XG4gICAgU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuX29uSW5jcmVtZW50YWxDbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5fbW9kZWwuc2VsZWN0aW9uU3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMuX21vZGVsLnNlbGVjdGlvbkVuZCA9IHRoaXMuX2dldE1vdXNlQnVmZmVyQ29vcmRzKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuX29uU2luZ2xlQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fbW9kZWwuc2VsZWN0aW9uU3RhcnRMZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl9tb2RlbC5pc1NlbGVjdEFsbEFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9hY3RpdmVTZWxlY3Rpb25Nb2RlID0gdGhpcy5zaG91bGRDb2x1bW5TZWxlY3QoZXZlbnQpID8gMyA6IDA7XG4gICAgICAgIHRoaXMuX21vZGVsLnNlbGVjdGlvblN0YXJ0ID0gdGhpcy5fZ2V0TW91c2VCdWZmZXJDb29yZHMoZXZlbnQpO1xuICAgICAgICBpZiAoIXRoaXMuX21vZGVsLnNlbGVjdGlvblN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbW9kZWwuc2VsZWN0aW9uRW5kID0gbnVsbDtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLl9idWZmZXIubGluZXMuZ2V0KHRoaXMuX21vZGVsLnNlbGVjdGlvblN0YXJ0WzFdKTtcbiAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmUubGVuZ3RoID49IHRoaXMuX21vZGVsLnNlbGVjdGlvblN0YXJ0WzBdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYXIgPSBsaW5lLmdldCh0aGlzLl9tb2RlbC5zZWxlY3Rpb25TdGFydFswXSk7XG4gICAgICAgIGlmIChjaGFyW0J1ZmZlcl8xLkNIQVJfREFUQV9XSURUSF9JTkRFWF0gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX21vZGVsLnNlbGVjdGlvblN0YXJ0WzBdKys7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLl9vbkRvdWJsZUNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBjb29yZHMgPSB0aGlzLl9nZXRNb3VzZUJ1ZmZlckNvb3JkcyhldmVudCk7XG4gICAgICAgIGlmIChjb29yZHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVNlbGVjdGlvbk1vZGUgPSAxO1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0V29yZEF0KGNvb3JkcywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLl9vblRyaXBsZUNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBjb29yZHMgPSB0aGlzLl9nZXRNb3VzZUJ1ZmZlckNvb3JkcyhldmVudCk7XG4gICAgICAgIGlmIChjb29yZHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVNlbGVjdGlvbk1vZGUgPSAyO1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0TGluZUF0KGNvb3Jkc1sxXSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNob3VsZENvbHVtblNlbGVjdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gZXZlbnQuYWx0S2V5ICYmICEoQnJvd3Nlci5pc01hYyAmJiB0aGlzLl90ZXJtaW5hbC5vcHRpb25zLm1hY09wdGlvbkNsaWNrRm9yY2VzU2VsZWN0aW9uKTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLl9vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdmFyIHByZXZpb3VzU2VsZWN0aW9uRW5kID0gdGhpcy5fbW9kZWwuc2VsZWN0aW9uRW5kID8gW3RoaXMuX21vZGVsLnNlbGVjdGlvbkVuZFswXSwgdGhpcy5fbW9kZWwuc2VsZWN0aW9uRW5kWzFdXSA6IG51bGw7XG4gICAgICAgIHRoaXMuX21vZGVsLnNlbGVjdGlvbkVuZCA9IHRoaXMuX2dldE1vdXNlQnVmZmVyQ29vcmRzKGV2ZW50KTtcbiAgICAgICAgaWYgKCF0aGlzLl9tb2RlbC5zZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCh0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYWN0aXZlU2VsZWN0aW9uTW9kZSA9PT0gMikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21vZGVsLnNlbGVjdGlvbkVuZFsxXSA8IHRoaXMuX21vZGVsLnNlbGVjdGlvblN0YXJ0WzFdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9kZWwuc2VsZWN0aW9uRW5kWzBdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vZGVsLnNlbGVjdGlvbkVuZFswXSA9IHRoaXMuX3Rlcm1pbmFsLmNvbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fYWN0aXZlU2VsZWN0aW9uTW9kZSA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0VG9Xb3JkQXQodGhpcy5fbW9kZWwuc2VsZWN0aW9uRW5kKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kcmFnU2Nyb2xsQW1vdW50ID0gdGhpcy5fZ2V0TW91c2VFdmVudFNjcm9sbEFtb3VudChldmVudCk7XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVTZWxlY3Rpb25Nb2RlICE9PSAzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZHJhZ1Njcm9sbEFtb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb2RlbC5zZWxlY3Rpb25FbmRbMF0gPSB0aGlzLl90ZXJtaW5hbC5jb2xzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fZHJhZ1Njcm9sbEFtb3VudCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb2RlbC5zZWxlY3Rpb25FbmRbMF0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9tb2RlbC5zZWxlY3Rpb25FbmRbMV0gPCB0aGlzLl9idWZmZXIubGluZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgY2hhciA9IHRoaXMuX2J1ZmZlci5saW5lcy5nZXQodGhpcy5fbW9kZWwuc2VsZWN0aW9uRW5kWzFdKS5nZXQodGhpcy5fbW9kZWwuc2VsZWN0aW9uRW5kWzBdKTtcbiAgICAgICAgICAgIGlmIChjaGFyICYmIGNoYXJbQnVmZmVyXzEuQ0hBUl9EQVRBX1dJRFRIX0lOREVYXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vZGVsLnNlbGVjdGlvbkVuZFswXSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcHJldmlvdXNTZWxlY3Rpb25FbmQgfHxcbiAgICAgICAgICAgIHByZXZpb3VzU2VsZWN0aW9uRW5kWzBdICE9PSB0aGlzLl9tb2RlbC5zZWxlY3Rpb25FbmRbMF0gfHxcbiAgICAgICAgICAgIHByZXZpb3VzU2VsZWN0aW9uRW5kWzFdICE9PSB0aGlzLl9tb2RlbC5zZWxlY3Rpb25FbmRbMV0pIHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCh0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuX2RyYWdTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kcmFnU2Nyb2xsQW1vdW50KSB7XG4gICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC5zY3JvbGxMaW5lcyh0aGlzLl9kcmFnU2Nyb2xsQW1vdW50LCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fZHJhZ1Njcm9sbEFtb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYWN0aXZlU2VsZWN0aW9uTW9kZSAhPT0gMykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tb2RlbC5zZWxlY3Rpb25FbmRbMF0gPSB0aGlzLl90ZXJtaW5hbC5jb2xzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9tb2RlbC5zZWxlY3Rpb25FbmRbMV0gPSBNYXRoLm1pbih0aGlzLl90ZXJtaW5hbC5idWZmZXIueWRpc3AgKyB0aGlzLl90ZXJtaW5hbC5yb3dzLCB0aGlzLl90ZXJtaW5hbC5idWZmZXIubGluZXMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYWN0aXZlU2VsZWN0aW9uTW9kZSAhPT0gMykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tb2RlbC5zZWxlY3Rpb25FbmRbMF0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9tb2RlbC5zZWxlY3Rpb25FbmRbMV0gPSB0aGlzLl90ZXJtaW5hbC5idWZmZXIueWRpc3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuX29uTW91c2VVcCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgdGltZUVsYXBzZWQgPSBldmVudC50aW1lU3RhbXAgLSB0aGlzLl9tb3VzZURvd25UaW1lU3RhbXA7XG4gICAgICAgIHRoaXMuX3JlbW92ZU1vdXNlRG93bkxpc3RlbmVycygpO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25UZXh0Lmxlbmd0aCA8PSAxICYmIHRpbWVFbGFwc2VkIDwgQUxUX0NMSUNLX01PVkVfQ1VSU09SX1RJTUUpIHtcbiAgICAgICAgICAgIChuZXcgQWx0Q2xpY2tIYW5kbGVyXzEuQWx0Q2xpY2tIYW5kbGVyKGV2ZW50LCB0aGlzLl90ZXJtaW5hbCkpLm1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmhhc1NlbGVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuZW1pdCgnc2VsZWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLl9vbkJ1ZmZlckFjdGl2YXRlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICBlLmluYWN0aXZlQnVmZmVyLmxpbmVzLm9mZigndHJpbScsIHRoaXMuX3RyaW1MaXN0ZW5lcik7XG4gICAgICAgIGUuYWN0aXZlQnVmZmVyLmxpbmVzLm9uKCd0cmltJywgdGhpcy5fdHJpbUxpc3RlbmVyKTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLl9jb252ZXJ0Vmlld3BvcnRDb2xUb0NoYXJhY3RlckluZGV4ID0gZnVuY3Rpb24gKGJ1ZmZlckxpbmUsIGNvb3Jkcykge1xuICAgICAgICB2YXIgY2hhckluZGV4ID0gY29vcmRzWzBdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgY29vcmRzWzBdID49IGk7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoYXIgPSBidWZmZXJMaW5lLmdldChpKTtcbiAgICAgICAgICAgIGlmIChjaGFyW0J1ZmZlcl8xLkNIQVJfREFUQV9XSURUSF9JTkRFWF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICBjaGFySW5kZXgtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJbQnVmZmVyXzEuQ0hBUl9EQVRBX0NIQVJfSU5ERVhdLmxlbmd0aCA+IDEgJiYgY29vcmRzWzBdICE9PSBpKSB7XG4gICAgICAgICAgICAgICAgY2hhckluZGV4ICs9IGNoYXJbQnVmZmVyXzEuQ0hBUl9EQVRBX0NIQVJfSU5ERVhdLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYXJJbmRleDtcbiAgICB9O1xuICAgIFNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNldFNlbGVjdGlvbiA9IGZ1bmN0aW9uIChjb2wsIHJvdywgbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX21vZGVsLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZU1vdXNlRG93bkxpc3RlbmVycygpO1xuICAgICAgICB0aGlzLl9tb2RlbC5zZWxlY3Rpb25TdGFydCA9IFtjb2wsIHJvd107XG4gICAgICAgIHRoaXMuX21vZGVsLnNlbGVjdGlvblN0YXJ0TGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLl9nZXRXb3JkQXQgPSBmdW5jdGlvbiAoY29vcmRzLCBhbGxvd1doaXRlc3BhY2VPbmx5U2VsZWN0aW9uLCBmb2xsb3dXcmFwcGVkTGluZXNBYm92ZSwgZm9sbG93V3JhcHBlZExpbmVzQmVsb3cpIHtcbiAgICAgICAgaWYgKGZvbGxvd1dyYXBwZWRMaW5lc0Fib3ZlID09PSB2b2lkIDApIHsgZm9sbG93V3JhcHBlZExpbmVzQWJvdmUgPSB0cnVlOyB9XG4gICAgICAgIGlmIChmb2xsb3dXcmFwcGVkTGluZXNCZWxvdyA9PT0gdm9pZCAwKSB7IGZvbGxvd1dyYXBwZWRMaW5lc0JlbG93ID0gdHJ1ZTsgfVxuICAgICAgICBpZiAoY29vcmRzWzBdID49IHRoaXMuX3Rlcm1pbmFsLmNvbHMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWZmZXJMaW5lID0gdGhpcy5fYnVmZmVyLmxpbmVzLmdldChjb29yZHNbMV0pO1xuICAgICAgICBpZiAoIWJ1ZmZlckxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5fYnVmZmVyLnRyYW5zbGF0ZUJ1ZmZlckxpbmVUb1N0cmluZyhjb29yZHNbMV0sIGZhbHNlKTtcbiAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSB0aGlzLl9jb252ZXJ0Vmlld3BvcnRDb2xUb0NoYXJhY3RlckluZGV4KGJ1ZmZlckxpbmUsIGNvb3Jkcyk7XG4gICAgICAgIHZhciBlbmRJbmRleCA9IHN0YXJ0SW5kZXg7XG4gICAgICAgIHZhciBjaGFyT2Zmc2V0ID0gY29vcmRzWzBdIC0gc3RhcnRJbmRleDtcbiAgICAgICAgdmFyIGxlZnRXaWRlQ2hhckNvdW50ID0gMDtcbiAgICAgICAgdmFyIHJpZ2h0V2lkZUNoYXJDb3VudCA9IDA7XG4gICAgICAgIHZhciBsZWZ0TG9uZ0NoYXJPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgcmlnaHRMb25nQ2hhck9mZnNldCA9IDA7XG4gICAgICAgIGlmIChsaW5lLmNoYXJBdChzdGFydEluZGV4KSA9PT0gJyAnKSB7XG4gICAgICAgICAgICB3aGlsZSAoc3RhcnRJbmRleCA+IDAgJiYgbGluZS5jaGFyQXQoc3RhcnRJbmRleCAtIDEpID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoZW5kSW5kZXggPCBsaW5lLmxlbmd0aCAmJiBsaW5lLmNoYXJBdChlbmRJbmRleCArIDEpID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICBlbmRJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHN0YXJ0Q29sID0gY29vcmRzWzBdO1xuICAgICAgICAgICAgdmFyIGVuZENvbCA9IGNvb3Jkc1swXTtcbiAgICAgICAgICAgIGlmIChidWZmZXJMaW5lLmdldChzdGFydENvbClbQnVmZmVyXzEuQ0hBUl9EQVRBX1dJRFRIX0lOREVYXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxlZnRXaWRlQ2hhckNvdW50Kys7XG4gICAgICAgICAgICAgICAgc3RhcnRDb2wtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChidWZmZXJMaW5lLmdldChlbmRDb2wpW0J1ZmZlcl8xLkNIQVJfREFUQV9XSURUSF9JTkRFWF0gPT09IDIpIHtcbiAgICAgICAgICAgICAgICByaWdodFdpZGVDaGFyQ291bnQrKztcbiAgICAgICAgICAgICAgICBlbmRDb2wrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChidWZmZXJMaW5lLmdldChlbmRDb2wpW0J1ZmZlcl8xLkNIQVJfREFUQV9DSEFSX0lOREVYXS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgcmlnaHRMb25nQ2hhck9mZnNldCArPSBidWZmZXJMaW5lLmdldChlbmRDb2wpW0J1ZmZlcl8xLkNIQVJfREFUQV9DSEFSX0lOREVYXS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIGVuZEluZGV4ICs9IGJ1ZmZlckxpbmUuZ2V0KGVuZENvbClbQnVmZmVyXzEuQ0hBUl9EQVRBX0NIQVJfSU5ERVhdLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoc3RhcnRDb2wgPiAwICYmIHN0YXJ0SW5kZXggPiAwICYmICF0aGlzLl9pc0NoYXJXb3JkU2VwYXJhdG9yKGJ1ZmZlckxpbmUuZ2V0KHN0YXJ0Q29sIC0gMSkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYXIgPSBidWZmZXJMaW5lLmdldChzdGFydENvbCAtIDEpO1xuICAgICAgICAgICAgICAgIGlmIChjaGFyW0J1ZmZlcl8xLkNIQVJfREFUQV9XSURUSF9JTkRFWF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdFdpZGVDaGFyQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRDb2wtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhcltCdWZmZXJfMS5DSEFSX0RBVEFfQ0hBUl9JTkRFWF0ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0TG9uZ0NoYXJPZmZzZXQgKz0gY2hhcltCdWZmZXJfMS5DSEFSX0RBVEFfQ0hBUl9JTkRFWF0ubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleCAtPSBjaGFyW0J1ZmZlcl8xLkNIQVJfREFUQV9DSEFSX0lOREVYXS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFydEluZGV4LS07XG4gICAgICAgICAgICAgICAgc3RhcnRDb2wtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChlbmRDb2wgPCBidWZmZXJMaW5lLmxlbmd0aCAmJiBlbmRJbmRleCArIDEgPCBsaW5lLmxlbmd0aCAmJiAhdGhpcy5faXNDaGFyV29yZFNlcGFyYXRvcihidWZmZXJMaW5lLmdldChlbmRDb2wgKyAxKSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhciA9IGJ1ZmZlckxpbmUuZ2V0KGVuZENvbCArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChjaGFyW0J1ZmZlcl8xLkNIQVJfREFUQV9XSURUSF9JTkRFWF0gPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRXaWRlQ2hhckNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGVuZENvbCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFyW0J1ZmZlcl8xLkNIQVJfREFUQV9DSEFSX0lOREVYXS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0TG9uZ0NoYXJPZmZzZXQgKz0gY2hhcltCdWZmZXJfMS5DSEFSX0RBVEFfQ0hBUl9JTkRFWF0ubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgZW5kSW5kZXggKz0gY2hhcltCdWZmZXJfMS5DSEFSX0RBVEFfQ0hBUl9JTkRFWF0ubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW5kSW5kZXgrKztcbiAgICAgICAgICAgICAgICBlbmRDb2wrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbmRJbmRleCsrO1xuICAgICAgICB2YXIgc3RhcnQgPSBzdGFydEluZGV4XG4gICAgICAgICAgICArIGNoYXJPZmZzZXRcbiAgICAgICAgICAgIC0gbGVmdFdpZGVDaGFyQ291bnRcbiAgICAgICAgICAgICsgbGVmdExvbmdDaGFyT2Zmc2V0O1xuICAgICAgICB2YXIgbGVuZ3RoID0gTWF0aC5taW4odGhpcy5fdGVybWluYWwuY29scywgZW5kSW5kZXhcbiAgICAgICAgICAgIC0gc3RhcnRJbmRleFxuICAgICAgICAgICAgKyBsZWZ0V2lkZUNoYXJDb3VudFxuICAgICAgICAgICAgKyByaWdodFdpZGVDaGFyQ291bnRcbiAgICAgICAgICAgIC0gbGVmdExvbmdDaGFyT2Zmc2V0XG4gICAgICAgICAgICAtIHJpZ2h0TG9uZ0NoYXJPZmZzZXQpO1xuICAgICAgICBpZiAoIWFsbG93V2hpdGVzcGFjZU9ubHlTZWxlY3Rpb24gJiYgbGluZS5zbGljZShzdGFydEluZGV4LCBlbmRJbmRleCkudHJpbSgpID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvbGxvd1dyYXBwZWRMaW5lc0Fib3ZlKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPT09IDAgJiYgYnVmZmVyTGluZS5nZXQoMClbQnVmZmVyXzEuQ0hBUl9EQVRBX0NPREVfSU5ERVhdICE9PSAzMikge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0J1ZmZlckxpbmUgPSB0aGlzLl9idWZmZXIubGluZXMuZ2V0KGNvb3Jkc1sxXSAtIDEpO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c0J1ZmZlckxpbmUgJiYgYnVmZmVyTGluZS5pc1dyYXBwZWQgJiYgcHJldmlvdXNCdWZmZXJMaW5lLmdldCh0aGlzLl90ZXJtaW5hbC5jb2xzIC0gMSlbQnVmZmVyXzEuQ0hBUl9EQVRBX0NPREVfSU5ERVhdICE9PSAzMikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNMaW5lV29yZFBvc2l0aW9uID0gdGhpcy5fZ2V0V29yZEF0KFt0aGlzLl90ZXJtaW5hbC5jb2xzIC0gMSwgY29vcmRzWzFdIC0gMV0sIGZhbHNlLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c0xpbmVXb3JkUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl90ZXJtaW5hbC5jb2xzIC0gcHJldmlvdXNMaW5lV29yZFBvc2l0aW9uLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgLT0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoICs9IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9sbG93V3JhcHBlZExpbmVzQmVsb3cpIHtcbiAgICAgICAgICAgIGlmIChzdGFydCArIGxlbmd0aCA9PT0gdGhpcy5fdGVybWluYWwuY29scyAmJiBidWZmZXJMaW5lLmdldCh0aGlzLl90ZXJtaW5hbC5jb2xzIC0gMSlbQnVmZmVyXzEuQ0hBUl9EQVRBX0NPREVfSU5ERVhdICE9PSAzMikge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0QnVmZmVyTGluZSA9IHRoaXMuX2J1ZmZlci5saW5lcy5nZXQoY29vcmRzWzFdICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRCdWZmZXJMaW5lICYmIG5leHRCdWZmZXJMaW5lLmlzV3JhcHBlZCAmJiBuZXh0QnVmZmVyTGluZS5nZXQoMClbQnVmZmVyXzEuQ0hBUl9EQVRBX0NPREVfSU5ERVhdICE9PSAzMikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dExpbmVXb3JkUG9zaXRpb24gPSB0aGlzLl9nZXRXb3JkQXQoWzAsIGNvb3Jkc1sxXSArIDFdLCBmYWxzZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dExpbmVXb3JkUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCArPSBuZXh0TGluZVdvcmRQb3NpdGlvbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBsZW5ndGg6IGxlbmd0aCB9O1xuICAgIH07XG4gICAgU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuX3NlbGVjdFdvcmRBdCA9IGZ1bmN0aW9uIChjb29yZHMsIGFsbG93V2hpdGVzcGFjZU9ubHlTZWxlY3Rpb24pIHtcbiAgICAgICAgdmFyIHdvcmRQb3NpdGlvbiA9IHRoaXMuX2dldFdvcmRBdChjb29yZHMsIGFsbG93V2hpdGVzcGFjZU9ubHlTZWxlY3Rpb24pO1xuICAgICAgICBpZiAod29yZFBvc2l0aW9uKSB7XG4gICAgICAgICAgICB3aGlsZSAod29yZFBvc2l0aW9uLnN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgICAgIHdvcmRQb3NpdGlvbi5zdGFydCArPSB0aGlzLl90ZXJtaW5hbC5jb2xzO1xuICAgICAgICAgICAgICAgIGNvb3Jkc1sxXS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbW9kZWwuc2VsZWN0aW9uU3RhcnQgPSBbd29yZFBvc2l0aW9uLnN0YXJ0LCBjb29yZHNbMV1dO1xuICAgICAgICAgICAgdGhpcy5fbW9kZWwuc2VsZWN0aW9uU3RhcnRMZW5ndGggPSB3b3JkUG9zaXRpb24ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5fc2VsZWN0VG9Xb3JkQXQgPSBmdW5jdGlvbiAoY29vcmRzKSB7XG4gICAgICAgIHZhciB3b3JkUG9zaXRpb24gPSB0aGlzLl9nZXRXb3JkQXQoY29vcmRzLCB0cnVlKTtcbiAgICAgICAgaWYgKHdvcmRQb3NpdGlvbikge1xuICAgICAgICAgICAgdmFyIGVuZFJvdyA9IGNvb3Jkc1sxXTtcbiAgICAgICAgICAgIHdoaWxlICh3b3JkUG9zaXRpb24uc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgd29yZFBvc2l0aW9uLnN0YXJ0ICs9IHRoaXMuX3Rlcm1pbmFsLmNvbHM7XG4gICAgICAgICAgICAgICAgZW5kUm93LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX21vZGVsLmFyZVNlbGVjdGlvblZhbHVlc1JldmVyc2VkKCkpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAod29yZFBvc2l0aW9uLnN0YXJ0ICsgd29yZFBvc2l0aW9uLmxlbmd0aCA+IHRoaXMuX3Rlcm1pbmFsLmNvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgd29yZFBvc2l0aW9uLmxlbmd0aCAtPSB0aGlzLl90ZXJtaW5hbC5jb2xzO1xuICAgICAgICAgICAgICAgICAgICBlbmRSb3crKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tb2RlbC5zZWxlY3Rpb25FbmQgPSBbdGhpcy5fbW9kZWwuYXJlU2VsZWN0aW9uVmFsdWVzUmV2ZXJzZWQoKSA/IHdvcmRQb3NpdGlvbi5zdGFydCA6IHdvcmRQb3NpdGlvbi5zdGFydCArIHdvcmRQb3NpdGlvbi5sZW5ndGgsIGVuZFJvd107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLl9pc0NoYXJXb3JkU2VwYXJhdG9yID0gZnVuY3Rpb24gKGNoYXJEYXRhKSB7XG4gICAgICAgIGlmIChjaGFyRGF0YVtCdWZmZXJfMS5DSEFSX0RBVEFfV0lEVEhfSU5ERVhdID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFdPUkRfU0VQQVJBVE9SUy5pbmRleE9mKGNoYXJEYXRhW0J1ZmZlcl8xLkNIQVJfREFUQV9DSEFSX0lOREVYXSkgPj0gMDtcbiAgICB9O1xuICAgIFNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLl9zZWxlY3RMaW5lQXQgPSBmdW5jdGlvbiAobGluZSkge1xuICAgICAgICB2YXIgd3JhcHBlZFJhbmdlID0gdGhpcy5fYnVmZmVyLmdldFdyYXBwZWRSYW5nZUZvckxpbmUobGluZSk7XG4gICAgICAgIHRoaXMuX21vZGVsLnNlbGVjdGlvblN0YXJ0ID0gWzAsIHdyYXBwZWRSYW5nZS5maXJzdF07XG4gICAgICAgIHRoaXMuX21vZGVsLnNlbGVjdGlvbkVuZCA9IFt0aGlzLl90ZXJtaW5hbC5jb2xzLCB3cmFwcGVkUmFuZ2UubGFzdF07XG4gICAgICAgIHRoaXMuX21vZGVsLnNlbGVjdGlvblN0YXJ0TGVuZ3RoID0gMDtcbiAgICB9O1xuICAgIHJldHVybiBTZWxlY3Rpb25NYW5hZ2VyO1xufShFdmVudEVtaXR0ZXJfMS5FdmVudEVtaXR0ZXIpKTtcbmV4cG9ydHMuU2VsZWN0aW9uTWFuYWdlciA9IFNlbGVjdGlvbk1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZWxlY3Rpb25NYW5hZ2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFNlbGVjdGlvbk1vZGVsID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZWxlY3Rpb25Nb2RlbChfdGVybWluYWwpIHtcbiAgICAgICAgdGhpcy5fdGVybWluYWwgPSBfdGVybWluYWw7XG4gICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICB9XG4gICAgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLmNsZWFyU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBudWxsO1xuICAgICAgICB0aGlzLmlzU2VsZWN0QWxsQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnRMZW5ndGggPSAwO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZSwgXCJmaW5hbFNlbGVjdGlvblN0YXJ0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1NlbGVjdEFsbEFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMCwgMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uRW5kIHx8ICF0aGlzLnNlbGVjdGlvblN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcmVTZWxlY3Rpb25WYWx1ZXNSZXZlcnNlZCgpID8gdGhpcy5zZWxlY3Rpb25FbmQgOiB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLCBcImZpbmFsU2VsZWN0aW9uRW5kXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1NlbGVjdEFsbEFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbdGhpcy5fdGVybWluYWwuY29scywgdGhpcy5fdGVybWluYWwuYnVmZmVyLnliYXNlICsgdGhpcy5fdGVybWluYWwucm93cyAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvblN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uRW5kIHx8IHRoaXMuYXJlU2VsZWN0aW9uVmFsdWVzUmV2ZXJzZWQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydFBsdXNMZW5ndGggPSB0aGlzLnNlbGVjdGlvblN0YXJ0WzBdICsgdGhpcy5zZWxlY3Rpb25TdGFydExlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRQbHVzTGVuZ3RoID4gdGhpcy5fdGVybWluYWwuY29scykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3N0YXJ0UGx1c0xlbmd0aCAlIHRoaXMuX3Rlcm1pbmFsLmNvbHMsIHRoaXMuc2VsZWN0aW9uU3RhcnRbMV0gKyBNYXRoLmZsb29yKHN0YXJ0UGx1c0xlbmd0aCAvIHRoaXMuX3Rlcm1pbmFsLmNvbHMpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzdGFydFBsdXNMZW5ndGgsIHRoaXMuc2VsZWN0aW9uU3RhcnRbMV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25FbmRbMV0gPT09IHRoaXMuc2VsZWN0aW9uU3RhcnRbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtNYXRoLm1heCh0aGlzLnNlbGVjdGlvblN0YXJ0WzBdICsgdGhpcy5zZWxlY3Rpb25TdGFydExlbmd0aCwgdGhpcy5zZWxlY3Rpb25FbmRbMF0pLCB0aGlzLnNlbGVjdGlvbkVuZFsxXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uRW5kO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUuYXJlU2VsZWN0aW9uVmFsdWVzUmV2ZXJzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnNlbGVjdGlvbkVuZDtcbiAgICAgICAgaWYgKCFzdGFydCB8fCAhZW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXJ0WzFdID4gZW5kWzFdIHx8IChzdGFydFsxXSA9PT0gZW5kWzFdICYmIHN0YXJ0WzBdID4gZW5kWzBdKTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5vblRyaW0gPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0KSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0WzFdIC09IGFtb3VudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kWzFdIC09IGFtb3VudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25FbmQgJiYgdGhpcy5zZWxlY3Rpb25FbmRbMV0gPCAwKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCAmJiB0aGlzLnNlbGVjdGlvblN0YXJ0WzFdIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydFsxXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgcmV0dXJuIFNlbGVjdGlvbk1vZGVsO1xufSgpKTtcbmV4cG9ydHMuU2VsZWN0aW9uTW9kZWwgPSBTZWxlY3Rpb25Nb2RlbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNlbGVjdGlvbk1vZGVsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ERUZBVUxUX0JFTExfU09VTkQgPSAnZGF0YTphdWRpby93YXY7YmFzZTY0LFVrbEdSaWdCQUFCWFFWWkZabTEwSUJBQUFBQUJBQUVBUkt3QUFJaFlBUUFDQUJBQVpHRjBZUVFCQUFEcEFGZ0N3QU1sQlpvRy93ZG1DY29LUkF5cERROFBiUkRCRVFRVE94UnRGWWNXbEJlUEdJVVpYaG9pRzg4YmNCejdISElkemgwV0hsTWVaeDUxSG1rZVV4NFdIczhkYWgwQUhYd2MzaHM5RzRzYXhSbnlHQklZR0JjUUZ2OFU0UlBBRW9ZUlFCQUNENzBOV3d3SEM2Z0pPd2pXQmxvRjdnT0JBaEFCa2Y4Yi9xdjhSL3ZlK1hmNElmZTc5Vy8wSmZQWjhaL3dkZTlON2lqdEUrd1U2eHZxTStsYjZIN253K1lYNW1ybHh1UXo1TXpqZStNYTQ5ZmlvZUtENG5YaVllSnk0cEhpdE9MMDRqL2puK01ONUlQa0ZPV3M1VTNtRGVmTTU1L29nT2wzNm03cmRPeUU3YWJ1eXU4RDhVbnlqL1BnOUQvMnFmY2IrWW42L3Z1Sy9Rai9sQUFsQWc9PSc7XG52YXIgU291bmRNYW5hZ2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTb3VuZE1hbmFnZXIoX3Rlcm1pbmFsKSB7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsID0gX3Rlcm1pbmFsO1xuICAgIH1cbiAgICBTb3VuZE1hbmFnZXIucHJvdG90eXBlLnBsYXlCZWxsU291bmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhdWRpb0NvbnRleHRDdG9yID0gd2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0O1xuICAgICAgICBpZiAoIXRoaXMuX2F1ZGlvQ29udGV4dCAmJiBhdWRpb0NvbnRleHRDdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9hdWRpb0NvbnRleHQgPSBuZXcgYXVkaW9Db250ZXh0Q3RvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9hdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBiZWxsQXVkaW9Tb3VyY2VfMSA9IHRoaXMuX2F1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgICAgICAgICAgIHZhciBjb250ZXh0XzEgPSB0aGlzLl9hdWRpb0NvbnRleHQ7XG4gICAgICAgICAgICB0aGlzLl9hdWRpb0NvbnRleHQuZGVjb2RlQXVkaW9EYXRhKHRoaXMuX2Jhc2U2NFRvQXJyYXlCdWZmZXIodGhpcy5fcmVtb3ZlTWltZVR5cGUodGhpcy5fdGVybWluYWwub3B0aW9ucy5iZWxsU291bmQpKSwgZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIGJlbGxBdWRpb1NvdXJjZV8xLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICBiZWxsQXVkaW9Tb3VyY2VfMS5jb25uZWN0KGNvbnRleHRfMS5kZXN0aW5hdGlvbik7XG4gICAgICAgICAgICAgICAgYmVsbEF1ZGlvU291cmNlXzEuc3RhcnQoMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignU29ycnksIGJ1dCB0aGUgV2ViIEF1ZGlvIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHlvdXIgYnJvd3Nlci4gUGxlYXNlLCBjb25zaWRlciB1cGdyYWRpbmcgdG8gdGhlIGxhdGVzdCB2ZXJzaW9uJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNvdW5kTWFuYWdlci5wcm90b3R5cGUuX2Jhc2U2NFRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoYmFzZTY0KSB7XG4gICAgICAgIHZhciBiaW5hcnlTdHJpbmcgPSB3aW5kb3cuYXRvYihiYXNlNjQpO1xuICAgICAgICB2YXIgbGVuID0gYmluYXJ5U3RyaW5nLmxlbmd0aDtcbiAgICAgICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgYnl0ZXNbaV0gPSBiaW5hcnlTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZXMuYnVmZmVyO1xuICAgIH07XG4gICAgU291bmRNYW5hZ2VyLnByb3RvdHlwZS5fcmVtb3ZlTWltZVR5cGUgPSBmdW5jdGlvbiAoZGF0YVVSSSkge1xuICAgICAgICB2YXIgc3BsaXRVcmkgPSBkYXRhVVJJLnNwbGl0KCcsJyk7XG4gICAgICAgIHJldHVybiBzcGxpdFVyaVsxXTtcbiAgICB9O1xuICAgIHJldHVybiBTb3VuZE1hbmFnZXI7XG59KCkpO1xuZXhwb3J0cy5Tb3VuZE1hbmFnZXIgPSBTb3VuZE1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Tb3VuZE1hbmFnZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJsYW5rTGluZSA9ICdCbGFuayBsaW5lJztcbmV4cG9ydHMucHJvbXB0TGFiZWwgPSAnVGVybWluYWwgaW5wdXQnO1xuZXhwb3J0cy50b29NdWNoT3V0cHV0ID0gJ1RvbyBtdWNoIG91dHB1dCB0byBhbm5vdW5jZSwgbmF2aWdhdGUgdG8gcm93cyBtYW51YWxseSB0byByZWFkJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0cmluZ3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEJ1ZmZlclNldF8xID0gcmVxdWlyZShcIi4vQnVmZmVyU2V0XCIpO1xudmFyIEJ1ZmZlcl8xID0gcmVxdWlyZShcIi4vQnVmZmVyXCIpO1xudmFyIENvbXBvc2l0aW9uSGVscGVyXzEgPSByZXF1aXJlKFwiLi9Db21wb3NpdGlvbkhlbHBlclwiKTtcbnZhciBFdmVudEVtaXR0ZXJfMSA9IHJlcXVpcmUoXCIuL2NvbW1vbi9FdmVudEVtaXR0ZXJcIik7XG52YXIgVmlld3BvcnRfMSA9IHJlcXVpcmUoXCIuL1ZpZXdwb3J0XCIpO1xudmFyIENsaXBib2FyZF8xID0gcmVxdWlyZShcIi4vaGFuZGxlcnMvQ2xpcGJvYXJkXCIpO1xudmFyIEVzY2FwZVNlcXVlbmNlc18xID0gcmVxdWlyZShcIi4vY29tbW9uL2RhdGEvRXNjYXBlU2VxdWVuY2VzXCIpO1xudmFyIElucHV0SGFuZGxlcl8xID0gcmVxdWlyZShcIi4vSW5wdXRIYW5kbGVyXCIpO1xudmFyIFJlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi9yZW5kZXJlci9SZW5kZXJlclwiKTtcbnZhciBMaW5raWZpZXJfMSA9IHJlcXVpcmUoXCIuL0xpbmtpZmllclwiKTtcbnZhciBTZWxlY3Rpb25NYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi9TZWxlY3Rpb25NYW5hZ2VyXCIpO1xudmFyIENoYXJNZWFzdXJlXzEgPSByZXF1aXJlKFwiLi91aS9DaGFyTWVhc3VyZVwiKTtcbnZhciBCcm93c2VyID0gcmVxdWlyZShcIi4vc2hhcmVkL3V0aWxzL0Jyb3dzZXJcIik7XG52YXIgTGlmZWN5Y2xlXzEgPSByZXF1aXJlKFwiLi91aS9MaWZlY3ljbGVcIik7XG52YXIgU3RyaW5ncyA9IHJlcXVpcmUoXCIuL1N0cmluZ3NcIik7XG52YXIgTW91c2VIZWxwZXJfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL01vdXNlSGVscGVyXCIpO1xudmFyIENsb25lXzEgPSByZXF1aXJlKFwiLi91dGlscy9DbG9uZVwiKTtcbnZhciBTb3VuZE1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL1NvdW5kTWFuYWdlclwiKTtcbnZhciBDb2xvck1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL3JlbmRlcmVyL0NvbG9yTWFuYWdlclwiKTtcbnZhciBNb3VzZVpvbmVNYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi91aS9Nb3VzZVpvbmVNYW5hZ2VyXCIpO1xudmFyIEFjY2Vzc2liaWxpdHlNYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi9BY2Nlc3NpYmlsaXR5TWFuYWdlclwiKTtcbnZhciBTY3JlZW5EcHJNb25pdG9yXzEgPSByZXF1aXJlKFwiLi91aS9TY3JlZW5EcHJNb25pdG9yXCIpO1xudmFyIENoYXJBdGxhc0NhY2hlXzEgPSByZXF1aXJlKFwiLi9yZW5kZXJlci9hdGxhcy9DaGFyQXRsYXNDYWNoZVwiKTtcbnZhciBEb21SZW5kZXJlcl8xID0gcmVxdWlyZShcIi4vcmVuZGVyZXIvZG9tL0RvbVJlbmRlcmVyXCIpO1xudmFyIEtleWJvYXJkXzEgPSByZXF1aXJlKFwiLi9jb3JlL2lucHV0L0tleWJvYXJkXCIpO1xudmFyIEJ1ZmZlckxpbmVfMSA9IHJlcXVpcmUoXCIuL0J1ZmZlckxpbmVcIik7XG52YXIgZG9jdW1lbnQgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpID8gd2luZG93LmRvY3VtZW50IDogbnVsbDtcbnZhciBXUklURV9CVUZGRVJfUEFVU0VfVEhSRVNIT0xEID0gNTtcbnZhciBXUklURV9CQVRDSF9TSVpFID0gMzAwO1xudmFyIENPTlNUUlVDVE9SX09OTFlfT1BUSU9OUyA9IFsnY29scycsICdyb3dzJ107XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIGNvbHM6IDgwLFxuICAgIHJvd3M6IDI0LFxuICAgIGNvbnZlcnRFb2w6IGZhbHNlLFxuICAgIHRlcm1OYW1lOiAneHRlcm0nLFxuICAgIGN1cnNvckJsaW5rOiBmYWxzZSxcbiAgICBjdXJzb3JTdHlsZTogJ2Jsb2NrJyxcbiAgICBiZWxsU291bmQ6IFNvdW5kTWFuYWdlcl8xLkRFRkFVTFRfQkVMTF9TT1VORCxcbiAgICBiZWxsU3R5bGU6ICdub25lJyxcbiAgICBkcmF3Qm9sZFRleHRJbkJyaWdodENvbG9yczogdHJ1ZSxcbiAgICBlbmFibGVCb2xkOiB0cnVlLFxuICAgIGV4cGVyaW1lbnRhbENoYXJBdGxhczogJ3N0YXRpYycsXG4gICAgZm9udEZhbWlseTogJ2NvdXJpZXItbmV3LCBjb3VyaWVyLCBtb25vc3BhY2UnLFxuICAgIGZvbnRTaXplOiAxNSxcbiAgICBmb250V2VpZ2h0OiAnbm9ybWFsJyxcbiAgICBmb250V2VpZ2h0Qm9sZDogJ2JvbGQnLFxuICAgIGxpbmVIZWlnaHQ6IDEuMCxcbiAgICBsZXR0ZXJTcGFjaW5nOiAwLFxuICAgIHNjcm9sbGJhY2s6IDEwMDAsXG4gICAgc2NyZWVuS2V5czogZmFsc2UsXG4gICAgc2NyZWVuUmVhZGVyTW9kZTogZmFsc2UsXG4gICAgZGVidWc6IGZhbHNlLFxuICAgIG1hY09wdGlvbklzTWV0YTogZmFsc2UsXG4gICAgbWFjT3B0aW9uQ2xpY2tGb3JjZXNTZWxlY3Rpb246IGZhbHNlLFxuICAgIGNhbmNlbEV2ZW50czogZmFsc2UsXG4gICAgZGlzYWJsZVN0ZGluOiBmYWxzZSxcbiAgICB1c2VGbG93Q29udHJvbDogZmFsc2UsXG4gICAgYWxsb3dUcmFuc3BhcmVuY3k6IGZhbHNlLFxuICAgIHRhYlN0b3BXaWR0aDogOCxcbiAgICB0aGVtZTogbnVsbCxcbiAgICByaWdodENsaWNrU2VsZWN0c1dvcmQ6IEJyb3dzZXIuaXNNYWMsXG4gICAgcmVuZGVyZXJUeXBlOiAnY2FudmFzJ1xufTtcbnZhciBUZXJtaW5hbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRlcm1pbmFsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRlcm1pbmFsKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYnJvd3NlciA9IEJyb3dzZXI7XG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSBDbG9uZV8xLmNsb25lKG9wdGlvbnMpO1xuICAgICAgICBfdGhpcy5fc2V0dXAoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUZXJtaW5hbC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX2N1c3RvbUtleUV2ZW50SGFuZGxlciA9IG51bGw7XG4gICAgICAgIENoYXJBdGxhc0NhY2hlXzEucmVtb3ZlVGVybWluYWxGcm9tQ2FjaGUodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgdGhpcy53cml0ZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudCAmJiB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLl9zZXR1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgT2JqZWN0LmtleXMoREVGQVVMVF9PUFRJT05TKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zW2tleV0gPT09IG51bGwgfHwgX3RoaXMub3B0aW9uc1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vcHRpb25zW2tleV0gPSBERUZBVUxUX09QVElPTlNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IGRvY3VtZW50ID8gZG9jdW1lbnQuYm9keSA6IG51bGw7XG4gICAgICAgIHRoaXMuY29scyA9IHRoaXMub3B0aW9ucy5jb2xzO1xuICAgICAgICB0aGlzLnJvd3MgPSB0aGlzLm9wdGlvbnMucm93cztcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLm9uKCdkYXRhJywgdGhpcy5vcHRpb25zLmhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3Vyc29yU3RhdGUgPSAwO1xuICAgICAgICB0aGlzLmN1cnNvckhpZGRlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jdXN0b21LZXlFdmVudEhhbmRsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uS2V5cGFkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYXBwbGljYXRpb25DdXJzb3IgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcmlnaW5Nb2RlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5zZXJ0TW9kZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLndyYXBhcm91bmRNb2RlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5icmFja2V0ZWRQYXN0ZU1vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jaGFyc2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5nY2hhcnNldCA9IG51bGw7XG4gICAgICAgIHRoaXMuZ2xldmVsID0gMDtcbiAgICAgICAgdGhpcy5jaGFyc2V0cyA9IFtudWxsXTtcbiAgICAgICAgdGhpcy5jdXJBdHRyID0gQnVmZmVyXzEuREVGQVVMVF9BVFRSO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnRQYXJhbSA9IDA7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5fd3JpdGVJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3hvZmZTZW50VG9DYXRjaFVwID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3VzZXJTY3JvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faW5wdXRIYW5kbGVyID0gbmV3IElucHV0SGFuZGxlcl8xLklucHV0SGFuZGxlcih0aGlzKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih0aGlzLl9pbnB1dEhhbmRsZXIpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gdGhpcy5yZW5kZXJlciB8fCBudWxsO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1hbmFnZXIgPSB0aGlzLnNlbGVjdGlvbk1hbmFnZXIgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5saW5raWZpZXIgPSB0aGlzLmxpbmtpZmllciB8fCBuZXcgTGlua2lmaWVyXzEuTGlua2lmaWVyKHRoaXMpO1xuICAgICAgICB0aGlzLl9tb3VzZVpvbmVNYW5hZ2VyID0gdGhpcy5fbW91c2Vab25lTWFuYWdlciB8fCBudWxsO1xuICAgICAgICB0aGlzLnNvdW5kTWFuYWdlciA9IHRoaXMuc291bmRNYW5hZ2VyIHx8IG5ldyBTb3VuZE1hbmFnZXJfMS5Tb3VuZE1hbmFnZXIodGhpcyk7XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IG5ldyBCdWZmZXJTZXRfMS5CdWZmZXJTZXQodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1hbmFnZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uTWFuYWdlci5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25NYW5hZ2VyLmluaXRCdWZmZXJzTGlzdGVuZXJzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXJtaW5hbC5wcm90b3R5cGUsIFwiYnVmZmVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJzLmFjdGl2ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVGVybWluYWwucHJvdG90eXBlLmVyYXNlQXR0ciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChCdWZmZXJfMS5ERUZBVUxUX0FUVFIgJiB+MHgxZmYpIHwgKHRoaXMuY3VyQXR0ciAmIDB4MWZmKTtcbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudGV4dGFyZWEpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dGFyZWEuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRlcm1pbmFsLnByb3RvdHlwZSwgXCJpc0ZvY3VzZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLnRleHRhcmVhO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBUZXJtaW5hbC5wcm90b3R5cGUuZ2V0T3B0aW9uID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gREVGQVVMVF9PUFRJT05TKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBvcHRpb24gd2l0aCBrZXkgXCInICsga2V5ICsgJ1wiJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1trZXldO1xuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLnNldE9wdGlvbiA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBERUZBVUxUX09QVElPTlMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG9wdGlvbiB3aXRoIGtleSBcIicgKyBrZXkgKyAnXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQ09OU1RSVUNUT1JfT05MWV9PUFRJT05TLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJPcHRpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIGNhbiBvbmx5IGJlIHNldCBpbiB0aGUgY29uc3RydWN0b3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1trZXldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICBjYXNlICdiZWxsU3R5bGUnOlxuICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY3Vyc29yU3R5bGUnOlxuICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnYmxvY2snO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2ZvbnRXZWlnaHQnOlxuICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnbm9ybWFsJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdmb250V2VpZ2h0Qm9sZCc6XG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICdib2xkJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsaW5lSGVpZ2h0JzpcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihrZXkgKyBcIiBjYW5ub3QgYmUgbGVzcyB0aGFuIDEsIHZhbHVlOiBcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3JlbmRlcmVyVHlwZSc6XG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICdjYW52YXMnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RhYlN0b3BXaWR0aCc6XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oa2V5ICsgXCIgY2Fubm90IGJlIGxlc3MgdGhhbiAxLCB2YWx1ZTogXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0aGVtZSc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0VGhlbWUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2Nyb2xsYmFjayc6XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLm1pbih2YWx1ZSwgQnVmZmVyXzEuTUFYX0JVRkZFUl9TSVpFKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihrZXkgKyBcIiBjYW5ub3QgYmUgbGVzcyB0aGFuIDAsIHZhbHVlOiBcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zW2tleV0gIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdCdWZmZXJMZW5ndGggPSB0aGlzLnJvd3MgKyB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYnVmZmVyLmxpbmVzLmxlbmd0aCA+IG5ld0J1ZmZlckxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFtb3VudFRvVHJpbSA9IHRoaXMuYnVmZmVyLmxpbmVzLmxlbmd0aCAtIG5ld0J1ZmZlckxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZWVkc1JlZnJlc2ggPSAodGhpcy5idWZmZXIueWRpc3AgLSBhbW91bnRUb1RyaW0gPCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLmxpbmVzLnRyaW1TdGFydChhbW91bnRUb1RyaW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXIueWJhc2UgPSBNYXRoLm1heCh0aGlzLmJ1ZmZlci55YmFzZSAtIGFtb3VudFRvVHJpbSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci55ZGlzcCA9IE1hdGgubWF4KHRoaXMuYnVmZmVyLnlkaXNwIC0gYW1vdW50VG9UcmltLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZWVkc1JlZnJlc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2goMCwgdGhpcy5yb3dzIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ2ZvbnRGYW1pbHknOlxuICAgICAgICAgICAgY2FzZSAnZm9udFNpemUnOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFyTWVhc3VyZS5tZWFzdXJlKHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZHJhd0JvbGRUZXh0SW5CcmlnaHRDb2xvcnMnOlxuICAgICAgICAgICAgY2FzZSAnZXhwZXJpbWVudGFsQ2hhckF0bGFzJzpcbiAgICAgICAgICAgIGNhc2UgJ2VuYWJsZUJvbGQnOlxuICAgICAgICAgICAgY2FzZSAnbGV0dGVyU3BhY2luZyc6XG4gICAgICAgICAgICBjYXNlICdsaW5lSGVpZ2h0JzpcbiAgICAgICAgICAgIGNhc2UgJ2ZvbnRXZWlnaHQnOlxuICAgICAgICAgICAgY2FzZSAnZm9udFdlaWdodEJvbGQnOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5vblJlc2l6ZSh0aGlzLmNvbHMsIHRoaXMucm93cyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaCgwLCB0aGlzLnJvd3MgLSAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdyZW5kZXJlclR5cGUnOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5yZWdpc3Rlcih0aGlzLnJlbmRlcmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9zZXR1cFJlbmRlcmVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5vbkNoYXJTaXplQ2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl90aGVtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFRoZW1lKHRoaXMuX3RoZW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzY3JvbGxiYWNrJzpcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcnMucmVzaXplKHRoaXMuY29scywgdGhpcy5yb3dzKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3cG9ydCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0LnN5bmNTY3JvbGxBcmVhKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2NyZWVuUmVhZGVyTW9kZSc6XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYWNjZXNzaWJpbGl0eU1hbmFnZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjY2Vzc2liaWxpdHlNYW5hZ2VyID0gbmV3IEFjY2Vzc2liaWxpdHlNYW5hZ2VyXzEuQWNjZXNzaWJpbGl0eU1hbmFnZXIodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hY2Nlc3NpYmlsaXR5TWFuYWdlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWNjZXNzaWJpbGl0eU1hbmFnZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWNjZXNzaWJpbGl0eU1hbmFnZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndGFiU3RvcFdpZHRoJzpcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcnMuc2V0dXBUYWJTdG9wcygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLm9uT3B0aW9uc0NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLl9vblRleHRBcmVhRm9jdXMgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VuZEZvY3VzKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIoRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgJ1tJJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVDdXJzb3JTdHlsZShldik7XG4gICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdmb2N1cycpO1xuICAgICAgICB0aGlzLnNob3dDdXJzb3IoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdmb2N1cycpO1xuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLmJsdXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHRhcmVhLmJsdXIoKTtcbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5fb25UZXh0QXJlYUJsdXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGV4dGFyZWEudmFsdWUgPSAnJztcbiAgICAgICAgdGhpcy5yZWZyZXNoKHRoaXMuYnVmZmVyLnksIHRoaXMuYnVmZmVyLnkpO1xuICAgICAgICBpZiAodGhpcy5zZW5kRm9jdXMpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlcihFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnW08nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnZm9jdXMnKTtcbiAgICAgICAgdGhpcy5lbWl0KCdibHVyJyk7XG4gICAgfTtcbiAgICBUZXJtaW5hbC5wcm90b3R5cGUuX2luaXRHbG9iYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2JpbmRLZXlzKCk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoTGlmZWN5Y2xlXzEuYWRkRGlzcG9zYWJsZURvbUxpc3RlbmVyKHRoaXMuZWxlbWVudCwgJ2NvcHknLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuaGFzU2VsZWN0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBDbGlwYm9hcmRfMS5jb3B5SGFuZGxlcihldmVudCwgX3RoaXMsIF90aGlzLnNlbGVjdGlvbk1hbmFnZXIpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHZhciBwYXN0ZUhhbmRsZXJXcmFwcGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBDbGlwYm9hcmRfMS5wYXN0ZUhhbmRsZXIoZXZlbnQsIF90aGlzKTsgfTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihMaWZlY3ljbGVfMS5hZGREaXNwb3NhYmxlRG9tTGlzdGVuZXIodGhpcy50ZXh0YXJlYSwgJ3Bhc3RlJywgcGFzdGVIYW5kbGVyV3JhcHBlcikpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKExpZmVjeWNsZV8xLmFkZERpc3Bvc2FibGVEb21MaXN0ZW5lcih0aGlzLmVsZW1lbnQsICdwYXN0ZScsIHBhc3RlSGFuZGxlcldyYXBwZXIpKTtcbiAgICAgICAgaWYgKEJyb3dzZXIuaXNGaXJlZm94KSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyKExpZmVjeWNsZV8xLmFkZERpc3Bvc2FibGVEb21MaXN0ZW5lcih0aGlzLmVsZW1lbnQsICdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuYnV0dG9uID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIENsaXBib2FyZF8xLnJpZ2h0Q2xpY2tIYW5kbGVyKGV2ZW50LCBfdGhpcy50ZXh0YXJlYSwgX3RoaXMuc2VsZWN0aW9uTWFuYWdlciwgX3RoaXMub3B0aW9ucy5yaWdodENsaWNrU2VsZWN0c1dvcmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIoTGlmZWN5Y2xlXzEuYWRkRGlzcG9zYWJsZURvbUxpc3RlbmVyKHRoaXMuZWxlbWVudCwgJ2NvbnRleHRtZW51JywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgQ2xpcGJvYXJkXzEucmlnaHRDbGlja0hhbmRsZXIoZXZlbnQsIF90aGlzLnRleHRhcmVhLCBfdGhpcy5zZWxlY3Rpb25NYW5hZ2VyLCBfdGhpcy5vcHRpb25zLnJpZ2h0Q2xpY2tTZWxlY3RzV29yZCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJyb3dzZXIuaXNMaW51eCkge1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcihMaWZlY3ljbGVfMS5hZGREaXNwb3NhYmxlRG9tTGlzdGVuZXIodGhpcy5lbGVtZW50LCAnYXV4Y2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuYnV0dG9uID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIENsaXBib2FyZF8xLm1vdmVUZXh0QXJlYVVuZGVyTW91c2VDdXJzb3IoZXZlbnQsIF90aGlzLnRleHRhcmVhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5fYmluZEtleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5yZWdpc3RlcihMaWZlY3ljbGVfMS5hZGREaXNwb3NhYmxlRG9tTGlzdGVuZXIodGhpcy5lbGVtZW50LCAna2V5ZG93bicsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLl9rZXlEb3duKGV2KTtcbiAgICAgICAgfSwgdHJ1ZSkpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKExpZmVjeWNsZV8xLmFkZERpc3Bvc2FibGVEb21MaXN0ZW5lcih0aGlzLmVsZW1lbnQsICdrZXlwcmVzcycsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLl9rZXlQcmVzcyhldik7XG4gICAgICAgIH0sIHRydWUpKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihMaWZlY3ljbGVfMS5hZGREaXNwb3NhYmxlRG9tTGlzdGVuZXIodGhpcy5lbGVtZW50LCAna2V5dXAnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGlmICghd2FzTW9kaWZpZXJLZXlPbmx5RXZlbnQoZXYpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuX2tleVVwKGV2KTtcbiAgICAgICAgfSwgdHJ1ZSkpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKExpZmVjeWNsZV8xLmFkZERpc3Bvc2FibGVEb21MaXN0ZW5lcih0aGlzLnRleHRhcmVhLCAna2V5ZG93bicsIGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMuX2tleURvd24oZXYpOyB9LCB0cnVlKSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoTGlmZWN5Y2xlXzEuYWRkRGlzcG9zYWJsZURvbUxpc3RlbmVyKHRoaXMudGV4dGFyZWEsICdrZXlwcmVzcycsIGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMuX2tleVByZXNzKGV2KTsgfSwgdHJ1ZSkpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKExpZmVjeWNsZV8xLmFkZERpc3Bvc2FibGVEb21MaXN0ZW5lcih0aGlzLnRleHRhcmVhLCAnY29tcG9zaXRpb25zdGFydCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9jb21wb3NpdGlvbkhlbHBlci5jb21wb3NpdGlvbnN0YXJ0KCk7IH0pKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihMaWZlY3ljbGVfMS5hZGREaXNwb3NhYmxlRG9tTGlzdGVuZXIodGhpcy50ZXh0YXJlYSwgJ2NvbXBvc2l0aW9udXBkYXRlJywgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLl9jb21wb3NpdGlvbkhlbHBlci5jb21wb3NpdGlvbnVwZGF0ZShlKTsgfSkpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKExpZmVjeWNsZV8xLmFkZERpc3Bvc2FibGVEb21MaXN0ZW5lcih0aGlzLnRleHRhcmVhLCAnY29tcG9zaXRpb25lbmQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fY29tcG9zaXRpb25IZWxwZXIuY29tcG9zaXRpb25lbmQoKTsgfSkpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHRoaXMuYWRkRGlzcG9zYWJsZUxpc3RlbmVyKCdyZWZyZXNoJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2NvbXBvc2l0aW9uSGVscGVyLnVwZGF0ZUNvbXBvc2l0aW9uRWxlbWVudHMoKTsgfSkpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHRoaXMuYWRkRGlzcG9zYWJsZUxpc3RlbmVyKCdyZWZyZXNoJywgZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIF90aGlzLl9xdWV1ZUxpbmtpZmljYXRpb24oZGF0YS5zdGFydCwgZGF0YS5lbmQpOyB9KSk7XG4gICAgfTtcbiAgICBUZXJtaW5hbC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50IHx8IHRoaXMuX3BhcmVudDtcbiAgICAgICAgaWYgKCF0aGlzLl9wYXJlbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGVybWluYWwgcmVxdWlyZXMgYSBwYXJlbnQgZWxlbWVudC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb250ZXh0ID0gdGhpcy5fcGFyZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgICAgIHRoaXMuX2RvY3VtZW50ID0gdGhpcy5fcGFyZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIHRoaXMuX3NjcmVlbkRwck1vbml0b3IgPSBuZXcgU2NyZWVuRHByTW9uaXRvcl8xLlNjcmVlbkRwck1vbml0b3IoKTtcbiAgICAgICAgdGhpcy5fc2NyZWVuRHByTW9uaXRvci5zZXRMaXN0ZW5lcihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5lbWl0KCdkcHJjaGFuZ2UnLCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7IH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHRoaXMuX3NjcmVlbkRwck1vbml0b3IpO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmRpciA9ICdsdHInO1xuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZCgndGVybWluYWwnKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3h0ZXJtJyk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJzAnKTtcbiAgICAgICAgdGhpcy5fcGFyZW50LmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudCk7XG4gICAgICAgIHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgdGhpcy5fdmlld3BvcnRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0RWxlbWVudC5jbGFzc0xpc3QuYWRkKCd4dGVybS12aWV3cG9ydCcpO1xuICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZCh0aGlzLl92aWV3cG9ydEVsZW1lbnQpO1xuICAgICAgICB0aGlzLl92aWV3cG9ydFNjcm9sbEFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5fdmlld3BvcnRTY3JvbGxBcmVhLmNsYXNzTGlzdC5hZGQoJ3h0ZXJtLXNjcm9sbC1hcmVhJyk7XG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl92aWV3cG9ydFNjcm9sbEFyZWEpO1xuICAgICAgICB0aGlzLnNjcmVlbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5zY3JlZW5FbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3h0ZXJtLXNjcmVlbicpO1xuICAgICAgICB0aGlzLl9oZWxwZXJDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5faGVscGVyQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3h0ZXJtLWhlbHBlcnMnKTtcbiAgICAgICAgdGhpcy5zY3JlZW5FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX2hlbHBlckNvbnRhaW5lcik7XG4gICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKHRoaXMuc2NyZWVuRWxlbWVudCk7XG4gICAgICAgIHRoaXMuX21vdXNlWm9uZU1hbmFnZXIgPSBuZXcgTW91c2Vab25lTWFuYWdlcl8xLk1vdXNlWm9uZU1hbmFnZXIodGhpcyk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodGhpcy5fbW91c2Vab25lTWFuYWdlcik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodGhpcy5hZGREaXNwb3NhYmxlTGlzdGVuZXIoJ3Njcm9sbCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9tb3VzZVpvbmVNYW5hZ2VyLmNsZWFyQWxsKCk7IH0pKTtcbiAgICAgICAgdGhpcy5saW5raWZpZXIuYXR0YWNoVG9Eb20odGhpcy5fbW91c2Vab25lTWFuYWdlcik7XG4gICAgICAgIHRoaXMudGV4dGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgICAgICB0aGlzLnRleHRhcmVhLmNsYXNzTGlzdC5hZGQoJ3h0ZXJtLWhlbHBlci10ZXh0YXJlYScpO1xuICAgICAgICB0aGlzLnRleHRhcmVhLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIFN0cmluZ3MucHJvbXB0TGFiZWwpO1xuICAgICAgICB0aGlzLnRleHRhcmVhLnNldEF0dHJpYnV0ZSgnYXJpYS1tdWx0aWxpbmUnLCAnZmFsc2UnKTtcbiAgICAgICAgdGhpcy50ZXh0YXJlYS5zZXRBdHRyaWJ1dGUoJ2F1dG9jb3JyZWN0JywgJ29mZicpO1xuICAgICAgICB0aGlzLnRleHRhcmVhLnNldEF0dHJpYnV0ZSgnYXV0b2NhcGl0YWxpemUnLCAnb2ZmJyk7XG4gICAgICAgIHRoaXMudGV4dGFyZWEuc2V0QXR0cmlidXRlKCdzcGVsbGNoZWNrJywgJ2ZhbHNlJyk7XG4gICAgICAgIHRoaXMudGV4dGFyZWEudGFiSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKExpZmVjeWNsZV8xLmFkZERpc3Bvc2FibGVEb21MaXN0ZW5lcih0aGlzLnRleHRhcmVhLCAnZm9jdXMnLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLl9vblRleHRBcmVhRm9jdXMoZXYpOyB9KSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoTGlmZWN5Y2xlXzEuYWRkRGlzcG9zYWJsZURvbUxpc3RlbmVyKHRoaXMudGV4dGFyZWEsICdibHVyJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX29uVGV4dEFyZWFCbHVyKCk7IH0pKTtcbiAgICAgICAgdGhpcy5faGVscGVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMudGV4dGFyZWEpO1xuICAgICAgICB0aGlzLl9jb21wb3NpdGlvblZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5fY29tcG9zaXRpb25WaWV3LmNsYXNzTGlzdC5hZGQoJ2NvbXBvc2l0aW9uLXZpZXcnKTtcbiAgICAgICAgdGhpcy5fY29tcG9zaXRpb25IZWxwZXIgPSBuZXcgQ29tcG9zaXRpb25IZWxwZXJfMS5Db21wb3NpdGlvbkhlbHBlcih0aGlzLnRleHRhcmVhLCB0aGlzLl9jb21wb3NpdGlvblZpZXcsIHRoaXMpO1xuICAgICAgICB0aGlzLl9oZWxwZXJDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fY29tcG9zaXRpb25WaWV3KTtcbiAgICAgICAgdGhpcy5jaGFyTWVhc3VyZSA9IG5ldyBDaGFyTWVhc3VyZV8xLkNoYXJNZWFzdXJlKGRvY3VtZW50LCB0aGlzLl9oZWxwZXJDb250YWluZXIpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuICAgICAgICB0aGlzLl9zZXR1cFJlbmRlcmVyKCk7XG4gICAgICAgIHRoaXMuX3RoZW1lID0gdGhpcy5vcHRpb25zLnRoZW1lO1xuICAgICAgICB0aGlzLm9wdGlvbnMudGhlbWUgPSBudWxsO1xuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gbmV3IFZpZXdwb3J0XzEuVmlld3BvcnQodGhpcywgdGhpcy5fdmlld3BvcnRFbGVtZW50LCB0aGlzLl92aWV3cG9ydFNjcm9sbEFyZWEsIHRoaXMuY2hhck1lYXN1cmUpO1xuICAgICAgICB0aGlzLnZpZXdwb3J0Lm9uVGhlbWVDaGFuZ2VkKHRoaXMucmVuZGVyZXIuY29sb3JNYW5hZ2VyLmNvbG9ycyk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodGhpcy52aWV3cG9ydCk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodGhpcy5hZGREaXNwb3NhYmxlTGlzdGVuZXIoJ2N1cnNvcm1vdmUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5yZW5kZXJlci5vbkN1cnNvck1vdmUoKTsgfSkpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHRoaXMuYWRkRGlzcG9zYWJsZUxpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5yZW5kZXJlci5vblJlc2l6ZShfdGhpcy5jb2xzLCBfdGhpcy5yb3dzKTsgfSkpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHRoaXMuYWRkRGlzcG9zYWJsZUxpc3RlbmVyKCdibHVyJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMucmVuZGVyZXIub25CbHVyKCk7IH0pKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih0aGlzLmFkZERpc3Bvc2FibGVMaXN0ZW5lcignZm9jdXMnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5yZW5kZXJlci5vbkZvY3VzKCk7IH0pKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih0aGlzLmFkZERpc3Bvc2FibGVMaXN0ZW5lcignZHByY2hhbmdlJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMucmVuZGVyZXIub25XaW5kb3dSZXNpemUod2luZG93LmRldmljZVBpeGVsUmF0aW8pOyB9KSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoTGlmZWN5Y2xlXzEuYWRkRGlzcG9zYWJsZURvbUxpc3RlbmVyKHdpbmRvdywgJ3Jlc2l6ZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnJlbmRlcmVyLm9uV2luZG93UmVzaXplKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTsgfSkpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHRoaXMuY2hhck1lYXN1cmUuYWRkRGlzcG9zYWJsZUxpc3RlbmVyKCdjaGFyc2l6ZWNoYW5nZWQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5yZW5kZXJlci5vbkNoYXJTaXplQ2hhbmdlZCgpOyB9KSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodGhpcy5yZW5kZXJlci5hZGREaXNwb3NhYmxlTGlzdGVuZXIoJ3Jlc2l6ZScsIGZ1bmN0aW9uIChkaW1lbnNpb25zKSB7IHJldHVybiBfdGhpcy52aWV3cG9ydC5zeW5jU2Nyb2xsQXJlYSgpOyB9KSk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTWFuYWdlciA9IG5ldyBTZWxlY3Rpb25NYW5hZ2VyXzEuU2VsZWN0aW9uTWFuYWdlcih0aGlzLCB0aGlzLmNoYXJNZWFzdXJlKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihMaWZlY3ljbGVfMS5hZGREaXNwb3NhYmxlRG9tTGlzdGVuZXIodGhpcy5lbGVtZW50LCAnbW91c2Vkb3duJywgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLnNlbGVjdGlvbk1hbmFnZXIub25Nb3VzZURvd24oZSk7IH0pKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih0aGlzLnNlbGVjdGlvbk1hbmFnZXIuYWRkRGlzcG9zYWJsZUxpc3RlbmVyKCdyZWZyZXNoJywgZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIF90aGlzLnJlbmRlcmVyLm9uU2VsZWN0aW9uQ2hhbmdlZChkYXRhLnN0YXJ0LCBkYXRhLmVuZCwgZGF0YS5jb2x1bW5TZWxlY3RNb2RlKTsgfSkpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHRoaXMuc2VsZWN0aW9uTWFuYWdlci5hZGREaXNwb3NhYmxlTGlzdGVuZXIoJ25ld3NlbGVjdGlvbicsIGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgICBfdGhpcy50ZXh0YXJlYS52YWx1ZSA9IHRleHQ7XG4gICAgICAgICAgICBfdGhpcy50ZXh0YXJlYS5mb2N1cygpO1xuICAgICAgICAgICAgX3RoaXMudGV4dGFyZWEuc2VsZWN0KCk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih0aGlzLmFkZERpc3Bvc2FibGVMaXN0ZW5lcignc2Nyb2xsJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMudmlld3BvcnQuc3luY1Njcm9sbEFyZWEoKTtcbiAgICAgICAgICAgIF90aGlzLnNlbGVjdGlvbk1hbmFnZXIucmVmcmVzaCgpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoTGlmZWN5Y2xlXzEuYWRkRGlzcG9zYWJsZURvbUxpc3RlbmVyKHRoaXMuX3ZpZXdwb3J0RWxlbWVudCwgJ3Njcm9sbCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNlbGVjdGlvbk1hbmFnZXIucmVmcmVzaCgpOyB9KSk7XG4gICAgICAgIHRoaXMubW91c2VIZWxwZXIgPSBuZXcgTW91c2VIZWxwZXJfMS5Nb3VzZUhlbHBlcih0aGlzLnJlbmRlcmVyKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zY3JlZW5SZWFkZXJNb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9hY2Nlc3NpYmlsaXR5TWFuYWdlciA9IG5ldyBBY2Nlc3NpYmlsaXR5TWFuYWdlcl8xLkFjY2Vzc2liaWxpdHlNYW5hZ2VyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhck1lYXN1cmUubWVhc3VyZSh0aGlzLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLnJlZnJlc2goMCwgdGhpcy5yb3dzIC0gMSk7XG4gICAgICAgIHRoaXMuX2luaXRHbG9iYWwoKTtcbiAgICAgICAgdGhpcy5iaW5kTW91c2UoKTtcbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5fc2V0dXBSZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLm9wdGlvbnMucmVuZGVyZXJUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdjYW52YXMnOlxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXJfMS5SZW5kZXJlcih0aGlzLCB0aGlzLm9wdGlvbnMudGhlbWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZG9tJzpcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyID0gbmV3IERvbVJlbmRlcmVyXzEuRG9tUmVuZGVyZXIodGhpcywgdGhpcy5vcHRpb25zLnRoZW1lKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCByZW5kZXJlclR5cGUgXFxcIlwiICsgdGhpcy5vcHRpb25zLnJlbmRlcmVyVHlwZSArIFwiXFxcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZ2lzdGVyKHRoaXMucmVuZGVyZXIpO1xuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLl9zZXRUaGVtZSA9IGZ1bmN0aW9uICh0aGVtZSkge1xuICAgICAgICB0aGlzLl90aGVtZSA9IHRoZW1lO1xuICAgICAgICB2YXIgY29sb3JzID0gdGhpcy5yZW5kZXJlci5zZXRUaGVtZSh0aGVtZSk7XG4gICAgICAgIGlmICh0aGlzLnZpZXdwb3J0KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0Lm9uVGhlbWVDaGFuZ2VkKGNvbG9ycyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5iaW5kTW91c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBlbCA9IHRoaXMuZWxlbWVudDtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcHJlc3NlZCA9IDMyO1xuICAgICAgICBmdW5jdGlvbiBzZW5kQnV0dG9uKGV2KSB7XG4gICAgICAgICAgICB2YXIgYnV0dG9uO1xuICAgICAgICAgICAgdmFyIHBvcztcbiAgICAgICAgICAgIGJ1dHRvbiA9IGdldEJ1dHRvbihldik7XG4gICAgICAgICAgICBwb3MgPSBzZWxmLm1vdXNlSGVscGVyLmdldFJhd0J5dGVDb29yZHMoZXYsIHNlbGYuc2NyZWVuRWxlbWVudCwgc2VsZi5jaGFyTWVhc3VyZSwgc2VsZi5vcHRpb25zLmxpbmVIZWlnaHQsIHNlbGYuY29scywgc2VsZi5yb3dzKTtcbiAgICAgICAgICAgIGlmICghcG9zKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHNlbmRFdmVudChidXR0b24sIHBvcyk7XG4gICAgICAgICAgICBzd2l0Y2ggKGV2Lm92ZXJyaWRlVHlwZSB8fCBldi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgICAgICAgICAgICAgcHJlc3NlZCA9IGJ1dHRvbjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbW91c2V1cCc6XG4gICAgICAgICAgICAgICAgICAgIHByZXNzZWQgPSAzMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnd2hlZWwnOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZW5kTW92ZShldikge1xuICAgICAgICAgICAgdmFyIGJ1dHRvbiA9IHByZXNzZWQ7XG4gICAgICAgICAgICB2YXIgcG9zID0gc2VsZi5tb3VzZUhlbHBlci5nZXRSYXdCeXRlQ29vcmRzKGV2LCBzZWxmLnNjcmVlbkVsZW1lbnQsIHNlbGYuY2hhck1lYXN1cmUsIHNlbGYub3B0aW9ucy5saW5lSGVpZ2h0LCBzZWxmLmNvbHMsIHNlbGYucm93cyk7XG4gICAgICAgICAgICBpZiAoIXBvcylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBidXR0b24gKz0gMzI7XG4gICAgICAgICAgICBzZW5kRXZlbnQoYnV0dG9uLCBwb3MpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVuY29kZShkYXRhLCBjaCkge1xuICAgICAgICAgICAgaWYgKCFzZWxmLnV0Zk1vdXNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAyNTUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wdXNoKDApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaCA+IDEyNylcbiAgICAgICAgICAgICAgICAgICAgY2ggPSAxMjc7XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMjA0Nykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goMCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoIDwgMTI3KSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEucHVzaChjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPiAyMDQ3KVxuICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSAyMDQ3O1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goMHhDMCB8IChjaCA+PiA2KSk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEucHVzaCgweDgwIHwgKGNoICYgMHgzRikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZW5kRXZlbnQoYnV0dG9uLCBwb3MpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl92dDMwME1vdXNlKSB7XG4gICAgICAgICAgICAgICAgYnV0dG9uICY9IDM7XG4gICAgICAgICAgICAgICAgcG9zLnggLT0gMzI7XG4gICAgICAgICAgICAgICAgcG9zLnkgLT0gMzI7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFfMSA9IEVzY2FwZVNlcXVlbmNlc18xLkMwLkVTQyArICdbMjQnO1xuICAgICAgICAgICAgICAgIGlmIChidXR0b24gPT09IDApXG4gICAgICAgICAgICAgICAgICAgIGRhdGFfMSArPSAnMSc7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYnV0dG9uID09PSAxKVxuICAgICAgICAgICAgICAgICAgICBkYXRhXzEgKz0gJzMnO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJ1dHRvbiA9PT0gMilcbiAgICAgICAgICAgICAgICAgICAgZGF0YV8xICs9ICc1JztcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChidXR0b24gPT09IDMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGRhdGFfMSArPSAnMCc7XG4gICAgICAgICAgICAgICAgZGF0YV8xICs9ICd+WycgKyBwb3MueCArICcsJyArIHBvcy55ICsgJ11cXHInO1xuICAgICAgICAgICAgICAgIHNlbGYuaGFuZGxlcihkYXRhXzEpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLl9kZWNMb2NhdG9yKSB7XG4gICAgICAgICAgICAgICAgYnV0dG9uICY9IDM7XG4gICAgICAgICAgICAgICAgcG9zLnggLT0gMzI7XG4gICAgICAgICAgICAgICAgcG9zLnkgLT0gMzI7XG4gICAgICAgICAgICAgICAgaWYgKGJ1dHRvbiA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uID0gMjtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChidXR0b24gPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbiA9IDQ7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYnV0dG9uID09PSAyKVxuICAgICAgICAgICAgICAgICAgICBidXR0b24gPSA2O1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJ1dHRvbiA9PT0gMylcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uID0gMztcbiAgICAgICAgICAgICAgICBzZWxmLmhhbmRsZXIoRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgJ1snXG4gICAgICAgICAgICAgICAgICAgICsgYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICsgJzsnXG4gICAgICAgICAgICAgICAgICAgICsgKGJ1dHRvbiA9PT0gMyA/IDQgOiAwKVxuICAgICAgICAgICAgICAgICAgICArICc7J1xuICAgICAgICAgICAgICAgICAgICArIHBvcy55XG4gICAgICAgICAgICAgICAgICAgICsgJzsnXG4gICAgICAgICAgICAgICAgICAgICsgcG9zLnhcbiAgICAgICAgICAgICAgICAgICAgKyAnOydcbiAgICAgICAgICAgICAgICAgICAgKyBwb3MucGFnZSB8fCAwXG4gICAgICAgICAgICAgICAgICAgICsgJyZ3Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYudXJ4dnRNb3VzZSkge1xuICAgICAgICAgICAgICAgIHBvcy54IC09IDMyO1xuICAgICAgICAgICAgICAgIHBvcy55IC09IDMyO1xuICAgICAgICAgICAgICAgIHBvcy54Kys7XG4gICAgICAgICAgICAgICAgcG9zLnkrKztcbiAgICAgICAgICAgICAgICBzZWxmLmhhbmRsZXIoRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgJ1snICsgYnV0dG9uICsgJzsnICsgcG9zLnggKyAnOycgKyBwb3MueSArICdNJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuc2dyTW91c2UpIHtcbiAgICAgICAgICAgICAgICBwb3MueCAtPSAzMjtcbiAgICAgICAgICAgICAgICBwb3MueSAtPSAzMjtcbiAgICAgICAgICAgICAgICBzZWxmLmhhbmRsZXIoRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgJ1s8J1xuICAgICAgICAgICAgICAgICAgICArICgoKGJ1dHRvbiAmIDMpID09PSAzID8gYnV0dG9uICYgfjMgOiBidXR0b24pIC0gMzIpXG4gICAgICAgICAgICAgICAgICAgICsgJzsnXG4gICAgICAgICAgICAgICAgICAgICsgcG9zLnhcbiAgICAgICAgICAgICAgICAgICAgKyAnOydcbiAgICAgICAgICAgICAgICAgICAgKyBwb3MueVxuICAgICAgICAgICAgICAgICAgICArICgoYnV0dG9uICYgMykgPT09IDMgPyAnbScgOiAnTScpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGF0YSA9IFtdO1xuICAgICAgICAgICAgZW5jb2RlKGRhdGEsIGJ1dHRvbik7XG4gICAgICAgICAgICBlbmNvZGUoZGF0YSwgcG9zLngpO1xuICAgICAgICAgICAgZW5jb2RlKGRhdGEsIHBvcy55KTtcbiAgICAgICAgICAgIHNlbGYuaGFuZGxlcihFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnW00nICsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRCdXR0b24oZXYpIHtcbiAgICAgICAgICAgIHZhciBidXR0b247XG4gICAgICAgICAgICB2YXIgc2hpZnQ7XG4gICAgICAgICAgICB2YXIgbWV0YTtcbiAgICAgICAgICAgIHZhciBjdHJsO1xuICAgICAgICAgICAgdmFyIG1vZDtcbiAgICAgICAgICAgIHN3aXRjaCAoZXYub3ZlcnJpZGVUeXBlIHx8IGV2LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgICAgICAgICAgICAgICAgICBidXR0b24gPSBldi5idXR0b24gIT09IG51bGwgJiYgZXYuYnV0dG9uICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gK2V2LmJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgOiBldi53aGljaCAhPT0gbnVsbCAmJiBldi53aGljaCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBldi53aGljaCAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChCcm93c2VyLmlzTVNJRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uID0gYnV0dG9uID09PSAxID8gMCA6IGJ1dHRvbiA9PT0gNCA/IDEgOiBidXR0b247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbW91c2V1cCc6XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbiA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0RPTU1vdXNlU2Nyb2xsJzpcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uID0gZXYuZGV0YWlsIDwgMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyA2NFxuICAgICAgICAgICAgICAgICAgICAgICAgOiA2NTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnd2hlZWwnOlxuICAgICAgICAgICAgICAgICAgICBidXR0b24gPSBldi53aGVlbERlbHRhWSA+IDBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gNjRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogNjU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2hpZnQgPSBldi5zaGlmdEtleSA/IDQgOiAwO1xuICAgICAgICAgICAgbWV0YSA9IGV2Lm1ldGFLZXkgPyA4IDogMDtcbiAgICAgICAgICAgIGN0cmwgPSBldi5jdHJsS2V5ID8gMTYgOiAwO1xuICAgICAgICAgICAgbW9kID0gc2hpZnQgfCBtZXRhIHwgY3RybDtcbiAgICAgICAgICAgIGlmIChzZWxmLnZ0MjAwTW91c2UpIHtcbiAgICAgICAgICAgICAgICBtb2QgJj0gY3RybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFzZWxmLm5vcm1hbE1vdXNlKSB7XG4gICAgICAgICAgICAgICAgbW9kID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1dHRvbiA9ICgzMiArIChtb2QgPDwgMikpICsgYnV0dG9uO1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZ2lzdGVyKExpZmVjeWNsZV8xLmFkZERpc3Bvc2FibGVEb21MaXN0ZW5lcihlbCwgJ21vdXNlZG93bicsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIF90aGlzLmZvY3VzKCk7XG4gICAgICAgICAgICBpZiAoIV90aGlzLm1vdXNlRXZlbnRzIHx8IF90aGlzLnNlbGVjdGlvbk1hbmFnZXIuc2hvdWxkRm9yY2VTZWxlY3Rpb24oZXYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VuZEJ1dHRvbihldik7XG4gICAgICAgICAgICBpZiAoX3RoaXMudnQyMDBNb3VzZSkge1xuICAgICAgICAgICAgICAgIGV2Lm92ZXJyaWRlVHlwZSA9ICdtb3VzZXVwJztcbiAgICAgICAgICAgICAgICBzZW5kQnV0dG9uKGV2KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY2FuY2VsKGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtb3ZlSGFuZGxlcjtcbiAgICAgICAgICAgIGlmIChfdGhpcy5ub3JtYWxNb3VzZSkge1xuICAgICAgICAgICAgICAgIG1vdmVIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMubm9ybWFsTW91c2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZW5kTW92ZShldmVudCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW92ZUhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMubm9ybWFsTW91c2UgJiYgIV90aGlzLngxME1vdXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmRCdXR0b24oZXYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobW92ZUhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2RvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdmVIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgbW92ZUhhbmRsZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5fZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jYW5jZWwoZXYpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF90aGlzLl9kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgaGFuZGxlcik7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuY2FuY2VsKGV2KTtcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKExpZmVjeWNsZV8xLmFkZERpc3Bvc2FibGVEb21MaXN0ZW5lcihlbCwgJ3doZWVsJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLm1vdXNlRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5idWZmZXIuaGFzU2Nyb2xsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW1vdW50ID0gX3RoaXMudmlld3BvcnQuZ2V0TGluZXNTY3JvbGxlZChldik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbW91bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgc2VxdWVuY2UgPSBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAoX3RoaXMuYXBwbGljYXRpb25DdXJzb3IgPyAnTycgOiAnWycpICsgKGV2LmRlbHRhWSA8IDAgPyAnQScgOiAnQicpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGguYWJzKGFtb3VudCk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSArPSBzZXF1ZW5jZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVyKGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMueDEwTW91c2UgfHwgX3RoaXMuX3Z0MzAwTW91c2UgfHwgX3RoaXMuX2RlY0xvY2F0b3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2VuZEJ1dHRvbihldik7XG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoTGlmZWN5Y2xlXzEuYWRkRGlzcG9zYWJsZURvbUxpc3RlbmVyKGVsLCAnd2hlZWwnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5tb3VzZUV2ZW50cylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBfdGhpcy52aWV3cG9ydC5vbldoZWVsKGV2KTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5jYW5jZWwoZXYpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoTGlmZWN5Y2xlXzEuYWRkRGlzcG9zYWJsZURvbUxpc3RlbmVyKGVsLCAndG91Y2hzdGFydCcsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKF90aGlzLm1vdXNlRXZlbnRzKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIF90aGlzLnZpZXdwb3J0Lm9uVG91Y2hTdGFydChldik7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuY2FuY2VsKGV2KTtcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKExpZmVjeWNsZV8xLmFkZERpc3Bvc2FibGVEb21MaXN0ZW5lcihlbCwgJ3RvdWNobW92ZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKF90aGlzLm1vdXNlRXZlbnRzKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIF90aGlzLnZpZXdwb3J0Lm9uVG91Y2hNb3ZlKGV2KTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5jYW5jZWwoZXYpO1xuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICBUZXJtaW5hbC5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlZnJlc2hSb3dzKHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZXJtaW5hbC5wcm90b3R5cGUuX3F1ZXVlTGlua2lmaWNhdGlvbiA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmtpZmllcikge1xuICAgICAgICAgICAgdGhpcy5saW5raWZpZXIubGlua2lmeVJvd3Moc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS51cGRhdGVDdXJzb3JTdHlsZSA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25NYW5hZ2VyICYmIHRoaXMuc2VsZWN0aW9uTWFuYWdlci5zaG91bGRDb2x1bW5TZWxlY3QoZXYpKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZCgneHRlcm0tY3Vyc29yLWNyb3NzaGFpcicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ3h0ZXJtLWN1cnNvci1jcm9zc2hhaXInKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLnNob3dDdXJzb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5jdXJzb3JTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3JTdGF0ZSA9IDE7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2godGhpcy5idWZmZXIueSwgdGhpcy5idWZmZXIueSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5zY3JvbGwgPSBmdW5jdGlvbiAoaXNXcmFwcGVkKSB7XG4gICAgICAgIHZhciBuZXdMaW5lID0gQnVmZmVyTGluZV8xLkJ1ZmZlckxpbmUuYmxhbmtMaW5lKHRoaXMuY29scywgQnVmZmVyXzEuREVGQVVMVF9BVFRSLCBpc1dyYXBwZWQpO1xuICAgICAgICB2YXIgdG9wUm93ID0gdGhpcy5idWZmZXIueWJhc2UgKyB0aGlzLmJ1ZmZlci5zY3JvbGxUb3A7XG4gICAgICAgIHZhciBib3R0b21Sb3cgPSB0aGlzLmJ1ZmZlci55YmFzZSArIHRoaXMuYnVmZmVyLnNjcm9sbEJvdHRvbTtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyLnNjcm9sbFRvcCA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIHdpbGxCdWZmZXJCZVRyaW1tZWQgPSB0aGlzLmJ1ZmZlci5saW5lcy5sZW5ndGggPT09IHRoaXMuYnVmZmVyLmxpbmVzLm1heExlbmd0aDtcbiAgICAgICAgICAgIGlmIChib3R0b21Sb3cgPT09IHRoaXMuYnVmZmVyLmxpbmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5saW5lcy5wdXNoKG5ld0xpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIubGluZXMuc3BsaWNlKGJvdHRvbVJvdyArIDEsIDAsIG5ld0xpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF3aWxsQnVmZmVyQmVUcmltbWVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIueWJhc2UrKztcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3VzZXJTY3JvbGxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXIueWRpc3ArKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdXNlclNjcm9sbGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci55ZGlzcCA9IE1hdGgubWF4KHRoaXMuYnVmZmVyLnlkaXNwIC0gMSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNjcm9sbFJlZ2lvbkhlaWdodCA9IGJvdHRvbVJvdyAtIHRvcFJvdyArIDE7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5saW5lcy5zaGlmdEVsZW1lbnRzKHRvcFJvdyArIDEsIHNjcm9sbFJlZ2lvbkhlaWdodCAtIDEsIC0xKTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLmxpbmVzLnNldChib3R0b21Sb3csIG5ld0xpbmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fdXNlclNjcm9sbGluZykge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIueWRpc3AgPSB0aGlzLmJ1ZmZlci55YmFzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVJhbmdlKHRoaXMuYnVmZmVyLnNjcm9sbFRvcCk7XG4gICAgICAgIHRoaXMudXBkYXRlUmFuZ2UodGhpcy5idWZmZXIuc2Nyb2xsQm90dG9tKTtcbiAgICAgICAgdGhpcy5lbWl0KCdzY3JvbGwnLCB0aGlzLmJ1ZmZlci55ZGlzcCk7XG4gICAgfTtcbiAgICBUZXJtaW5hbC5wcm90b3R5cGUuc2Nyb2xsTGluZXMgPSBmdW5jdGlvbiAoZGlzcCwgc3VwcHJlc3NTY3JvbGxFdmVudCkge1xuICAgICAgICBpZiAoZGlzcCA8IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1ZmZlci55ZGlzcCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3VzZXJTY3JvbGxpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpc3AgKyB0aGlzLmJ1ZmZlci55ZGlzcCA+PSB0aGlzLmJ1ZmZlci55YmFzZSkge1xuICAgICAgICAgICAgdGhpcy5fdXNlclNjcm9sbGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvbGRZZGlzcCA9IHRoaXMuYnVmZmVyLnlkaXNwO1xuICAgICAgICB0aGlzLmJ1ZmZlci55ZGlzcCA9IE1hdGgubWF4KE1hdGgubWluKHRoaXMuYnVmZmVyLnlkaXNwICsgZGlzcCwgdGhpcy5idWZmZXIueWJhc2UpLCAwKTtcbiAgICAgICAgaWYgKG9sZFlkaXNwID09PSB0aGlzLmJ1ZmZlci55ZGlzcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3VwcHJlc3NTY3JvbGxFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdzY3JvbGwnLCB0aGlzLmJ1ZmZlci55ZGlzcCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWZyZXNoKDAsIHRoaXMucm93cyAtIDEpO1xuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLnNjcm9sbFBhZ2VzID0gZnVuY3Rpb24gKHBhZ2VDb3VudCkge1xuICAgICAgICB0aGlzLnNjcm9sbExpbmVzKHBhZ2VDb3VudCAqICh0aGlzLnJvd3MgLSAxKSk7XG4gICAgfTtcbiAgICBUZXJtaW5hbC5wcm90b3R5cGUuc2Nyb2xsVG9Ub3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsTGluZXMoLXRoaXMuYnVmZmVyLnlkaXNwKTtcbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5zY3JvbGxUb0JvdHRvbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxMaW5lcyh0aGlzLmJ1ZmZlci55YmFzZSAtIHRoaXMuYnVmZmVyLnlkaXNwKTtcbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5zY3JvbGxUb0xpbmUgPSBmdW5jdGlvbiAobGluZSkge1xuICAgICAgICB2YXIgc2Nyb2xsQW1vdW50ID0gbGluZSAtIHRoaXMuYnVmZmVyLnlkaXNwO1xuICAgICAgICBpZiAoc2Nyb2xsQW1vdW50ICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbExpbmVzKHNjcm9sbEFtb3VudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlci5wdXNoKGRhdGEpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnVzZUZsb3dDb250cm9sICYmICF0aGlzLl94b2ZmU2VudFRvQ2F0Y2hVcCAmJiB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCA+PSBXUklURV9CVUZGRVJfUEFVU0VfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIoRXNjYXBlU2VxdWVuY2VzXzEuQzAuREMzKTtcbiAgICAgICAgICAgIHRoaXMuX3hvZmZTZW50VG9DYXRjaFVwID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3dyaXRlSW5Qcm9ncmVzcyAmJiB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3dyaXRlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5faW5uZXJXcml0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5faW5uZXJXcml0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2lzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd3JpdGVCYXRjaCA9IHRoaXMud3JpdGVCdWZmZXIuc3BsaWNlKDAsIFdSSVRFX0JBVENIX1NJWkUpO1xuICAgICAgICB3aGlsZSAod3JpdGVCYXRjaC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHdyaXRlQmF0Y2guc2hpZnQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl94b2ZmU2VudFRvQ2F0Y2hVcCAmJiB3cml0ZUJhdGNoLmxlbmd0aCA9PT0gMCAmJiB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlcihFc2NhcGVTZXF1ZW5jZXNfMS5DMC5EQzEpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3hvZmZTZW50VG9DYXRjaFVwID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZWZyZXNoU3RhcnQgPSB0aGlzLmJ1ZmZlci55O1xuICAgICAgICAgICAgdGhpcy5fcmVmcmVzaEVuZCA9IHRoaXMuYnVmZmVyLnk7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dEhhbmRsZXIucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJhbmdlKHRoaXMuYnVmZmVyLnkpO1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKHRoaXMuX3JlZnJlc2hTdGFydCwgdGhpcy5fcmVmcmVzaEVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5faW5uZXJXcml0ZSgpOyB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3dyaXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZXJtaW5hbC5wcm90b3R5cGUud3JpdGVsbiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMud3JpdGUoZGF0YSArICdcXHJcXG4nKTtcbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5hdHRhY2hDdXN0b21LZXlFdmVudEhhbmRsZXIgPSBmdW5jdGlvbiAoY3VzdG9tS2V5RXZlbnRIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX2N1c3RvbUtleUV2ZW50SGFuZGxlciA9IGN1c3RvbUtleUV2ZW50SGFuZGxlcjtcbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5yZWdpc3RlckxpbmtNYXRjaGVyID0gZnVuY3Rpb24gKHJlZ2V4LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBtYXRjaGVySWQgPSB0aGlzLmxpbmtpZmllci5yZWdpc3RlckxpbmtNYXRjaGVyKHJlZ2V4LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5yZWZyZXNoKDAsIHRoaXMucm93cyAtIDEpO1xuICAgICAgICByZXR1cm4gbWF0Y2hlcklkO1xuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLmRlcmVnaXN0ZXJMaW5rTWF0Y2hlciA9IGZ1bmN0aW9uIChtYXRjaGVySWQpIHtcbiAgICAgICAgaWYgKHRoaXMubGlua2lmaWVyLmRlcmVnaXN0ZXJMaW5rTWF0Y2hlcihtYXRjaGVySWQpKSB7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goMCwgdGhpcy5yb3dzIC0gMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5yZWdpc3RlckNoYXJhY3RlckpvaW5lciA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIHZhciBqb2luZXJJZCA9IHRoaXMucmVuZGVyZXIucmVnaXN0ZXJDaGFyYWN0ZXJKb2luZXIoaGFuZGxlcik7XG4gICAgICAgIHRoaXMucmVmcmVzaCgwLCB0aGlzLnJvd3MgLSAxKTtcbiAgICAgICAgcmV0dXJuIGpvaW5lcklkO1xuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLmRlcmVnaXN0ZXJDaGFyYWN0ZXJKb2luZXIgPSBmdW5jdGlvbiAoam9pbmVySWQpIHtcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZXIuZGVyZWdpc3RlckNoYXJhY3RlckpvaW5lcihqb2luZXJJZCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgwLCB0aGlzLnJvd3MgLSAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRlcm1pbmFsLnByb3RvdHlwZSwgXCJtYXJrZXJzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIubWFya2VycztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVGVybWluYWwucHJvdG90eXBlLmFkZE1hcmtlciA9IGZ1bmN0aW9uIChjdXJzb3JZT2Zmc2V0KSB7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlciAhPT0gdGhpcy5idWZmZXJzLm5vcm1hbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5hZGRNYXJrZXIodGhpcy5idWZmZXIueWJhc2UgKyB0aGlzLmJ1ZmZlci55ICsgY3Vyc29yWU9mZnNldCk7XG4gICAgfTtcbiAgICBUZXJtaW5hbC5wcm90b3R5cGUuaGFzU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25NYW5hZ2VyID8gdGhpcy5zZWxlY3Rpb25NYW5hZ2VyLmhhc1NlbGVjdGlvbiA6IGZhbHNlO1xuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uTWFuYWdlciA/IHRoaXMuc2VsZWN0aW9uTWFuYWdlci5zZWxlY3Rpb25UZXh0IDogJyc7XG4gICAgfTtcbiAgICBUZXJtaW5hbC5wcm90b3R5cGUuY2xlYXJTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1hbmFnZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uTWFuYWdlci5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZXJtaW5hbC5wcm90b3R5cGUuc2VsZWN0QWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25NYW5hZ2VyKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbk1hbmFnZXIuc2VsZWN0QWxsKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5zZWxlY3RMaW5lcyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1hbmFnZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uTWFuYWdlci5zZWxlY3RMaW5lcyhzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLl9rZXlEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXN0b21LZXlFdmVudEhhbmRsZXIgJiYgdGhpcy5fY3VzdG9tS2V5RXZlbnRIYW5kbGVyKGV2ZW50KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2NvbXBvc2l0aW9uSGVscGVyLmtleWRvd24oZXZlbnQpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZmZXIueWJhc2UgIT09IHRoaXMuYnVmZmVyLnlkaXNwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb0JvdHRvbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBLZXlib2FyZF8xLmV2YWx1YXRlS2V5Ym9hcmRFdmVudChldmVudCwgdGhpcy5hcHBsaWNhdGlvbkN1cnNvciwgdGhpcy5icm93c2VyLmlzTWFjLCB0aGlzLm9wdGlvbnMubWFjT3B0aW9uSXNNZXRhKTtcbiAgICAgICAgdGhpcy51cGRhdGVDdXJzb3JTdHlsZShldmVudCk7XG4gICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gMyB8fCByZXN1bHQudHlwZSA9PT0gMikge1xuICAgICAgICAgICAgdmFyIHNjcm9sbENvdW50ID0gdGhpcy5yb3dzIC0gMTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsTGluZXMocmVzdWx0LnR5cGUgPT09IDIgPyAtc2Nyb2xsQ291bnQgOiBzY3JvbGxDb3VudCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYW5jZWwoZXZlbnQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RBbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faXNUaGlyZExldmVsU2hpZnQodGhpcy5icm93c2VyLCBldmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQuY2FuY2VsKSB7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbChldmVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQua2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ2tleWRvd24nLCBldmVudCk7XG4gICAgICAgIHRoaXMuZW1pdCgna2V5JywgcmVzdWx0LmtleSwgZXZlbnQpO1xuICAgICAgICB0aGlzLnNob3dDdXJzb3IoKTtcbiAgICAgICAgdGhpcy5oYW5kbGVyKHJlc3VsdC5rZXkpO1xuICAgICAgICByZXR1cm4gdGhpcy5jYW5jZWwoZXZlbnQsIHRydWUpO1xuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLl9pc1RoaXJkTGV2ZWxTaGlmdCA9IGZ1bmN0aW9uIChicm93c2VyLCBldikge1xuICAgICAgICB2YXIgdGhpcmRMZXZlbEtleSA9IChicm93c2VyLmlzTWFjICYmICF0aGlzLm9wdGlvbnMubWFjT3B0aW9uSXNNZXRhICYmIGV2LmFsdEtleSAmJiAhZXYuY3RybEtleSAmJiAhZXYubWV0YUtleSkgfHxcbiAgICAgICAgICAgIChicm93c2VyLmlzTVNXaW5kb3dzICYmIGV2LmFsdEtleSAmJiBldi5jdHJsS2V5ICYmICFldi5tZXRhS2V5KTtcbiAgICAgICAgaWYgKGV2LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlyZExldmVsS2V5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlyZExldmVsS2V5ICYmICghZXYua2V5Q29kZSB8fCBldi5rZXlDb2RlID4gNDcpO1xuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLnNldGdMZXZlbCA9IGZ1bmN0aW9uIChnKSB7XG4gICAgICAgIHRoaXMuZ2xldmVsID0gZztcbiAgICAgICAgdGhpcy5jaGFyc2V0ID0gdGhpcy5jaGFyc2V0c1tnXTtcbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5zZXRnQ2hhcnNldCA9IGZ1bmN0aW9uIChnLCBjaGFyc2V0KSB7XG4gICAgICAgIHRoaXMuY2hhcnNldHNbZ10gPSBjaGFyc2V0O1xuICAgICAgICBpZiAodGhpcy5nbGV2ZWwgPT09IGcpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhcnNldCA9IGNoYXJzZXQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5fa2V5VXAgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDdXJzb3JTdHlsZShldik7XG4gICAgfTtcbiAgICBUZXJtaW5hbC5wcm90b3R5cGUuX2tleVByZXNzID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGlmICh0aGlzLl9jdXN0b21LZXlFdmVudEhhbmRsZXIgJiYgdGhpcy5fY3VzdG9tS2V5RXZlbnRIYW5kbGVyKGV2KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbmNlbChldik7XG4gICAgICAgIGlmIChldi5jaGFyQ29kZSkge1xuICAgICAgICAgICAga2V5ID0gZXYuY2hhckNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXYud2hpY2ggPT09IG51bGwgfHwgZXYud2hpY2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAga2V5ID0gZXYua2V5Q29kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldi53aGljaCAhPT0gMCAmJiBldi5jaGFyQ29kZSAhPT0gMCkge1xuICAgICAgICAgICAga2V5ID0gZXYud2hpY2g7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFrZXkgfHwgKChldi5hbHRLZXkgfHwgZXYuY3RybEtleSB8fCBldi5tZXRhS2V5KSAmJiAhdGhpcy5faXNUaGlyZExldmVsU2hpZnQodGhpcy5icm93c2VyLCBldikpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gU3RyaW5nLmZyb21DaGFyQ29kZShrZXkpO1xuICAgICAgICB0aGlzLmVtaXQoJ2tleXByZXNzJywga2V5LCBldik7XG4gICAgICAgIHRoaXMuZW1pdCgna2V5Jywga2V5LCBldik7XG4gICAgICAgIHRoaXMuc2hvd0N1cnNvcigpO1xuICAgICAgICB0aGlzLmhhbmRsZXIoa2V5KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBUZXJtaW5hbC5wcm90b3R5cGUuYmVsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5lbWl0KCdiZWxsJyk7XG4gICAgICAgIGlmICh0aGlzLl9zb3VuZEJlbGwoKSkge1xuICAgICAgICAgICAgdGhpcy5zb3VuZE1hbmFnZXIucGxheUJlbGxTb3VuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl92aXN1YWxCZWxsKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCd2aXN1YWwtYmVsbC1hY3RpdmUnKTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl92aXN1YWxCZWxsVGltZXIpO1xuICAgICAgICAgICAgdGhpcy5fdmlzdWFsQmVsbFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgndmlzdWFsLWJlbGwtYWN0aXZlJyk7XG4gICAgICAgICAgICB9LCAyMDApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZXJtaW5hbC5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKHRleHQsIGRhdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZGVidWcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghdGhpcy5fY29udGV4dC5jb25zb2xlIHx8ICF0aGlzLl9jb250ZXh0LmNvbnNvbGUubG9nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9jb250ZXh0LmNvbnNvbGUubG9nKHRleHQsIGRhdGEpO1xuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKHRleHQsIGRhdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZGVidWcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghdGhpcy5fY29udGV4dC5jb25zb2xlIHx8ICF0aGlzLl9jb250ZXh0LmNvbnNvbGUuZXJyb3IpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY29uc29sZS5lcnJvcih0ZXh0LCBkYXRhKTtcbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICBpZiAoaXNOYU4oeCkgfHwgaXNOYU4oeSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCA9PT0gdGhpcy5jb2xzICYmIHkgPT09IHRoaXMucm93cykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hhck1lYXN1cmUgJiYgKCF0aGlzLmNoYXJNZWFzdXJlLndpZHRoIHx8ICF0aGlzLmNoYXJNZWFzdXJlLmhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJNZWFzdXJlLm1lYXN1cmUodGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCA8IDEpXG4gICAgICAgICAgICB4ID0gMTtcbiAgICAgICAgaWYgKHkgPCAxKVxuICAgICAgICAgICAgeSA9IDE7XG4gICAgICAgIHRoaXMuYnVmZmVycy5yZXNpemUoeCwgeSk7XG4gICAgICAgIHRoaXMuY29scyA9IHg7XG4gICAgICAgIHRoaXMucm93cyA9IHk7XG4gICAgICAgIHRoaXMuYnVmZmVycy5zZXR1cFRhYlN0b3BzKHRoaXMuY29scyk7XG4gICAgICAgIGlmICh0aGlzLmNoYXJNZWFzdXJlKSB7XG4gICAgICAgICAgICB0aGlzLmNoYXJNZWFzdXJlLm1lYXN1cmUodGhpcy5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZnJlc2goMCwgdGhpcy5yb3dzIC0gMSk7XG4gICAgICAgIHRoaXMuZW1pdCgncmVzaXplJywgeyBjb2xzOiB4LCByb3dzOiB5IH0pO1xuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLnVwZGF0ZVJhbmdlID0gZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgaWYgKHkgPCB0aGlzLl9yZWZyZXNoU3RhcnQpXG4gICAgICAgICAgICB0aGlzLl9yZWZyZXNoU3RhcnQgPSB5O1xuICAgICAgICBpZiAoeSA+IHRoaXMuX3JlZnJlc2hFbmQpXG4gICAgICAgICAgICB0aGlzLl9yZWZyZXNoRW5kID0geTtcbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5tYXhSYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmVmcmVzaFN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5fcmVmcmVzaEVuZCA9IHRoaXMucm93cyAtIDE7XG4gICAgfTtcbiAgICBUZXJtaW5hbC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlci55YmFzZSA9PT0gMCAmJiB0aGlzLmJ1ZmZlci55ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXIubGluZXMuc2V0KDAsIHRoaXMuYnVmZmVyLmxpbmVzLmdldCh0aGlzLmJ1ZmZlci55YmFzZSArIHRoaXMuYnVmZmVyLnkpKTtcbiAgICAgICAgdGhpcy5idWZmZXIubGluZXMubGVuZ3RoID0gMTtcbiAgICAgICAgdGhpcy5idWZmZXIueWRpc3AgPSAwO1xuICAgICAgICB0aGlzLmJ1ZmZlci55YmFzZSA9IDA7XG4gICAgICAgIHRoaXMuYnVmZmVyLnkgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5saW5lcy5wdXNoKEJ1ZmZlckxpbmVfMS5CdWZmZXJMaW5lLmJsYW5rTGluZSh0aGlzLmNvbHMsIEJ1ZmZlcl8xLkRFRkFVTFRfQVRUUikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVmcmVzaCgwLCB0aGlzLnJvd3MgLSAxKTtcbiAgICAgICAgdGhpcy5lbWl0KCdzY3JvbGwnLCB0aGlzLmJ1ZmZlci55ZGlzcCk7XG4gICAgfTtcbiAgICBUZXJtaW5hbC5wcm90b3R5cGUuY2ggPSBmdW5jdGlvbiAoY3VyKSB7XG4gICAgICAgIGlmIChjdXIpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5lcmFzZUF0dHIoKSwgQnVmZmVyXzEuTlVMTF9DRUxMX0NIQVIsIEJ1ZmZlcl8xLk5VTExfQ0VMTF9XSURUSCwgQnVmZmVyXzEuTlVMTF9DRUxMX0NPREVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbQnVmZmVyXzEuREVGQVVMVF9BVFRSLCBCdWZmZXJfMS5OVUxMX0NFTExfQ0hBUiwgQnVmZmVyXzEuTlVMTF9DRUxMX1dJRFRILCBCdWZmZXJfMS5OVUxMX0NFTExfQ09ERV07XG4gICAgfTtcbiAgICBUZXJtaW5hbC5wcm90b3R5cGUuaXMgPSBmdW5jdGlvbiAodGVybSkge1xuICAgICAgICByZXR1cm4gKHRoaXMub3B0aW9ucy50ZXJtTmFtZSArICcnKS5pbmRleE9mKHRlcm0pID09PSAwO1xuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLmhhbmRsZXIgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRpc2FibGVTdGRpbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1hbmFnZXIgJiYgdGhpcy5zZWxlY3Rpb25NYW5hZ2VyLmhhc1NlbGVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25NYW5hZ2VyLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyLnliYXNlICE9PSB0aGlzLmJ1ZmZlci55ZGlzcCkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb0JvdHRvbSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIGRhdGEpO1xuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLmhhbmRsZVRpdGxlID0gZnVuY3Rpb24gKHRpdGxlKSB7XG4gICAgICAgIHRoaXMuZW1pdCgndGl0bGUnLCB0aXRsZSk7XG4gICAgfTtcbiAgICBUZXJtaW5hbC5wcm90b3R5cGUuaW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyLnkrKztcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyLnkgPiB0aGlzLmJ1ZmZlci5zY3JvbGxCb3R0b20pIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnktLTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyLnggPj0gdGhpcy5jb2xzKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci54LS07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5yZXZlcnNlSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlci55ID09PSB0aGlzLmJ1ZmZlci5zY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIHZhciBzY3JvbGxSZWdpb25IZWlnaHQgPSB0aGlzLmJ1ZmZlci5zY3JvbGxCb3R0b20gLSB0aGlzLmJ1ZmZlci5zY3JvbGxUb3A7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5saW5lcy5zaGlmdEVsZW1lbnRzKHRoaXMuYnVmZmVyLnkgKyB0aGlzLmJ1ZmZlci55YmFzZSwgc2Nyb2xsUmVnaW9uSGVpZ2h0LCAxKTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLmxpbmVzLnNldCh0aGlzLmJ1ZmZlci55ICsgdGhpcy5idWZmZXIueWJhc2UsIEJ1ZmZlckxpbmVfMS5CdWZmZXJMaW5lLmJsYW5rTGluZSh0aGlzLmNvbHMsIHRoaXMuZXJhc2VBdHRyKCkpKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUmFuZ2UodGhpcy5idWZmZXIuc2Nyb2xsVG9wKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUmFuZ2UodGhpcy5idWZmZXIuc2Nyb2xsQm90dG9tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnktLTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMucm93cyA9IHRoaXMucm93cztcbiAgICAgICAgdGhpcy5vcHRpb25zLmNvbHMgPSB0aGlzLmNvbHM7XG4gICAgICAgIHZhciBjdXN0b21LZXlFdmVudEhhbmRsZXIgPSB0aGlzLl9jdXN0b21LZXlFdmVudEhhbmRsZXI7XG4gICAgICAgIHZhciBpbnB1dEhhbmRsZXIgPSB0aGlzLl9pbnB1dEhhbmRsZXI7XG4gICAgICAgIHZhciBjdXJzb3JTdGF0ZSA9IHRoaXMuY3Vyc29yU3RhdGU7XG4gICAgICAgIHRoaXMuX3NldHVwKCk7XG4gICAgICAgIHRoaXMuX2N1c3RvbUtleUV2ZW50SGFuZGxlciA9IGN1c3RvbUtleUV2ZW50SGFuZGxlcjtcbiAgICAgICAgdGhpcy5faW5wdXRIYW5kbGVyID0gaW5wdXRIYW5kbGVyO1xuICAgICAgICB0aGlzLmN1cnNvclN0YXRlID0gY3Vyc29yU3RhdGU7XG4gICAgICAgIHRoaXMucmVmcmVzaCgwLCB0aGlzLnJvd3MgLSAxKTtcbiAgICAgICAgaWYgKHRoaXMudmlld3BvcnQpIHtcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnQuc3luY1Njcm9sbEFyZWEoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLnRhYlNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5idWZmZXIudGFic1t0aGlzLmJ1ZmZlci54XSA9IHRydWU7XG4gICAgfTtcbiAgICBUZXJtaW5hbC5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKGV2LCBmb3JjZSkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5jYW5jZWxFdmVudHMgJiYgIWZvcmNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5tYXRjaENvbG9yID0gZnVuY3Rpb24gKHIxLCBnMSwgYjEpIHtcbiAgICAgICAgdmFyIGhhc2ggPSAocjEgPDwgMTYpIHwgKGcxIDw8IDgpIHwgYjE7XG4gICAgICAgIGlmIChtYXRjaENvbG9yQ2FjaGVbaGFzaF0gIT09IG51bGwgJiYgbWF0Y2hDb2xvckNhY2hlW2hhc2hdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaENvbG9yQ2FjaGVbaGFzaF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxkaWZmID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBsaSA9IC0xO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBjO1xuICAgICAgICB2YXIgcjI7XG4gICAgICAgIHZhciBnMjtcbiAgICAgICAgdmFyIGIyO1xuICAgICAgICB2YXIgZGlmZjtcbiAgICAgICAgZm9yICg7IGkgPCBDb2xvck1hbmFnZXJfMS5ERUZBVUxUX0FOU0lfQ09MT1JTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjID0gQ29sb3JNYW5hZ2VyXzEuREVGQVVMVF9BTlNJX0NPTE9SU1tpXS5yZ2JhO1xuICAgICAgICAgICAgcjIgPSBjID4+PiAyNDtcbiAgICAgICAgICAgIGcyID0gYyA+Pj4gMTYgJiAweEZGO1xuICAgICAgICAgICAgYjIgPSBjID4+PiA4ICYgMHhGRjtcbiAgICAgICAgICAgIGRpZmYgPSBtYXRjaENvbG9yRGlzdGFuY2UocjEsIGcxLCBiMSwgcjIsIGcyLCBiMik7XG4gICAgICAgICAgICBpZiAoZGlmZiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxpID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaWZmIDwgbGRpZmYpIHtcbiAgICAgICAgICAgICAgICBsZGlmZiA9IGRpZmY7XG4gICAgICAgICAgICAgICAgbGkgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXRjaENvbG9yQ2FjaGVbaGFzaF0gPSBsaTtcbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5fdmlzdWFsQmVsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLl9zb3VuZEJlbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYmVsbFN0eWxlID09PSAnc291bmQnO1xuICAgIH07XG4gICAgcmV0dXJuIFRlcm1pbmFsO1xufShFdmVudEVtaXR0ZXJfMS5FdmVudEVtaXR0ZXIpKTtcbmV4cG9ydHMuVGVybWluYWwgPSBUZXJtaW5hbDtcbmZ1bmN0aW9uIHdhc01vZGlmaWVyS2V5T25seUV2ZW50KGV2KSB7XG4gICAgcmV0dXJuIGV2LmtleUNvZGUgPT09IDE2IHx8XG4gICAgICAgIGV2LmtleUNvZGUgPT09IDE3IHx8XG4gICAgICAgIGV2LmtleUNvZGUgPT09IDE4O1xufVxudmFyIG1hdGNoQ29sb3JDYWNoZSA9IHt9O1xuZnVuY3Rpb24gbWF0Y2hDb2xvckRpc3RhbmNlKHIxLCBnMSwgYjEsIHIyLCBnMiwgYjIpIHtcbiAgICByZXR1cm4gTWF0aC5wb3coMzAgKiAocjEgLSByMiksIDIpXG4gICAgICAgICsgTWF0aC5wb3coNTkgKiAoZzEgLSBnMiksIDIpXG4gICAgICAgICsgTWF0aC5wb3coMTEgKiAoYjEgLSBiMiksIDIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGVybWluYWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIExpZmVjeWNsZV8xID0gcmVxdWlyZShcIi4vY29tbW9uL0xpZmVjeWNsZVwiKTtcbnZhciBMaWZlY3ljbGVfMiA9IHJlcXVpcmUoXCIuL3VpL0xpZmVjeWNsZVwiKTtcbnZhciBGQUxMQkFDS19TQ1JPTExfQkFSX1dJRFRIID0gMTU7XG52YXIgVmlld3BvcnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhWaWV3cG9ydCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBWaWV3cG9ydChfdGVybWluYWwsIF92aWV3cG9ydEVsZW1lbnQsIF9zY3JvbGxBcmVhLCBfY2hhck1lYXN1cmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3Rlcm1pbmFsID0gX3Rlcm1pbmFsO1xuICAgICAgICBfdGhpcy5fdmlld3BvcnRFbGVtZW50ID0gX3ZpZXdwb3J0RWxlbWVudDtcbiAgICAgICAgX3RoaXMuX3Njcm9sbEFyZWEgPSBfc2Nyb2xsQXJlYTtcbiAgICAgICAgX3RoaXMuX2NoYXJNZWFzdXJlID0gX2NoYXJNZWFzdXJlO1xuICAgICAgICBfdGhpcy5zY3JvbGxCYXJXaWR0aCA9IDA7XG4gICAgICAgIF90aGlzLl9jdXJyZW50Um93SGVpZ2h0ID0gMDtcbiAgICAgICAgX3RoaXMuX2xhc3RSZWNvcmRlZEJ1ZmZlckxlbmd0aCA9IDA7XG4gICAgICAgIF90aGlzLl9sYXN0UmVjb3JkZWRWaWV3cG9ydEhlaWdodCA9IDA7XG4gICAgICAgIF90aGlzLl9sYXN0UmVjb3JkZWRCdWZmZXJIZWlnaHQgPSAwO1xuICAgICAgICBfdGhpcy5fbGFzdFNjcm9sbFRvcCA9IDA7XG4gICAgICAgIF90aGlzLl93aGVlbFBhcnRpYWxTY3JvbGwgPSAwO1xuICAgICAgICBfdGhpcy5fcmVmcmVzaEFuaW1hdGlvbkZyYW1lID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX2lnbm9yZU5leHRTY3JvbGxFdmVudCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5zY3JvbGxCYXJXaWR0aCA9IChfdGhpcy5fdmlld3BvcnRFbGVtZW50Lm9mZnNldFdpZHRoIC0gX3RoaXMuX3Njcm9sbEFyZWEub2Zmc2V0V2lkdGgpIHx8IEZBTExCQUNLX1NDUk9MTF9CQVJfV0lEVEg7XG4gICAgICAgIF90aGlzLnJlZ2lzdGVyKExpZmVjeWNsZV8yLmFkZERpc3Bvc2FibGVEb21MaXN0ZW5lcihfdGhpcy5fdmlld3BvcnRFbGVtZW50LCAnc2Nyb2xsJywgX3RoaXMuX29uU2Nyb2xsLmJpbmQoX3RoaXMpKSk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc3luY1Njcm9sbEFyZWEoKTsgfSwgMCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVmlld3BvcnQucHJvdG90eXBlLm9uVGhlbWVDaGFuZ2VkID0gZnVuY3Rpb24gKGNvbG9ycykge1xuICAgICAgICB0aGlzLl92aWV3cG9ydEVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3JzLmJhY2tncm91bmQuY3NzO1xuICAgIH07XG4gICAgVmlld3BvcnQucHJvdG90eXBlLl9yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fcmVmcmVzaEFuaW1hdGlvbkZyYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWZyZXNoQW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2lubmVyUmVmcmVzaCgpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVmlld3BvcnQucHJvdG90eXBlLl9pbm5lclJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jaGFyTWVhc3VyZS5oZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50Um93SGVpZ2h0ID0gdGhpcy5fdGVybWluYWwucmVuZGVyZXIuZGltZW5zaW9ucy5zY2FsZWRDZWxsSGVpZ2h0IC8gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgICAgICB0aGlzLl9sYXN0UmVjb3JkZWRWaWV3cG9ydEhlaWdodCA9IHRoaXMuX3ZpZXdwb3J0RWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICB2YXIgbmV3QnVmZmVySGVpZ2h0ID0gTWF0aC5yb3VuZCh0aGlzLl9jdXJyZW50Um93SGVpZ2h0ICogdGhpcy5fbGFzdFJlY29yZGVkQnVmZmVyTGVuZ3RoKSArICh0aGlzLl9sYXN0UmVjb3JkZWRWaWV3cG9ydEhlaWdodCAtIHRoaXMuX3Rlcm1pbmFsLnJlbmRlcmVyLmRpbWVuc2lvbnMuY2FudmFzSGVpZ2h0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sYXN0UmVjb3JkZWRCdWZmZXJIZWlnaHQgIT09IG5ld0J1ZmZlckhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RSZWNvcmRlZEJ1ZmZlckhlaWdodCA9IG5ld0J1ZmZlckhlaWdodDtcbiAgICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxBcmVhLnN0eWxlLmhlaWdodCA9IHRoaXMuX2xhc3RSZWNvcmRlZEJ1ZmZlckhlaWdodCArICdweCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjcm9sbFRvcCA9IHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci55ZGlzcCAqIHRoaXMuX2N1cnJlbnRSb3dIZWlnaHQ7XG4gICAgICAgIGlmICh0aGlzLl92aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wICE9PSBzY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIHRoaXMuX2lnbm9yZU5leHRTY3JvbGxFdmVudCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl92aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlZnJlc2hBbmltYXRpb25GcmFtZSA9IG51bGw7XG4gICAgfTtcbiAgICBWaWV3cG9ydC5wcm90b3R5cGUuc3luY1Njcm9sbEFyZWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYXN0UmVjb3JkZWRCdWZmZXJMZW5ndGggIT09IHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci5saW5lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RSZWNvcmRlZEJ1ZmZlckxlbmd0aCA9IHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci5saW5lcy5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLl9yZWZyZXNoKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2xhc3RSZWNvcmRlZFZpZXdwb3J0SGVpZ2h0ICE9PSB0aGlzLl90ZXJtaW5hbC5yZW5kZXJlci5kaW1lbnNpb25zLmNhbnZhc0hlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5fcmVmcmVzaCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdTY3JvbGxUb3AgPSB0aGlzLl90ZXJtaW5hbC5idWZmZXIueWRpc3AgKiB0aGlzLl9jdXJyZW50Um93SGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy5fbGFzdFNjcm9sbFRvcCAhPT0gbmV3U2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWZyZXNoKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2xhc3RTY3JvbGxUb3AgIT09IHRoaXMuX3ZpZXdwb3J0RWxlbWVudC5zY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdGVybWluYWwucmVuZGVyZXIuZGltZW5zaW9ucy5zY2FsZWRDZWxsSGVpZ2h0IC8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gIT09IHRoaXMuX2N1cnJlbnRSb3dIZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVmlld3BvcnQucHJvdG90eXBlLl9vblNjcm9sbCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICB0aGlzLl9sYXN0U2Nyb2xsVG9wID0gdGhpcy5fdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICAgaWYgKCF0aGlzLl92aWV3cG9ydEVsZW1lbnQub2Zmc2V0UGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2lnbm9yZU5leHRTY3JvbGxFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5faWdub3JlTmV4dFNjcm9sbEV2ZW50ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld1JvdyA9IE1hdGgucm91bmQodGhpcy5fbGFzdFNjcm9sbFRvcCAvIHRoaXMuX2N1cnJlbnRSb3dIZWlnaHQpO1xuICAgICAgICB2YXIgZGlmZiA9IG5ld1JvdyAtIHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci55ZGlzcDtcbiAgICAgICAgdGhpcy5fdGVybWluYWwuc2Nyb2xsTGluZXMoZGlmZiwgdHJ1ZSk7XG4gICAgfTtcbiAgICBWaWV3cG9ydC5wcm90b3R5cGUub25XaGVlbCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICB2YXIgYW1vdW50ID0gdGhpcy5fZ2V0UGl4ZWxzU2Nyb2xsZWQoZXYpO1xuICAgICAgICBpZiAoYW1vdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcCArPSBhbW91bnQ7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBWaWV3cG9ydC5wcm90b3R5cGUuX2dldFBpeGVsc1Njcm9sbGVkID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIGlmIChldi5kZWx0YVkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbW91bnQgPSBldi5kZWx0YVk7XG4gICAgICAgIGlmIChldi5kZWx0YU1vZGUgPT09IFdoZWVsRXZlbnQuRE9NX0RFTFRBX0xJTkUpIHtcbiAgICAgICAgICAgIGFtb3VudCAqPSB0aGlzLl9jdXJyZW50Um93SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2LmRlbHRhTW9kZSA9PT0gV2hlZWxFdmVudC5ET01fREVMVEFfUEFHRSkge1xuICAgICAgICAgICAgYW1vdW50ICo9IHRoaXMuX2N1cnJlbnRSb3dIZWlnaHQgKiB0aGlzLl90ZXJtaW5hbC5yb3dzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbW91bnQ7XG4gICAgfTtcbiAgICBWaWV3cG9ydC5wcm90b3R5cGUuZ2V0TGluZXNTY3JvbGxlZCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICBpZiAoZXYuZGVsdGFZID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYW1vdW50ID0gZXYuZGVsdGFZO1xuICAgICAgICBpZiAoZXYuZGVsdGFNb2RlID09PSBXaGVlbEV2ZW50LkRPTV9ERUxUQV9QSVhFTCkge1xuICAgICAgICAgICAgYW1vdW50IC89IHRoaXMuX2N1cnJlbnRSb3dIZWlnaHQgKyAwLjA7XG4gICAgICAgICAgICB0aGlzLl93aGVlbFBhcnRpYWxTY3JvbGwgKz0gYW1vdW50O1xuICAgICAgICAgICAgYW1vdW50ID0gTWF0aC5mbG9vcihNYXRoLmFicyh0aGlzLl93aGVlbFBhcnRpYWxTY3JvbGwpKSAqICh0aGlzLl93aGVlbFBhcnRpYWxTY3JvbGwgPiAwID8gMSA6IC0xKTtcbiAgICAgICAgICAgIHRoaXMuX3doZWVsUGFydGlhbFNjcm9sbCAlPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2LmRlbHRhTW9kZSA9PT0gV2hlZWxFdmVudC5ET01fREVMVEFfUEFHRSkge1xuICAgICAgICAgICAgYW1vdW50ICo9IHRoaXMuX3Rlcm1pbmFsLnJvd3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFtb3VudDtcbiAgICB9O1xuICAgIFZpZXdwb3J0LnByb3RvdHlwZS5vblRvdWNoU3RhcnQgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdGhpcy5fbGFzdFRvdWNoWSA9IGV2LnRvdWNoZXNbMF0ucGFnZVk7XG4gICAgfTtcbiAgICBWaWV3cG9ydC5wcm90b3R5cGUub25Ub3VjaE1vdmUgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdmFyIGRlbHRhWSA9IHRoaXMuX2xhc3RUb3VjaFkgLSBldi50b3VjaGVzWzBdLnBhZ2VZO1xuICAgICAgICB0aGlzLl9sYXN0VG91Y2hZID0gZXYudG91Y2hlc1swXS5wYWdlWTtcbiAgICAgICAgaWYgKGRlbHRhWSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0RWxlbWVudC5zY3JvbGxUb3AgKz0gZGVsdGFZO1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG4gICAgcmV0dXJuIFZpZXdwb3J0O1xufShMaWZlY3ljbGVfMS5EaXNwb3NhYmxlKSk7XG5leHBvcnRzLlZpZXdwb3J0ID0gVmlld3BvcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WaWV3cG9ydC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGF0dGFjaCh0ZXJtLCBzb2NrZXQsIGJpZGlyZWN0aW9uYWwsIGJ1ZmZlcmVkKSB7XG4gICAgdmFyIGFkZG9uVGVybWluYWwgPSB0ZXJtO1xuICAgIGJpZGlyZWN0aW9uYWwgPSAodHlwZW9mIGJpZGlyZWN0aW9uYWwgPT09ICd1bmRlZmluZWQnKSA/IHRydWUgOiBiaWRpcmVjdGlvbmFsO1xuICAgIGFkZG9uVGVybWluYWwuX19zb2NrZXQgPSBzb2NrZXQ7XG4gICAgYWRkb25UZXJtaW5hbC5fX2ZsdXNoQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBhZGRvblRlcm1pbmFsLndyaXRlKGFkZG9uVGVybWluYWwuX19hdHRhY2hTb2NrZXRCdWZmZXIpO1xuICAgICAgICBhZGRvblRlcm1pbmFsLl9fYXR0YWNoU29ja2V0QnVmZmVyID0gbnVsbDtcbiAgICB9O1xuICAgIGFkZG9uVGVybWluYWwuX19wdXNoVG9CdWZmZXIgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoYWRkb25UZXJtaW5hbC5fX2F0dGFjaFNvY2tldEJ1ZmZlcikge1xuICAgICAgICAgICAgYWRkb25UZXJtaW5hbC5fX2F0dGFjaFNvY2tldEJ1ZmZlciArPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWRkb25UZXJtaW5hbC5fX2F0dGFjaFNvY2tldEJ1ZmZlciA9IGRhdGE7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGFkZG9uVGVybWluYWwuX19mbHVzaEJ1ZmZlciwgMTApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgbXlUZXh0RGVjb2RlcjtcbiAgICBhZGRvblRlcm1pbmFsLl9fZ2V0TWVzc2FnZSA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICB2YXIgc3RyO1xuICAgICAgICBpZiAodHlwZW9mIGV2LmRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoIW15VGV4dERlY29kZXIpIHtcbiAgICAgICAgICAgICAgICBteVRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXYuZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gbXlUZXh0RGVjb2Rlci5kZWNvZGUoZXYuZGF0YSk7XG4gICAgICAgICAgICAgICAgZGlzcGxheURhdGEoc3RyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBmaWxlUmVhZGVyXzEgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgICAgIGZpbGVSZWFkZXJfMS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSBteVRleHREZWNvZGVyLmRlY29kZShmaWxlUmVhZGVyXzEucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGEoc3RyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmaWxlUmVhZGVyXzEucmVhZEFzQXJyYXlCdWZmZXIoZXYuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGV2LmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBkaXNwbGF5RGF0YShldi5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiQ2Fubm90IGhhbmRsZSBcXFwiXCIgKyB0eXBlb2YgZXYuZGF0YSArIFwiXFxcIiB3ZWJzb2NrZXQgbWVzc2FnZS5cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGRpc3BsYXlEYXRhKHN0ciwgZGF0YSkge1xuICAgICAgICBpZiAoYnVmZmVyZWQpIHtcbiAgICAgICAgICAgIGFkZG9uVGVybWluYWwuX19wdXNoVG9CdWZmZXIoc3RyIHx8IGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWRkb25UZXJtaW5hbC53cml0ZShzdHIgfHwgZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkb25UZXJtaW5hbC5fX3NlbmREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKHNvY2tldC5yZWFkeVN0YXRlICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc29ja2V0LnNlbmQoZGF0YSk7XG4gICAgfTtcbiAgICBhZGRvblRlcm1pbmFsLl9jb3JlLnJlZ2lzdGVyKGFkZFNvY2tldExpc3RlbmVyKHNvY2tldCwgJ21lc3NhZ2UnLCBhZGRvblRlcm1pbmFsLl9fZ2V0TWVzc2FnZSkpO1xuICAgIGlmIChiaWRpcmVjdGlvbmFsKSB7XG4gICAgICAgIGFkZG9uVGVybWluYWwuX2NvcmUucmVnaXN0ZXIoYWRkb25UZXJtaW5hbC5hZGREaXNwb3NhYmxlTGlzdGVuZXIoJ2RhdGEnLCBhZGRvblRlcm1pbmFsLl9fc2VuZERhdGEpKTtcbiAgICB9XG4gICAgYWRkb25UZXJtaW5hbC5fY29yZS5yZWdpc3RlcihhZGRTb2NrZXRMaXN0ZW5lcihzb2NrZXQsICdjbG9zZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRldGFjaChhZGRvblRlcm1pbmFsLCBzb2NrZXQpOyB9KSk7XG4gICAgYWRkb25UZXJtaW5hbC5fY29yZS5yZWdpc3RlcihhZGRTb2NrZXRMaXN0ZW5lcihzb2NrZXQsICdlcnJvcicsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRldGFjaChhZGRvblRlcm1pbmFsLCBzb2NrZXQpOyB9KSk7XG59XG5leHBvcnRzLmF0dGFjaCA9IGF0dGFjaDtcbmZ1bmN0aW9uIGFkZFNvY2tldExpc3RlbmVyKHNvY2tldCwgdHlwZSwgaGFuZGxlcikge1xuICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgaGFuZGxlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gZGV0YWNoKHRlcm0sIHNvY2tldCkge1xuICAgIHZhciBhZGRvblRlcm1pbmFsID0gdGVybTtcbiAgICBhZGRvblRlcm1pbmFsLm9mZignZGF0YScsIGFkZG9uVGVybWluYWwuX19zZW5kRGF0YSk7XG4gICAgc29ja2V0ID0gKHR5cGVvZiBzb2NrZXQgPT09ICd1bmRlZmluZWQnKSA/IGFkZG9uVGVybWluYWwuX19zb2NrZXQgOiBzb2NrZXQ7XG4gICAgaWYgKHNvY2tldCkge1xuICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGFkZG9uVGVybWluYWwuX19nZXRNZXNzYWdlKTtcbiAgICB9XG4gICAgZGVsZXRlIGFkZG9uVGVybWluYWwuX19zb2NrZXQ7XG59XG5leHBvcnRzLmRldGFjaCA9IGRldGFjaDtcbmZ1bmN0aW9uIGFwcGx5KHRlcm1pbmFsQ29uc3RydWN0b3IpIHtcbiAgICB0ZXJtaW5hbENvbnN0cnVjdG9yLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAoc29ja2V0LCBiaWRpcmVjdGlvbmFsLCBidWZmZXJlZCkge1xuICAgICAgICBhdHRhY2godGhpcywgc29ja2V0LCBiaWRpcmVjdGlvbmFsLCBidWZmZXJlZCk7XG4gICAgfTtcbiAgICB0ZXJtaW5hbENvbnN0cnVjdG9yLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoc29ja2V0KSB7XG4gICAgICAgIGRldGFjaCh0aGlzLCBzb2NrZXQpO1xuICAgIH07XG59XG5leHBvcnRzLmFwcGx5ID0gYXBwbHk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdHRhY2guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBwcm9wb3NlR2VvbWV0cnkodGVybSkge1xuICAgIGlmICghdGVybS5lbGVtZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBwYXJlbnRFbGVtZW50U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0ZXJtLmVsZW1lbnQucGFyZW50RWxlbWVudCk7XG4gICAgdmFyIHBhcmVudEVsZW1lbnRIZWlnaHQgPSBwYXJzZUludChwYXJlbnRFbGVtZW50U3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnaGVpZ2h0JykpO1xuICAgIHZhciBwYXJlbnRFbGVtZW50V2lkdGggPSBNYXRoLm1heCgwLCBwYXJzZUludChwYXJlbnRFbGVtZW50U3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnd2lkdGgnKSkpO1xuICAgIHZhciBlbGVtZW50U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0ZXJtLmVsZW1lbnQpO1xuICAgIHZhciBlbGVtZW50UGFkZGluZyA9IHtcbiAgICAgICAgdG9wOiBwYXJzZUludChlbGVtZW50U3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy10b3AnKSksXG4gICAgICAgIGJvdHRvbTogcGFyc2VJbnQoZWxlbWVudFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3BhZGRpbmctYm90dG9tJykpLFxuICAgICAgICByaWdodDogcGFyc2VJbnQoZWxlbWVudFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3BhZGRpbmctcmlnaHQnKSksXG4gICAgICAgIGxlZnQ6IHBhcnNlSW50KGVsZW1lbnRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdwYWRkaW5nLWxlZnQnKSlcbiAgICB9O1xuICAgIHZhciBlbGVtZW50UGFkZGluZ1ZlciA9IGVsZW1lbnRQYWRkaW5nLnRvcCArIGVsZW1lbnRQYWRkaW5nLmJvdHRvbTtcbiAgICB2YXIgZWxlbWVudFBhZGRpbmdIb3IgPSBlbGVtZW50UGFkZGluZy5yaWdodCArIGVsZW1lbnRQYWRkaW5nLmxlZnQ7XG4gICAgdmFyIGF2YWlsYWJsZUhlaWdodCA9IHBhcmVudEVsZW1lbnRIZWlnaHQgLSBlbGVtZW50UGFkZGluZ1ZlcjtcbiAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSBwYXJlbnRFbGVtZW50V2lkdGggLSBlbGVtZW50UGFkZGluZ0hvciAtIHRlcm0uX2NvcmUudmlld3BvcnQuc2Nyb2xsQmFyV2lkdGg7XG4gICAgdmFyIGdlb21ldHJ5ID0ge1xuICAgICAgICBjb2xzOiBNYXRoLmZsb29yKGF2YWlsYWJsZVdpZHRoIC8gdGVybS5fY29yZS5yZW5kZXJlci5kaW1lbnNpb25zLmFjdHVhbENlbGxXaWR0aCksXG4gICAgICAgIHJvd3M6IE1hdGguZmxvb3IoYXZhaWxhYmxlSGVpZ2h0IC8gdGVybS5fY29yZS5yZW5kZXJlci5kaW1lbnNpb25zLmFjdHVhbENlbGxIZWlnaHQpXG4gICAgfTtcbiAgICByZXR1cm4gZ2VvbWV0cnk7XG59XG5leHBvcnRzLnByb3Bvc2VHZW9tZXRyeSA9IHByb3Bvc2VHZW9tZXRyeTtcbmZ1bmN0aW9uIGZpdCh0ZXJtKSB7XG4gICAgdmFyIGdlb21ldHJ5ID0gcHJvcG9zZUdlb21ldHJ5KHRlcm0pO1xuICAgIGlmIChnZW9tZXRyeSkge1xuICAgICAgICBpZiAodGVybS5yb3dzICE9PSBnZW9tZXRyeS5yb3dzIHx8IHRlcm0uY29scyAhPT0gZ2VvbWV0cnkuY29scykge1xuICAgICAgICAgICAgdGVybS5fY29yZS5yZW5kZXJlci5jbGVhcigpO1xuICAgICAgICAgICAgdGVybS5yZXNpemUoZ2VvbWV0cnkuY29scywgZ2VvbWV0cnkucm93cyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmZpdCA9IGZpdDtcbmZ1bmN0aW9uIGFwcGx5KHRlcm1pbmFsQ29uc3RydWN0b3IpIHtcbiAgICB0ZXJtaW5hbENvbnN0cnVjdG9yLnByb3RvdHlwZS5wcm9wb3NlR2VvbWV0cnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwcm9wb3NlR2VvbWV0cnkodGhpcyk7XG4gICAgfTtcbiAgICB0ZXJtaW5hbENvbnN0cnVjdG9yLnByb3RvdHlwZS5maXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZpdCh0aGlzKTtcbiAgICB9O1xufVxuZXhwb3J0cy5hcHBseSA9IGFwcGx5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zml0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gdG9nZ2xlRnVsbFNjcmVlbih0ZXJtLCBmdWxsc2NyZWVuKSB7XG4gICAgdmFyIGZuO1xuICAgIGlmICh0eXBlb2YgZnVsbHNjcmVlbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZm4gPSAodGVybS5lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnZnVsbHNjcmVlbicpKSA/ICdyZW1vdmUnIDogJ2FkZCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFmdWxsc2NyZWVuKSB7XG4gICAgICAgIGZuID0gJ3JlbW92ZSc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmbiA9ICdhZGQnO1xuICAgIH1cbiAgICB0ZXJtLmVsZW1lbnQuY2xhc3NMaXN0W2ZuXSgnZnVsbHNjcmVlbicpO1xufVxuZXhwb3J0cy50b2dnbGVGdWxsU2NyZWVuID0gdG9nZ2xlRnVsbFNjcmVlbjtcbmZ1bmN0aW9uIGFwcGx5KHRlcm1pbmFsQ29uc3RydWN0b3IpIHtcbiAgICB0ZXJtaW5hbENvbnN0cnVjdG9yLnByb3RvdHlwZS50b2dnbGVGdWxsU2NyZWVuID0gZnVuY3Rpb24gKGZ1bGxzY3JlZW4pIHtcbiAgICAgICAgdG9nZ2xlRnVsbFNjcmVlbih0aGlzLCBmdWxsc2NyZWVuKTtcbiAgICB9O1xufVxuZXhwb3J0cy5hcHBseSA9IGFwcGx5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnVsbHNjcmVlbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBub25Xb3JkQ2hhcmFjdGVycyA9ICcgfiFAIyQlXiYqKClfK2AtPVtde318XFw7OlwiXFwnLC4vPD4/JztcbnZhciBTZWFyY2hIZWxwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlYXJjaEhlbHBlcihfdGVybWluYWwpIHtcbiAgICAgICAgdGhpcy5fdGVybWluYWwgPSBfdGVybWluYWw7XG4gICAgfVxuICAgIFNlYXJjaEhlbHBlci5wcm90b3R5cGUuZmluZE5leHQgPSBmdW5jdGlvbiAodGVybSwgc2VhcmNoT3B0aW9ucykge1xuICAgICAgICBpZiAoIXRlcm0gfHwgdGVybS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgc3RhcnRSb3cgPSB0aGlzLl90ZXJtaW5hbC5fY29yZS5idWZmZXIueWRpc3A7XG4gICAgICAgIGlmICh0aGlzLl90ZXJtaW5hbC5fY29yZS5zZWxlY3Rpb25NYW5hZ2VyLnNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgc3RhcnRSb3cgPSB0aGlzLl90ZXJtaW5hbC5fY29yZS5zZWxlY3Rpb25NYW5hZ2VyLnNlbGVjdGlvbkVuZFsxXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciB5ID0gc3RhcnRSb3cgKyAxOyB5IDwgdGhpcy5fdGVybWluYWwuX2NvcmUuYnVmZmVyLnliYXNlICsgdGhpcy5fdGVybWluYWwucm93czsgeSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9maW5kSW5MaW5lKHRlcm0sIHksIHNlYXJjaE9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHN0YXJ0Um93OyB5KyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9maW5kSW5MaW5lKHRlcm0sIHksIHNlYXJjaE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RSZXN1bHQocmVzdWx0KTtcbiAgICB9O1xuICAgIFNlYXJjaEhlbHBlci5wcm90b3R5cGUuZmluZFByZXZpb3VzID0gZnVuY3Rpb24gKHRlcm0sIHNlYXJjaE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0ZXJtIHx8IHRlcm0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHN0YXJ0Um93ID0gdGhpcy5fdGVybWluYWwuX2NvcmUuYnVmZmVyLnlkaXNwO1xuICAgICAgICBpZiAodGhpcy5fdGVybWluYWwuX2NvcmUuc2VsZWN0aW9uTWFuYWdlci5zZWxlY3Rpb25TdGFydCkge1xuICAgICAgICAgICAgc3RhcnRSb3cgPSB0aGlzLl90ZXJtaW5hbC5fY29yZS5zZWxlY3Rpb25NYW5hZ2VyLnNlbGVjdGlvblN0YXJ0WzFdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHkgPSBzdGFydFJvdyAtIDE7IHkgPj0gMDsgeS0tKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9maW5kSW5MaW5lKHRlcm0sIHksIHNlYXJjaE9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gdGhpcy5fdGVybWluYWwuX2NvcmUuYnVmZmVyLnliYXNlICsgdGhpcy5fdGVybWluYWwucm93cyAtIDE7IHkgPiBzdGFydFJvdzsgeS0tKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fZmluZEluTGluZSh0ZXJtLCB5LCBzZWFyY2hPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0UmVzdWx0KHJlc3VsdCk7XG4gICAgfTtcbiAgICBTZWFyY2hIZWxwZXIucHJvdG90eXBlLl9pc1dob2xlV29yZCA9IGZ1bmN0aW9uIChzZWFyY2hJbmRleCwgbGluZSwgdGVybSkge1xuICAgICAgICByZXR1cm4gKCgoc2VhcmNoSW5kZXggPT09IDApIHx8IChub25Xb3JkQ2hhcmFjdGVycy5pbmRleE9mKGxpbmVbc2VhcmNoSW5kZXggLSAxXSkgIT09IC0xKSkgJiZcbiAgICAgICAgICAgICgoKHNlYXJjaEluZGV4ICsgdGVybS5sZW5ndGgpID09PSBsaW5lLmxlbmd0aCkgfHwgKG5vbldvcmRDaGFyYWN0ZXJzLmluZGV4T2YobGluZVtzZWFyY2hJbmRleCArIHRlcm0ubGVuZ3RoXSkgIT09IC0xKSkpO1xuICAgIH07XG4gICAgU2VhcmNoSGVscGVyLnByb3RvdHlwZS5fZmluZEluTGluZSA9IGZ1bmN0aW9uICh0ZXJtLCB5LCBzZWFyY2hPcHRpb25zKSB7XG4gICAgICAgIGlmIChzZWFyY2hPcHRpb25zID09PSB2b2lkIDApIHsgc2VhcmNoT3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIGlmICh0aGlzLl90ZXJtaW5hbC5fY29yZS5idWZmZXIubGluZXMuZ2V0KHkpLmlzV3JhcHBlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJpbmdMaW5lID0gdGhpcy50cmFuc2xhdGVCdWZmZXJMaW5lVG9TdHJpbmdXaXRoV3JhcCh5LCB0cnVlKTtcbiAgICAgICAgdmFyIHNlYXJjaFN0cmluZ0xpbmUgPSBzZWFyY2hPcHRpb25zLmNhc2VTZW5zaXRpdmUgPyBzdHJpbmdMaW5lIDogc3RyaW5nTGluZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgc2VhcmNoVGVybSA9IHNlYXJjaE9wdGlvbnMuY2FzZVNlbnNpdGl2ZSA/IHRlcm0gOiB0ZXJtLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBzZWFyY2hJbmRleCA9IC0xO1xuICAgICAgICBpZiAoc2VhcmNoT3B0aW9ucy5yZWdleCkge1xuICAgICAgICAgICAgdmFyIHNlYXJjaFJlZ2V4ID0gUmVnRXhwKHNlYXJjaFRlcm0sICdnJyk7XG4gICAgICAgICAgICB2YXIgZm91bmRUZXJtID0gc2VhcmNoUmVnZXguZXhlYyhzZWFyY2hTdHJpbmdMaW5lKTtcbiAgICAgICAgICAgIGlmIChmb3VuZFRlcm0gJiYgZm91bmRUZXJtWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzZWFyY2hJbmRleCA9IHNlYXJjaFJlZ2V4Lmxhc3RJbmRleCAtIGZvdW5kVGVybVswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdGVybSA9IGZvdW5kVGVybVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlYXJjaEluZGV4ID0gc2VhcmNoU3RyaW5nTGluZS5pbmRleE9mKHNlYXJjaFRlcm0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWFyY2hJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICBpZiAoc2VhcmNoSW5kZXggPj0gdGhpcy5fdGVybWluYWwuY29scykge1xuICAgICAgICAgICAgICAgIHkgKz0gTWF0aC5mbG9vcihzZWFyY2hJbmRleCAvIHRoaXMuX3Rlcm1pbmFsLmNvbHMpO1xuICAgICAgICAgICAgICAgIHNlYXJjaEluZGV4ID0gc2VhcmNoSW5kZXggJSB0aGlzLl90ZXJtaW5hbC5jb2xzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlYXJjaE9wdGlvbnMud2hvbGVXb3JkICYmICF0aGlzLl9pc1dob2xlV29yZChzZWFyY2hJbmRleCwgc2VhcmNoU3RyaW5nTGluZSwgdGVybSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGluZSA9IHRoaXMuX3Rlcm1pbmFsLl9jb3JlLmJ1ZmZlci5saW5lcy5nZXQoeSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlYXJjaEluZGV4OyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhckRhdGEgPSBsaW5lLmdldChpKTtcbiAgICAgICAgICAgICAgICB2YXIgY2hhciA9IGNoYXJEYXRhWzFdO1xuICAgICAgICAgICAgICAgIGlmIChjaGFyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VhcmNoSW5kZXggLT0gY2hhci5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY2hhcldpZHRoID0gY2hhckRhdGFbMl07XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzZWFyY2hJbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGVybTogdGVybSxcbiAgICAgICAgICAgICAgICBjb2w6IHNlYXJjaEluZGV4LFxuICAgICAgICAgICAgICAgIHJvdzogeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2VhcmNoSGVscGVyLnByb3RvdHlwZS50cmFuc2xhdGVCdWZmZXJMaW5lVG9TdHJpbmdXaXRoV3JhcCA9IGZ1bmN0aW9uIChsaW5lSW5kZXgsIHRyaW1SaWdodCkge1xuICAgICAgICB2YXIgbGluZVN0cmluZyA9ICcnO1xuICAgICAgICB2YXIgbGluZVdyYXBzVG9OZXh0O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgbmV4dExpbmUgPSB0aGlzLl90ZXJtaW5hbC5fY29yZS5idWZmZXIubGluZXMuZ2V0KGxpbmVJbmRleCArIDEpO1xuICAgICAgICAgICAgbGluZVdyYXBzVG9OZXh0ID0gbmV4dExpbmUgPyBuZXh0TGluZS5pc1dyYXBwZWQgOiBmYWxzZTtcbiAgICAgICAgICAgIGxpbmVTdHJpbmcgKz0gdGhpcy5fdGVybWluYWwuX2NvcmUuYnVmZmVyLnRyYW5zbGF0ZUJ1ZmZlckxpbmVUb1N0cmluZyhsaW5lSW5kZXgsICFsaW5lV3JhcHNUb05leHQgJiYgdHJpbVJpZ2h0KTtcbiAgICAgICAgICAgIGxpbmVJbmRleCsrO1xuICAgICAgICB9IHdoaWxlIChsaW5lV3JhcHNUb05leHQpO1xuICAgICAgICByZXR1cm4gbGluZVN0cmluZztcbiAgICB9O1xuICAgIFNlYXJjaEhlbHBlci5wcm90b3R5cGUuX3NlbGVjdFJlc3VsdCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90ZXJtaW5hbC5fY29yZS5zZWxlY3Rpb25NYW5hZ2VyLnNldFNlbGVjdGlvbihyZXN1bHQuY29sLCByZXN1bHQucm93LCByZXN1bHQudGVybS5sZW5ndGgpO1xuICAgICAgICB0aGlzLl90ZXJtaW5hbC5zY3JvbGxMaW5lcyhyZXN1bHQucm93IC0gdGhpcy5fdGVybWluYWwuX2NvcmUuYnVmZmVyLnlkaXNwKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gU2VhcmNoSGVscGVyO1xufSgpKTtcbmV4cG9ydHMuU2VhcmNoSGVscGVyID0gU2VhcmNoSGVscGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2VhcmNoSGVscGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFNlYXJjaEhlbHBlcl8xID0gcmVxdWlyZShcIi4vU2VhcmNoSGVscGVyXCIpO1xuZnVuY3Rpb24gZmluZE5leHQodGVybWluYWwsIHRlcm0sIHNlYXJjaE9wdGlvbnMpIHtcbiAgICBpZiAoc2VhcmNoT3B0aW9ucyA9PT0gdm9pZCAwKSB7IHNlYXJjaE9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBhZGRvblRlcm1pbmFsID0gdGVybWluYWw7XG4gICAgaWYgKCFhZGRvblRlcm1pbmFsLl9fc2VhcmNoSGVscGVyKSB7XG4gICAgICAgIGFkZG9uVGVybWluYWwuX19zZWFyY2hIZWxwZXIgPSBuZXcgU2VhcmNoSGVscGVyXzEuU2VhcmNoSGVscGVyKGFkZG9uVGVybWluYWwpO1xuICAgIH1cbiAgICByZXR1cm4gYWRkb25UZXJtaW5hbC5fX3NlYXJjaEhlbHBlci5maW5kTmV4dCh0ZXJtLCBzZWFyY2hPcHRpb25zKTtcbn1cbmV4cG9ydHMuZmluZE5leHQgPSBmaW5kTmV4dDtcbmZ1bmN0aW9uIGZpbmRQcmV2aW91cyh0ZXJtaW5hbCwgdGVybSwgc2VhcmNoT3B0aW9ucykge1xuICAgIHZhciBhZGRvblRlcm1pbmFsID0gdGVybWluYWw7XG4gICAgaWYgKCFhZGRvblRlcm1pbmFsLl9fc2VhcmNoSGVscGVyKSB7XG4gICAgICAgIGFkZG9uVGVybWluYWwuX19zZWFyY2hIZWxwZXIgPSBuZXcgU2VhcmNoSGVscGVyXzEuU2VhcmNoSGVscGVyKGFkZG9uVGVybWluYWwpO1xuICAgIH1cbiAgICByZXR1cm4gYWRkb25UZXJtaW5hbC5fX3NlYXJjaEhlbHBlci5maW5kUHJldmlvdXModGVybSwgc2VhcmNoT3B0aW9ucyk7XG59XG5leHBvcnRzLmZpbmRQcmV2aW91cyA9IGZpbmRQcmV2aW91cztcbmZ1bmN0aW9uIGFwcGx5KHRlcm1pbmFsQ29uc3RydWN0b3IpIHtcbiAgICB0ZXJtaW5hbENvbnN0cnVjdG9yLnByb3RvdHlwZS5maW5kTmV4dCA9IGZ1bmN0aW9uICh0ZXJtLCBzZWFyY2hPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBmaW5kTmV4dCh0aGlzLCB0ZXJtLCBzZWFyY2hPcHRpb25zKTtcbiAgICB9O1xuICAgIHRlcm1pbmFsQ29uc3RydWN0b3IucHJvdG90eXBlLmZpbmRQcmV2aW91cyA9IGZ1bmN0aW9uICh0ZXJtLCBzZWFyY2hPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBmaW5kUHJldmlvdXModGhpcywgdGVybSwgc2VhcmNoT3B0aW9ucyk7XG4gICAgfTtcbn1cbmV4cG9ydHMuYXBwbHkgPSBhcHBseTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlYXJjaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBwcm90b2NvbENsYXVzZSA9ICcoaHR0cHM/OlxcXFwvXFxcXC8pJztcbnZhciBkb21haW5DaGFyYWN0ZXJTZXQgPSAnW1xcXFxkYS16XFxcXC4tXSsnO1xudmFyIG5lZ2F0ZWREb21haW5DaGFyYWN0ZXJTZXQgPSAnW15cXFxcZGEtelxcXFwuLV0rJztcbnZhciBkb21haW5Cb2R5Q2xhdXNlID0gJygnICsgZG9tYWluQ2hhcmFjdGVyU2V0ICsgJyknO1xudmFyIHRsZENsYXVzZSA9ICcoW2EtelxcXFwuXXsyLDZ9KSc7XG52YXIgaXBDbGF1c2UgPSAnKChcXFxcZHsxLDN9XFxcXC4pezN9XFxcXGR7MSwzfSknO1xudmFyIGxvY2FsSG9zdENsYXVzZSA9ICcobG9jYWxob3N0KSc7XG52YXIgcG9ydENsYXVzZSA9ICcoOlxcXFxkezEsNX0pJztcbnZhciBob3N0Q2xhdXNlID0gJygoJyArIGRvbWFpbkJvZHlDbGF1c2UgKyAnXFxcXC4nICsgdGxkQ2xhdXNlICsgJyl8JyArIGlwQ2xhdXNlICsgJ3wnICsgbG9jYWxIb3N0Q2xhdXNlICsgJyknICsgcG9ydENsYXVzZSArICc/JztcbnZhciBwYXRoQ2xhdXNlID0gJyhcXFxcL1tcXFxcL1xcXFx3XFxcXC5cXFxcLSV+XSopKic7XG52YXIgcXVlcnlTdHJpbmdIYXNoRnJhZ21lbnRDaGFyYWN0ZXJTZXQgPSAnWzAtOVxcXFx3XFxcXFtcXFxcXVxcXFwoXFxcXClcXFxcL1xcXFw/XFxcXCEjQCQlJlxcJyorLDo7flxcXFw9XFxcXC5cXFxcLV0qJztcbnZhciBxdWVyeVN0cmluZ0NsYXVzZSA9ICcoXFxcXD8nICsgcXVlcnlTdHJpbmdIYXNoRnJhZ21lbnRDaGFyYWN0ZXJTZXQgKyAnKT8nO1xudmFyIGhhc2hGcmFnbWVudENsYXVzZSA9ICcoIycgKyBxdWVyeVN0cmluZ0hhc2hGcmFnbWVudENoYXJhY3RlclNldCArICcpPyc7XG52YXIgbmVnYXRlZFBhdGhDaGFyYWN0ZXJTZXQgPSAnW15cXFxcL1xcXFx3XFxcXC5cXFxcLSVdKyc7XG52YXIgYm9keUNsYXVzZSA9IGhvc3RDbGF1c2UgKyBwYXRoQ2xhdXNlICsgcXVlcnlTdHJpbmdDbGF1c2UgKyBoYXNoRnJhZ21lbnRDbGF1c2U7XG52YXIgc3RhcnQgPSAnKD86XnwnICsgbmVnYXRlZERvbWFpbkNoYXJhY3RlclNldCArICcpKCc7XG52YXIgZW5kID0gJykoJHwnICsgbmVnYXRlZFBhdGhDaGFyYWN0ZXJTZXQgKyAnKSc7XG52YXIgc3RyaWN0VXJsUmVnZXggPSBuZXcgUmVnRXhwKHN0YXJ0ICsgcHJvdG9jb2xDbGF1c2UgKyBib2R5Q2xhdXNlICsgZW5kKTtcbmZ1bmN0aW9uIGhhbmRsZUxpbmsoZXZlbnQsIHVyaSkge1xuICAgIHdpbmRvdy5vcGVuKHVyaSwgJ19ibGFuaycpO1xufVxuZnVuY3Rpb24gd2ViTGlua3NJbml0KHRlcm0sIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAoaGFuZGxlciA9PT0gdm9pZCAwKSB7IGhhbmRsZXIgPSBoYW5kbGVMaW5rOyB9XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICBvcHRpb25zLm1hdGNoSW5kZXggPSAxO1xuICAgIHRlcm0ucmVnaXN0ZXJMaW5rTWF0Y2hlcihzdHJpY3RVcmxSZWdleCwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5leHBvcnRzLndlYkxpbmtzSW5pdCA9IHdlYkxpbmtzSW5pdDtcbmZ1bmN0aW9uIGFwcGx5KHRlcm1pbmFsQ29uc3RydWN0b3IpIHtcbiAgICB0ZXJtaW5hbENvbnN0cnVjdG9yLnByb3RvdHlwZS53ZWJMaW5rc0luaXQgPSBmdW5jdGlvbiAoaGFuZGxlciwgb3B0aW9ucykge1xuICAgICAgICB3ZWJMaW5rc0luaXQodGhpcywgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgfTtcbn1cbmV4cG9ydHMuYXBwbHkgPSBhcHBseTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYkxpbmtzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIENIQVJfREFUQV9DT0RFX0lOREVYID0gMztcbnZhciBOVUxMX0NFTExfQ09ERSA9IDMyO1xuZnVuY3Rpb24gd2lucHR5Q29tcGF0SW5pdCh0ZXJtaW5hbCkge1xuICAgIHZhciBhZGRvblRlcm1pbmFsID0gdGVybWluYWw7XG4gICAgdmFyIGlzV2luZG93cyA9IFsnV2luZG93cycsICdXaW4xNicsICdXaW4zMicsICdXaW5DRSddLmluZGV4T2YobmF2aWdhdG9yLnBsYXRmb3JtKSA+PSAwO1xuICAgIGlmICghaXNXaW5kb3dzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYWRkb25UZXJtaW5hbC5vbignbGluZWZlZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsaW5lID0gYWRkb25UZXJtaW5hbC5fY29yZS5idWZmZXIubGluZXMuZ2V0KGFkZG9uVGVybWluYWwuX2NvcmUuYnVmZmVyLnliYXNlICsgYWRkb25UZXJtaW5hbC5fY29yZS5idWZmZXIueSAtIDEpO1xuICAgICAgICB2YXIgbGFzdENoYXIgPSBsaW5lLmdldChhZGRvblRlcm1pbmFsLmNvbHMgLSAxKTtcbiAgICAgICAgaWYgKGxhc3RDaGFyW0NIQVJfREFUQV9DT0RFX0lOREVYXSAhPT0gTlVMTF9DRUxMX0NPREUpIHtcbiAgICAgICAgICAgIHZhciBuZXh0TGluZSA9IGFkZG9uVGVybWluYWwuX2NvcmUuYnVmZmVyLmxpbmVzLmdldChhZGRvblRlcm1pbmFsLl9jb3JlLmJ1ZmZlci55YmFzZSArIGFkZG9uVGVybWluYWwuX2NvcmUuYnVmZmVyLnkpO1xuICAgICAgICAgICAgbmV4dExpbmUuaXNXcmFwcGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy53aW5wdHlDb21wYXRJbml0ID0gd2lucHR5Q29tcGF0SW5pdDtcbmZ1bmN0aW9uIGFwcGx5KHRlcm1pbmFsQ29uc3RydWN0b3IpIHtcbiAgICB0ZXJtaW5hbENvbnN0cnVjdG9yLnByb3RvdHlwZS53aW5wdHlDb21wYXRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aW5wdHlDb21wYXRJbml0KHRoaXMpO1xuICAgIH07XG59XG5leHBvcnRzLmFwcGx5ID0gYXBwbHk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aW5wdHlDb21wYXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEV2ZW50RW1pdHRlcl8xID0gcmVxdWlyZShcIi4vRXZlbnRFbWl0dGVyXCIpO1xudmFyIENpcmN1bGFyTGlzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENpcmN1bGFyTGlzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDaXJjdWxhckxpc3QoX21heExlbmd0aCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fbWF4TGVuZ3RoID0gX21heExlbmd0aDtcbiAgICAgICAgX3RoaXMuX2FycmF5ID0gbmV3IEFycmF5KF90aGlzLl9tYXhMZW5ndGgpO1xuICAgICAgICBfdGhpcy5fc3RhcnRJbmRleCA9IDA7XG4gICAgICAgIF90aGlzLl9sZW5ndGggPSAwO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaXJjdWxhckxpc3QucHJvdG90eXBlLCBcIm1heExlbmd0aFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21heExlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3TWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbWF4TGVuZ3RoID09PSBuZXdNYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmV3QXJyYXkgPSBuZXcgQXJyYXkobmV3TWF4TGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTWF0aC5taW4obmV3TWF4TGVuZ3RoLCB0aGlzLmxlbmd0aCk7IGkrKykge1xuICAgICAgICAgICAgICAgIG5ld0FycmF5W2ldID0gdGhpcy5fYXJyYXlbdGhpcy5fZ2V0Q3ljbGljSW5kZXgoaSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYXJyYXkgPSBuZXdBcnJheTtcbiAgICAgICAgICAgIHRoaXMuX21heExlbmd0aCA9IG5ld01heExlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0SW5kZXggPSAwO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2lyY3VsYXJMaXN0LnByb3RvdHlwZSwgXCJsZW5ndGhcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0xlbmd0aCkge1xuICAgICAgICAgICAgaWYgKG5ld0xlbmd0aCA+IHRoaXMuX2xlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9sZW5ndGg7IGkgPCBuZXdMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcnJheVtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sZW5ndGggPSBuZXdMZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIENpcmN1bGFyTGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcnJheVt0aGlzLl9nZXRDeWNsaWNJbmRleChpbmRleCldO1xuICAgIH07XG4gICAgQ2lyY3VsYXJMaXN0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2FycmF5W3RoaXMuX2dldEN5Y2xpY0luZGV4KGluZGV4KV0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIENpcmN1bGFyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9hcnJheVt0aGlzLl9nZXRDeWNsaWNJbmRleCh0aGlzLl9sZW5ndGgpXSA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fbGVuZ3RoID09PSB0aGlzLl9tYXhMZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0SW5kZXgrKztcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGFydEluZGV4ID09PSB0aGlzLl9tYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydEluZGV4ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdCgndHJpbScsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbGVuZ3RoKys7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENpcmN1bGFyTGlzdC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXJyYXlbdGhpcy5fZ2V0Q3ljbGljSW5kZXgodGhpcy5fbGVuZ3RoLS0gLSAxKV07XG4gICAgfTtcbiAgICBDaXJjdWxhckxpc3QucHJvdG90eXBlLnNwbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZGVsZXRlQ291bnQpIHtcbiAgICAgICAgdmFyIGl0ZW1zID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBpdGVtc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVsZXRlQ291bnQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IHRoaXMuX2xlbmd0aCAtIGRlbGV0ZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hcnJheVt0aGlzLl9nZXRDeWNsaWNJbmRleChpKV0gPSB0aGlzLl9hcnJheVt0aGlzLl9nZXRDeWNsaWNJbmRleChpICsgZGVsZXRlQ291bnQpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xlbmd0aCAtPSBkZWxldGVDb3VudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbXMgJiYgaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5fbGVuZ3RoIC0gMTsgaSA+PSBzdGFydDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXJyYXlbdGhpcy5fZ2V0Q3ljbGljSW5kZXgoaSArIGl0ZW1zLmxlbmd0aCldID0gdGhpcy5fYXJyYXlbdGhpcy5fZ2V0Q3ljbGljSW5kZXgoaSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FycmF5W3RoaXMuX2dldEN5Y2xpY0luZGV4KHN0YXJ0ICsgaSldID0gaXRlbXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fbGVuZ3RoICsgaXRlbXMubGVuZ3RoID4gdGhpcy5tYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY291bnRUb1RyaW0gPSAodGhpcy5fbGVuZ3RoICsgaXRlbXMubGVuZ3RoKSAtIHRoaXMubWF4TGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0SW5kZXggKz0gY291bnRUb1RyaW07XG4gICAgICAgICAgICAgICAgdGhpcy5fbGVuZ3RoID0gdGhpcy5tYXhMZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCd0cmltJywgY291bnRUb1RyaW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGVuZ3RoICs9IGl0ZW1zLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2lyY3VsYXJMaXN0LnByb3RvdHlwZS50cmltU3RhcnQgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICAgICAgaWYgKGNvdW50ID4gdGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgICAgICBjb3VudCA9IHRoaXMuX2xlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGFydEluZGV4ICs9IGNvdW50O1xuICAgICAgICB0aGlzLl9sZW5ndGggLT0gY291bnQ7XG4gICAgICAgIHRoaXMuZW1pdCgndHJpbScsIGNvdW50KTtcbiAgICB9O1xuICAgIENpcmN1bGFyTGlzdC5wcm90b3R5cGUuc2hpZnRFbGVtZW50cyA9IGZ1bmN0aW9uIChzdGFydCwgY291bnQsIG9mZnNldCkge1xuICAgICAgICBpZiAoY291bnQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0IGFyZ3VtZW50IG91dCBvZiByYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCArIG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNoaWZ0IGVsZW1lbnRzIGluIGxpc3QgYmV5b25kIGluZGV4IDAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGNvdW50IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldChzdGFydCArIGkgKyBvZmZzZXQsIHRoaXMuZ2V0KHN0YXJ0ICsgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGV4cGFuZExpc3RCeSA9IChzdGFydCArIGNvdW50ICsgb2Zmc2V0KSAtIHRoaXMuX2xlbmd0aDtcbiAgICAgICAgICAgIGlmIChleHBhbmRMaXN0QnkgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGVuZ3RoICs9IGV4cGFuZExpc3RCeTtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5fbGVuZ3RoID4gdGhpcy5tYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGVuZ3RoLS07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0SW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCd0cmltJywgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoc3RhcnQgKyBpICsgb2Zmc2V0LCB0aGlzLmdldChzdGFydCArIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2lyY3VsYXJMaXN0LnByb3RvdHlwZS5fZ2V0Q3ljbGljSW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9zdGFydEluZGV4ICsgaW5kZXgpICUgdGhpcy5tYXhMZW5ndGg7XG4gICAgfTtcbiAgICByZXR1cm4gQ2lyY3VsYXJMaXN0O1xufShFdmVudEVtaXR0ZXJfMS5FdmVudEVtaXR0ZXIpKTtcbmV4cG9ydHMuQ2lyY3VsYXJMaXN0ID0gQ2lyY3VsYXJMaXN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2lyY3VsYXJMaXN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBMaWZlY3ljbGVfMSA9IHJlcXVpcmUoXCIuL0xpZmVjeWNsZVwiKTtcbnZhciBFdmVudEVtaXR0ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFdmVudEVtaXR0ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fZXZlbnRzID0gX3RoaXMuX2V2ZW50cyB8fCB7fTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IHRoaXMuX2V2ZW50c1t0eXBlXSB8fCBbXTtcbiAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICAgIH07XG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGREaXNwb3NhYmxlTGlzdGVuZXIgPSBmdW5jdGlvbiAodHlwZSwgaGFuZGxlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLm9uKHR5cGUsIGhhbmRsZXIpO1xuICAgICAgICB2YXIgZGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGlzcG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5vZmYodHlwZSwgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgZGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2JqID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgICAgICB2YXIgaSA9IG9iai5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGlmIChvYmpbaV0gPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgb2JqLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2JqID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb2JqW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudHNbdHlwZV0gfHwgW107XG4gICAgfTtcbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICB9O1xuICAgIHJldHVybiBFdmVudEVtaXR0ZXI7XG59KExpZmVjeWNsZV8xLkRpc3Bvc2FibGUpKTtcbmV4cG9ydHMuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXZlbnRFbWl0dGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIERpc3Bvc2FibGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERpc3Bvc2FibGUoKSB7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2FibGVzID0gW107XG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgRGlzcG9zYWJsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2FibGVzLmZvckVhY2goZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgdGhpcy5fZGlzcG9zYWJsZXMubGVuZ3RoID0gMDtcbiAgICB9O1xuICAgIERpc3Bvc2FibGUucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdGhpcy5fZGlzcG9zYWJsZXMucHVzaChkKTtcbiAgICB9O1xuICAgIERpc3Bvc2FibGUucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9kaXNwb3NhYmxlcy5pbmRleE9mKGQpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNwb3NhYmxlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGlzcG9zYWJsZTtcbn0oKSk7XG5leHBvcnRzLkRpc3Bvc2FibGUgPSBEaXNwb3NhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGlmZWN5Y2xlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEMwO1xuKGZ1bmN0aW9uIChDMCkge1xuICAgIEMwLk5VTCA9ICdcXHgwMCc7XG4gICAgQzAuU09IID0gJ1xceDAxJztcbiAgICBDMC5TVFggPSAnXFx4MDInO1xuICAgIEMwLkVUWCA9ICdcXHgwMyc7XG4gICAgQzAuRU9UID0gJ1xceDA0JztcbiAgICBDMC5FTlEgPSAnXFx4MDUnO1xuICAgIEMwLkFDSyA9ICdcXHgwNic7XG4gICAgQzAuQkVMID0gJ1xceDA3JztcbiAgICBDMC5CUyA9ICdcXHgwOCc7XG4gICAgQzAuSFQgPSAnXFx4MDknO1xuICAgIEMwLkxGID0gJ1xceDBhJztcbiAgICBDMC5WVCA9ICdcXHgwYic7XG4gICAgQzAuRkYgPSAnXFx4MGMnO1xuICAgIEMwLkNSID0gJ1xceDBkJztcbiAgICBDMC5TTyA9ICdcXHgwZSc7XG4gICAgQzAuU0kgPSAnXFx4MGYnO1xuICAgIEMwLkRMRSA9ICdcXHgxMCc7XG4gICAgQzAuREMxID0gJ1xceDExJztcbiAgICBDMC5EQzIgPSAnXFx4MTInO1xuICAgIEMwLkRDMyA9ICdcXHgxMyc7XG4gICAgQzAuREM0ID0gJ1xceDE0JztcbiAgICBDMC5OQUsgPSAnXFx4MTUnO1xuICAgIEMwLlNZTiA9ICdcXHgxNic7XG4gICAgQzAuRVRCID0gJ1xceDE3JztcbiAgICBDMC5DQU4gPSAnXFx4MTgnO1xuICAgIEMwLkVNID0gJ1xceDE5JztcbiAgICBDMC5TVUIgPSAnXFx4MWEnO1xuICAgIEMwLkVTQyA9ICdcXHgxYic7XG4gICAgQzAuRlMgPSAnXFx4MWMnO1xuICAgIEMwLkdTID0gJ1xceDFkJztcbiAgICBDMC5SUyA9ICdcXHgxZSc7XG4gICAgQzAuVVMgPSAnXFx4MWYnO1xuICAgIEMwLlNQID0gJ1xceDIwJztcbiAgICBDMC5ERUwgPSAnXFx4N2YnO1xufSkoQzAgPSBleHBvcnRzLkMwIHx8IChleHBvcnRzLkMwID0ge30pKTtcbnZhciBDMTtcbihmdW5jdGlvbiAoQzEpIHtcbiAgICBDMS5QQUQgPSAnXFx4ODAnO1xuICAgIEMxLkhPUCA9ICdcXHg4MSc7XG4gICAgQzEuQlBIID0gJ1xceDgyJztcbiAgICBDMS5OQkggPSAnXFx4ODMnO1xuICAgIEMxLklORCA9ICdcXHg4NCc7XG4gICAgQzEuTkVMID0gJ1xceDg1JztcbiAgICBDMS5TU0EgPSAnXFx4ODYnO1xuICAgIEMxLkVTQSA9ICdcXHg4Nyc7XG4gICAgQzEuSFRTID0gJ1xceDg4JztcbiAgICBDMS5IVEogPSAnXFx4ODknO1xuICAgIEMxLlZUUyA9ICdcXHg4YSc7XG4gICAgQzEuUExEID0gJ1xceDhiJztcbiAgICBDMS5QTFUgPSAnXFx4OGMnO1xuICAgIEMxLlJJID0gJ1xceDhkJztcbiAgICBDMS5TUzIgPSAnXFx4OGUnO1xuICAgIEMxLlNTMyA9ICdcXHg4Zic7XG4gICAgQzEuRENTID0gJ1xceDkwJztcbiAgICBDMS5QVTEgPSAnXFx4OTEnO1xuICAgIEMxLlBVMiA9ICdcXHg5Mic7XG4gICAgQzEuU1RTID0gJ1xceDkzJztcbiAgICBDMS5DQ0ggPSAnXFx4OTQnO1xuICAgIEMxLk1XID0gJ1xceDk1JztcbiAgICBDMS5TUEEgPSAnXFx4OTYnO1xuICAgIEMxLkVQQSA9ICdcXHg5Nyc7XG4gICAgQzEuU09TID0gJ1xceDk4JztcbiAgICBDMS5TR0NJID0gJ1xceDk5JztcbiAgICBDMS5TQ0kgPSAnXFx4OWEnO1xuICAgIEMxLkNTSSA9ICdcXHg5Yic7XG4gICAgQzEuU1QgPSAnXFx4OWMnO1xuICAgIEMxLk9TQyA9ICdcXHg5ZCc7XG4gICAgQzEuUE0gPSAnXFx4OWUnO1xuICAgIEMxLkFQQyA9ICdcXHg5Zic7XG59KShDMSA9IGV4cG9ydHMuQzEgfHwgKGV4cG9ydHMuQzEgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXNjYXBlU2VxdWVuY2VzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DSEFSU0VUUyA9IHt9O1xuZXhwb3J0cy5ERUZBVUxUX0NIQVJTRVQgPSBleHBvcnRzLkNIQVJTRVRTWydCJ107XG5leHBvcnRzLkNIQVJTRVRTWycwJ10gPSB7XG4gICAgJ2AnOiAnXFx1MjVjNicsXG4gICAgJ2EnOiAnXFx1MjU5MicsXG4gICAgJ2InOiAnXFx1MDAwOScsXG4gICAgJ2MnOiAnXFx1MDAwYycsXG4gICAgJ2QnOiAnXFx1MDAwZCcsXG4gICAgJ2UnOiAnXFx1MDAwYScsXG4gICAgJ2YnOiAnXFx1MDBiMCcsXG4gICAgJ2cnOiAnXFx1MDBiMScsXG4gICAgJ2gnOiAnXFx1MjQyNCcsXG4gICAgJ2knOiAnXFx1MDAwYicsXG4gICAgJ2onOiAnXFx1MjUxOCcsXG4gICAgJ2snOiAnXFx1MjUxMCcsXG4gICAgJ2wnOiAnXFx1MjUwYycsXG4gICAgJ20nOiAnXFx1MjUxNCcsXG4gICAgJ24nOiAnXFx1MjUzYycsXG4gICAgJ28nOiAnXFx1MjNiYScsXG4gICAgJ3AnOiAnXFx1MjNiYicsXG4gICAgJ3EnOiAnXFx1MjUwMCcsXG4gICAgJ3InOiAnXFx1MjNiYycsXG4gICAgJ3MnOiAnXFx1MjNiZCcsXG4gICAgJ3QnOiAnXFx1MjUxYycsXG4gICAgJ3UnOiAnXFx1MjUyNCcsXG4gICAgJ3YnOiAnXFx1MjUzNCcsXG4gICAgJ3cnOiAnXFx1MjUyYycsXG4gICAgJ3gnOiAnXFx1MjUwMicsXG4gICAgJ3knOiAnXFx1MjI2NCcsXG4gICAgJ3onOiAnXFx1MjI2NScsXG4gICAgJ3snOiAnXFx1MDNjMCcsXG4gICAgJ3wnOiAnXFx1MjI2MCcsXG4gICAgJ30nOiAnXFx1MDBhMycsXG4gICAgJ34nOiAnXFx1MDBiNydcbn07XG5leHBvcnRzLkNIQVJTRVRTWydBJ10gPSB7XG4gICAgJyMnOiAnwqMnXG59O1xuZXhwb3J0cy5DSEFSU0VUU1snQiddID0gbnVsbDtcbmV4cG9ydHMuQ0hBUlNFVFNbJzQnXSA9IHtcbiAgICAnIyc6ICfCoycsXG4gICAgJ0AnOiAnwr4nLFxuICAgICdbJzogJ2lqJyxcbiAgICAnXFxcXCc6ICfCvScsXG4gICAgJ10nOiAnfCcsXG4gICAgJ3snOiAnwqgnLFxuICAgICd8JzogJ2YnLFxuICAgICd9JzogJ8K8JyxcbiAgICAnfic6ICfCtCdcbn07XG5leHBvcnRzLkNIQVJTRVRTWydDJ10gPVxuICAgIGV4cG9ydHMuQ0hBUlNFVFNbJzUnXSA9IHtcbiAgICAgICAgJ1snOiAnw4QnLFxuICAgICAgICAnXFxcXCc6ICfDlicsXG4gICAgICAgICddJzogJ8OFJyxcbiAgICAgICAgJ14nOiAnw5wnLFxuICAgICAgICAnYCc6ICfDqScsXG4gICAgICAgICd7JzogJ8OkJyxcbiAgICAgICAgJ3wnOiAnw7YnLFxuICAgICAgICAnfSc6ICfDpScsXG4gICAgICAgICd+JzogJ8O8J1xuICAgIH07XG5leHBvcnRzLkNIQVJTRVRTWydSJ10gPSB7XG4gICAgJyMnOiAnwqMnLFxuICAgICdAJzogJ8OgJyxcbiAgICAnWyc6ICfCsCcsXG4gICAgJ1xcXFwnOiAnw6cnLFxuICAgICddJzogJ8KnJyxcbiAgICAneyc6ICfDqScsXG4gICAgJ3wnOiAnw7knLFxuICAgICd9JzogJ8OoJyxcbiAgICAnfic6ICfCqCdcbn07XG5leHBvcnRzLkNIQVJTRVRTWydRJ10gPSB7XG4gICAgJ0AnOiAnw6AnLFxuICAgICdbJzogJ8OiJyxcbiAgICAnXFxcXCc6ICfDpycsXG4gICAgJ10nOiAnw6onLFxuICAgICdeJzogJ8OuJyxcbiAgICAnYCc6ICfDtCcsXG4gICAgJ3snOiAnw6knLFxuICAgICd8JzogJ8O5JyxcbiAgICAnfSc6ICfDqCcsXG4gICAgJ34nOiAnw7snXG59O1xuZXhwb3J0cy5DSEFSU0VUU1snSyddID0ge1xuICAgICdAJzogJ8KnJyxcbiAgICAnWyc6ICfDhCcsXG4gICAgJ1xcXFwnOiAnw5YnLFxuICAgICddJzogJ8OcJyxcbiAgICAneyc6ICfDpCcsXG4gICAgJ3wnOiAnw7YnLFxuICAgICd9JzogJ8O8JyxcbiAgICAnfic6ICfDnydcbn07XG5leHBvcnRzLkNIQVJTRVRTWydZJ10gPSB7XG4gICAgJyMnOiAnwqMnLFxuICAgICdAJzogJ8KnJyxcbiAgICAnWyc6ICfCsCcsXG4gICAgJ1xcXFwnOiAnw6cnLFxuICAgICddJzogJ8OpJyxcbiAgICAnYCc6ICfDuScsXG4gICAgJ3snOiAnw6AnLFxuICAgICd8JzogJ8OyJyxcbiAgICAnfSc6ICfDqCcsXG4gICAgJ34nOiAnw6wnXG59O1xuZXhwb3J0cy5DSEFSU0VUU1snRSddID1cbiAgICBleHBvcnRzLkNIQVJTRVRTWyc2J10gPSB7XG4gICAgICAgICdAJzogJ8OEJyxcbiAgICAgICAgJ1snOiAnw4YnLFxuICAgICAgICAnXFxcXCc6ICfDmCcsXG4gICAgICAgICddJzogJ8OFJyxcbiAgICAgICAgJ14nOiAnw5wnLFxuICAgICAgICAnYCc6ICfDpCcsXG4gICAgICAgICd7JzogJ8OmJyxcbiAgICAgICAgJ3wnOiAnw7gnLFxuICAgICAgICAnfSc6ICfDpScsXG4gICAgICAgICd+JzogJ8O8J1xuICAgIH07XG5leHBvcnRzLkNIQVJTRVRTWydaJ10gPSB7XG4gICAgJyMnOiAnwqMnLFxuICAgICdAJzogJ8KnJyxcbiAgICAnWyc6ICfCoScsXG4gICAgJ1xcXFwnOiAnw5EnLFxuICAgICddJzogJ8K/JyxcbiAgICAneyc6ICfCsCcsXG4gICAgJ3wnOiAnw7EnLFxuICAgICd9JzogJ8OnJ1xufTtcbmV4cG9ydHMuQ0hBUlNFVFNbJ0gnXSA9XG4gICAgZXhwb3J0cy5DSEFSU0VUU1snNyddID0ge1xuICAgICAgICAnQCc6ICfDiScsXG4gICAgICAgICdbJzogJ8OEJyxcbiAgICAgICAgJ1xcXFwnOiAnw5YnLFxuICAgICAgICAnXSc6ICfDhScsXG4gICAgICAgICdeJzogJ8OcJyxcbiAgICAgICAgJ2AnOiAnw6knLFxuICAgICAgICAneyc6ICfDpCcsXG4gICAgICAgICd8JzogJ8O2JyxcbiAgICAgICAgJ30nOiAnw6UnLFxuICAgICAgICAnfic6ICfDvCdcbiAgICB9O1xuZXhwb3J0cy5DSEFSU0VUU1snPSddID0ge1xuICAgICcjJzogJ8O5JyxcbiAgICAnQCc6ICfDoCcsXG4gICAgJ1snOiAnw6knLFxuICAgICdcXFxcJzogJ8OnJyxcbiAgICAnXSc6ICfDqicsXG4gICAgJ14nOiAnw64nLFxuICAgICdfJzogJ8OoJyxcbiAgICAnYCc6ICfDtCcsXG4gICAgJ3snOiAnw6QnLFxuICAgICd8JzogJ8O2JyxcbiAgICAnfSc6ICfDvCcsXG4gICAgJ34nOiAnw7snXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2hhcnNldHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRXNjYXBlU2VxdWVuY2VzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL2RhdGEvRXNjYXBlU2VxdWVuY2VzXCIpO1xudmFyIEtFWUNPREVfS0VZX01BUFBJTkdTID0ge1xuICAgIDQ4OiBbJzAnLCAnKSddLFxuICAgIDQ5OiBbJzEnLCAnISddLFxuICAgIDUwOiBbJzInLCAnQCddLFxuICAgIDUxOiBbJzMnLCAnIyddLFxuICAgIDUyOiBbJzQnLCAnJCddLFxuICAgIDUzOiBbJzUnLCAnJSddLFxuICAgIDU0OiBbJzYnLCAnXiddLFxuICAgIDU1OiBbJzcnLCAnJiddLFxuICAgIDU2OiBbJzgnLCAnKiddLFxuICAgIDU3OiBbJzknLCAnKCddLFxuICAgIDE4NjogWyc7JywgJzonXSxcbiAgICAxODc6IFsnPScsICcrJ10sXG4gICAgMTg4OiBbJywnLCAnPCddLFxuICAgIDE4OTogWyctJywgJ18nXSxcbiAgICAxOTA6IFsnLicsICc+J10sXG4gICAgMTkxOiBbJy8nLCAnPyddLFxuICAgIDE5MjogWydgJywgJ34nXSxcbiAgICAyMTk6IFsnWycsICd7J10sXG4gICAgMjIwOiBbJ1xcXFwnLCAnfCddLFxuICAgIDIyMTogWyddJywgJ30nXSxcbiAgICAyMjI6IFsnXFwnJywgJ1wiJ11cbn07XG5mdW5jdGlvbiBldmFsdWF0ZUtleWJvYXJkRXZlbnQoZXYsIGFwcGxpY2F0aW9uQ3Vyc29yTW9kZSwgaXNNYWMsIG1hY09wdGlvbklzTWV0YSkge1xuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIHR5cGU6IDAsXG4gICAgICAgIGNhbmNlbDogZmFsc2UsXG4gICAgICAgIGtleTogdW5kZWZpbmVkXG4gICAgfTtcbiAgICB2YXIgbW9kaWZpZXJzID0gKGV2LnNoaWZ0S2V5ID8gMSA6IDApIHwgKGV2LmFsdEtleSA/IDIgOiAwKSB8IChldi5jdHJsS2V5ID8gNCA6IDApIHwgKGV2Lm1ldGFLZXkgPyA4IDogMCk7XG4gICAgc3dpdGNoIChldi5rZXlDb2RlKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmIChldi5rZXkgPT09ICdVSUtleUlucHV0VXBBcnJvdycpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXBwbGljYXRpb25DdXJzb3JNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnT0EnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9IEVzY2FwZVNlcXVlbmNlc18xLkMwLkVTQyArICdbQSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXYua2V5ID09PSAnVUlLZXlJbnB1dExlZnRBcnJvdycpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXBwbGljYXRpb25DdXJzb3JNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnT0QnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9IEVzY2FwZVNlcXVlbmNlc18xLkMwLkVTQyArICdbRCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXYua2V5ID09PSAnVUlLZXlJbnB1dFJpZ2h0QXJyb3cnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFwcGxpY2F0aW9uQ3Vyc29yTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgJ09DJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnW0MnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2LmtleSA9PT0gJ1VJS2V5SW5wdXREb3duQXJyb3cnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFwcGxpY2F0aW9uQ3Vyc29yTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgJ09CJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnW0InO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBpZiAoZXYuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gRXNjYXBlU2VxdWVuY2VzXzEuQzAuQlM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldi5hbHRLZXkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgRXNjYXBlU2VxdWVuY2VzXzEuQzAuREVMO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LmtleSA9IEVzY2FwZVNlcXVlbmNlc18xLkMwLkRFTDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBpZiAoZXYuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgJ1taJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5IVDtcbiAgICAgICAgICAgIHJlc3VsdC5jYW5jZWwgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICByZXN1bHQua2V5ID0gRXNjYXBlU2VxdWVuY2VzXzEuQzAuQ1I7XG4gICAgICAgICAgICByZXN1bHQuY2FuY2VsID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgcmVzdWx0LmtleSA9IEVzY2FwZVNlcXVlbmNlc18xLkMwLkVTQztcbiAgICAgICAgICAgIHJlc3VsdC5jYW5jZWwgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9IEVzY2FwZVNlcXVlbmNlc18xLkMwLkVTQyArICdbMTsnICsgKG1vZGlmaWVycyArIDEpICsgJ0QnO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQua2V5ID09PSBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnWzE7M0QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBpc01hYyA/IEVzY2FwZVNlcXVlbmNlc18xLkMwLkVTQyArICdiJyA6IEVzY2FwZVNlcXVlbmNlc18xLkMwLkVTQyArICdbMTs1RCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXBwbGljYXRpb25DdXJzb3JNb2RlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9IEVzY2FwZVNlcXVlbmNlc18xLkMwLkVTQyArICdPRCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgJ1tEJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnWzE7JyArIChtb2RpZmllcnMgKyAxKSArICdDJztcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmtleSA9PT0gRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgJ1sxOzNDJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gaXNNYWMgPyBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnZicgOiBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnWzE7NUMnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFwcGxpY2F0aW9uQ3Vyc29yTW9kZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnT0MnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9IEVzY2FwZVNlcXVlbmNlc18xLkMwLkVTQyArICdbQyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgJ1sxOycgKyAobW9kaWZpZXJzICsgMSkgKyAnQSc7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5rZXkgPT09IEVzY2FwZVNlcXVlbmNlc18xLkMwLkVTQyArICdbMTszQScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9IEVzY2FwZVNlcXVlbmNlc18xLkMwLkVTQyArICdbMTs1QSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXBwbGljYXRpb25DdXJzb3JNb2RlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9IEVzY2FwZVNlcXVlbmNlc18xLkMwLkVTQyArICdPQSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgJ1tBJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnWzE7JyArIChtb2RpZmllcnMgKyAxKSArICdCJztcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmtleSA9PT0gRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgJ1sxOzNCJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgJ1sxOzVCJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhcHBsaWNhdGlvbkN1cnNvck1vZGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgJ09CJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnW0InO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDU6XG4gICAgICAgICAgICBpZiAoIWV2LnNoaWZ0S2V5ICYmICFldi5jdHJsS2V5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9IEVzY2FwZVNlcXVlbmNlc18xLkMwLkVTQyArICdbMn4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDY6XG4gICAgICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9IEVzY2FwZVNlcXVlbmNlc18xLkMwLkVTQyArICdbMzsnICsgKG1vZGlmaWVycyArIDEpICsgJ34nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9IEVzY2FwZVNlcXVlbmNlc18xLkMwLkVTQyArICdbM34nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzY6XG4gICAgICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9IEVzY2FwZVNlcXVlbmNlc18xLkMwLkVTQyArICdbMTsnICsgKG1vZGlmaWVycyArIDEpICsgJ0gnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXBwbGljYXRpb25DdXJzb3JNb2RlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9IEVzY2FwZVNlcXVlbmNlc18xLkMwLkVTQyArICdPSCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgJ1tIJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM1OlxuICAgICAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnWzE7JyArIChtb2RpZmllcnMgKyAxKSArICdGJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFwcGxpY2F0aW9uQ3Vyc29yTW9kZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnT0YnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9IEVzY2FwZVNlcXVlbmNlc18xLkMwLkVTQyArICdbRic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzMzpcbiAgICAgICAgICAgIGlmIChldi5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC50eXBlID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnWzV+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgaWYgKGV2LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnR5cGUgPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9IEVzY2FwZVNlcXVlbmNlc18xLkMwLkVTQyArICdbNn4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTEyOlxuICAgICAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnWzE7JyArIChtb2RpZmllcnMgKyAxKSArICdQJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnT1AnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTEzOlxuICAgICAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnWzE7JyArIChtb2RpZmllcnMgKyAxKSArICdRJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnT1EnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTE0OlxuICAgICAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnWzE7JyArIChtb2RpZmllcnMgKyAxKSArICdSJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnT1InO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTE1OlxuICAgICAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnWzE7JyArIChtb2RpZmllcnMgKyAxKSArICdTJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnT1MnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTE2OlxuICAgICAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnWzE1OycgKyAobW9kaWZpZXJzICsgMSkgKyAnfic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgJ1sxNX4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTE3OlxuICAgICAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnWzE3OycgKyAobW9kaWZpZXJzICsgMSkgKyAnfic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgJ1sxN34nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTE4OlxuICAgICAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnWzE4OycgKyAobW9kaWZpZXJzICsgMSkgKyAnfic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgJ1sxOH4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTE5OlxuICAgICAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnWzE5OycgKyAobW9kaWZpZXJzICsgMSkgKyAnfic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgJ1sxOX4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTIwOlxuICAgICAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnWzIwOycgKyAobW9kaWZpZXJzICsgMSkgKyAnfic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgJ1syMH4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTIxOlxuICAgICAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnWzIxOycgKyAobW9kaWZpZXJzICsgMSkgKyAnfic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgJ1syMX4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTIyOlxuICAgICAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnWzIzOycgKyAobW9kaWZpZXJzICsgMSkgKyAnfic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgJ1syM34nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTIzOlxuICAgICAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyAnWzI0OycgKyAobW9kaWZpZXJzICsgMSkgKyAnfic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgJ1syNH4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoZXYuY3RybEtleSAmJiAhZXYuc2hpZnRLZXkgJiYgIWV2LmFsdEtleSAmJiAhZXYubWV0YUtleSkge1xuICAgICAgICAgICAgICAgIGlmIChldi5rZXlDb2RlID49IDY1ICYmIGV2LmtleUNvZGUgPD0gOTApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZXYua2V5Q29kZSAtIDY0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXYua2V5Q29kZSA9PT0gMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2LmtleUNvZGUgPj0gNTEgJiYgZXYua2V5Q29kZSA8PSA1NSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gU3RyaW5nLmZyb21DaGFyQ29kZShldi5rZXlDb2RlIC0gNTEgKyAyNyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2LmtleUNvZGUgPT09IDU2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDEyNyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2LmtleUNvZGUgPT09IDIxOSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gU3RyaW5nLmZyb21DaGFyQ29kZSgyNyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2LmtleUNvZGUgPT09IDIyMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gU3RyaW5nLmZyb21DaGFyQ29kZSgyOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2LmtleUNvZGUgPT09IDIyMSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gU3RyaW5nLmZyb21DaGFyQ29kZSgyOSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKCFpc01hYyB8fCBtYWNPcHRpb25Jc01ldGEpICYmIGV2LmFsdEtleSAmJiAhZXYubWV0YUtleSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXlNYXBwaW5nID0gS0VZQ09ERV9LRVlfTUFQUElOR1NbZXYua2V5Q29kZV07XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleU1hcHBpbmcgJiYga2V5TWFwcGluZ1shZXYuc2hpZnRLZXkgPyAwIDogMV07XG4gICAgICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsga2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChldi5rZXlDb2RlID49IDY1ICYmIGV2LmtleUNvZGUgPD0gOTApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleUNvZGUgPSBldi5jdHJsS2V5ID8gZXYua2V5Q29kZSAtIDY0IDogZXYua2V5Q29kZSArIDMyO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gRXNjYXBlU2VxdWVuY2VzXzEuQzAuRVNDICsgU3RyaW5nLmZyb21DaGFyQ29kZShrZXlDb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc01hYyAmJiAhZXYuYWx0S2V5ICYmICFldi5jdHJsS2V5ICYmIGV2Lm1ldGFLZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXYua2V5Q29kZSA9PT0gNjUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnR5cGUgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5ldmFsdWF0ZUtleWJvYXJkRXZlbnQgPSBldmFsdWF0ZUtleWJvYXJkRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1LZXlib2FyZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBFc2NhcGVTZXF1ZW5jZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vZGF0YS9Fc2NhcGVTZXF1ZW5jZXNcIik7XG52YXIgQWx0Q2xpY2tIYW5kbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBbHRDbGlja0hhbmRsZXIoX21vdXNlRXZlbnQsIF90ZXJtaW5hbCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuX21vdXNlRXZlbnQgPSBfbW91c2VFdmVudDtcbiAgICAgICAgdGhpcy5fdGVybWluYWwgPSBfdGVybWluYWw7XG4gICAgICAgIHRoaXMuX2xpbmVzID0gdGhpcy5fdGVybWluYWwuYnVmZmVyLmxpbmVzO1xuICAgICAgICB0aGlzLl9zdGFydENvbCA9IHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci54O1xuICAgICAgICB0aGlzLl9zdGFydFJvdyA9IHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci55O1xuICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSB0aGlzLl90ZXJtaW5hbC5tb3VzZUhlbHBlci5nZXRDb29yZHModGhpcy5fbW91c2VFdmVudCwgdGhpcy5fdGVybWluYWwuZWxlbWVudCwgdGhpcy5fdGVybWluYWwuY2hhck1lYXN1cmUsIHRoaXMuX3Rlcm1pbmFsLm9wdGlvbnMubGluZUhlaWdodCwgdGhpcy5fdGVybWluYWwuY29scywgdGhpcy5fdGVybWluYWwucm93cywgZmFsc2UpO1xuICAgICAgICBpZiAoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgIF9hID0gY29vcmRpbmF0ZXMubWFwKGZ1bmN0aW9uIChjb29yZGluYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGUgLSAxO1xuICAgICAgICAgICAgfSksIHRoaXMuX2VuZENvbCA9IF9hWzBdLCB0aGlzLl9lbmRSb3cgPSBfYVsxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBbHRDbGlja0hhbmRsZXIucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9tb3VzZUV2ZW50LmFsdEtleSAmJiB0aGlzLl9lbmRDb2wgIT09IHVuZGVmaW5lZCAmJiB0aGlzLl9lbmRSb3cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuaGFuZGxlcih0aGlzLl9hcnJvd1NlcXVlbmNlcygpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWx0Q2xpY2tIYW5kbGVyLnByb3RvdHlwZS5fYXJyb3dTZXF1ZW5jZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdGVybWluYWwuYnVmZmVyLmhhc1Njcm9sbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXNldFN0YXJ0aW5nUm93KCkgKyB0aGlzLl9tb3ZlVG9SZXF1ZXN0ZWRSb3coKSArIHRoaXMuX21vdmVUb1JlcXVlc3RlZENvbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9tb3ZlSG9yaXpvbnRhbGx5T25seSgpO1xuICAgIH07XG4gICAgQWx0Q2xpY2tIYW5kbGVyLnByb3RvdHlwZS5fcmVzZXRTdGFydGluZ1JvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vdmVUb1JlcXVlc3RlZFJvdygpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXBlYXQodGhpcy5fYnVmZmVyTGluZSh0aGlzLl9zdGFydENvbCwgdGhpcy5fc3RhcnRSb3csIHRoaXMuX3N0YXJ0Q29sLCB0aGlzLl9zdGFydFJvdyAtIHRoaXMuX3dyYXBwZWRSb3dzRm9yUm93KHRoaXMuX3N0YXJ0Um93KSwgZmFsc2UpLmxlbmd0aCwgdGhpcy5fc2VxdWVuY2UoXCJEXCIpKTtcbiAgICB9O1xuICAgIEFsdENsaWNrSGFuZGxlci5wcm90b3R5cGUuX21vdmVUb1JlcXVlc3RlZFJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXJ0Um93ID0gdGhpcy5fc3RhcnRSb3cgLSB0aGlzLl93cmFwcGVkUm93c0ZvclJvdyh0aGlzLl9zdGFydFJvdyk7XG4gICAgICAgIHZhciBlbmRSb3cgPSB0aGlzLl9lbmRSb3cgLSB0aGlzLl93cmFwcGVkUm93c0ZvclJvdyh0aGlzLl9lbmRSb3cpO1xuICAgICAgICB2YXIgcm93c1RvTW92ZSA9IE1hdGguYWJzKHN0YXJ0Um93IC0gZW5kUm93KSAtIHRoaXMuX3dyYXBwZWRSb3dzQ291bnQoKTtcbiAgICAgICAgcmV0dXJuIHJlcGVhdChyb3dzVG9Nb3ZlLCB0aGlzLl9zZXF1ZW5jZSh0aGlzLl92ZXJ0aWNhbERpcmVjdGlvbigpKSk7XG4gICAgfTtcbiAgICBBbHRDbGlja0hhbmRsZXIucHJvdG90eXBlLl9tb3ZlVG9SZXF1ZXN0ZWRDb2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGFydFJvdztcbiAgICAgICAgaWYgKHRoaXMuX21vdmVUb1JlcXVlc3RlZFJvdygpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHN0YXJ0Um93ID0gdGhpcy5fZW5kUm93IC0gdGhpcy5fd3JhcHBlZFJvd3NGb3JSb3codGhpcy5fZW5kUm93KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0Um93ID0gdGhpcy5fc3RhcnRSb3c7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVuZFJvdyA9IHRoaXMuX2VuZFJvdztcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMuX2hvcml6b250YWxEaXJlY3Rpb24oKTtcbiAgICAgICAgcmV0dXJuIHJlcGVhdCh0aGlzLl9idWZmZXJMaW5lKHRoaXMuX3N0YXJ0Q29sLCBzdGFydFJvdywgdGhpcy5fZW5kQ29sLCBlbmRSb3csIGRpcmVjdGlvbiA9PT0gXCJDXCIpLmxlbmd0aCwgdGhpcy5fc2VxdWVuY2UoZGlyZWN0aW9uKSk7XG4gICAgfTtcbiAgICBBbHRDbGlja0hhbmRsZXIucHJvdG90eXBlLl9tb3ZlSG9yaXpvbnRhbGx5T25seSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMuX2hvcml6b250YWxEaXJlY3Rpb24oKTtcbiAgICAgICAgcmV0dXJuIHJlcGVhdChNYXRoLmFicyh0aGlzLl9zdGFydENvbCAtIHRoaXMuX2VuZENvbCksIHRoaXMuX3NlcXVlbmNlKGRpcmVjdGlvbikpO1xuICAgIH07XG4gICAgQWx0Q2xpY2tIYW5kbGVyLnByb3RvdHlwZS5fd3JhcHBlZFJvd3NDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdyYXBwZWRSb3dzID0gMDtcbiAgICAgICAgdmFyIHN0YXJ0Um93ID0gdGhpcy5fc3RhcnRSb3cgLSB0aGlzLl93cmFwcGVkUm93c0ZvclJvdyh0aGlzLl9zdGFydFJvdyk7XG4gICAgICAgIHZhciBlbmRSb3cgPSB0aGlzLl9lbmRSb3cgLSB0aGlzLl93cmFwcGVkUm93c0ZvclJvdyh0aGlzLl9lbmRSb3cpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGguYWJzKHN0YXJ0Um93IC0gZW5kUm93KTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5fdmVydGljYWxEaXJlY3Rpb24oKSA9PT0gXCJBXCIgPyAtMSA6IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGluZXMuZ2V0KHN0YXJ0Um93ICsgKGRpcmVjdGlvbiAqIGkpKS5pc1dyYXBwZWQpIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVkUm93cysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cmFwcGVkUm93cztcbiAgICB9O1xuICAgIEFsdENsaWNrSGFuZGxlci5wcm90b3R5cGUuX3dyYXBwZWRSb3dzRm9yUm93ID0gZnVuY3Rpb24gKGN1cnJlbnRSb3cpIHtcbiAgICAgICAgdmFyIHJvd0NvdW50ID0gMDtcbiAgICAgICAgdmFyIGxpbmVXcmFwcyA9IHRoaXMuX2xpbmVzLmdldChjdXJyZW50Um93KS5pc1dyYXBwZWQ7XG4gICAgICAgIHdoaWxlIChsaW5lV3JhcHMgJiYgY3VycmVudFJvdyA+PSAwICYmIGN1cnJlbnRSb3cgPCB0aGlzLl90ZXJtaW5hbC5yb3dzKSB7XG4gICAgICAgICAgICByb3dDb3VudCsrO1xuICAgICAgICAgICAgY3VycmVudFJvdy0tO1xuICAgICAgICAgICAgbGluZVdyYXBzID0gdGhpcy5fbGluZXMuZ2V0KGN1cnJlbnRSb3cpLmlzV3JhcHBlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm93Q291bnQ7XG4gICAgfTtcbiAgICBBbHRDbGlja0hhbmRsZXIucHJvdG90eXBlLl9ob3Jpem9udGFsRGlyZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhcnRSb3c7XG4gICAgICAgIGlmICh0aGlzLl9tb3ZlVG9SZXF1ZXN0ZWRSb3coKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzdGFydFJvdyA9IHRoaXMuX2VuZFJvdyAtIHRoaXMuX3dyYXBwZWRSb3dzRm9yUm93KHRoaXMuX2VuZFJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydFJvdyA9IHRoaXMuX3N0YXJ0Um93O1xuICAgICAgICB9XG4gICAgICAgIGlmICgodGhpcy5fc3RhcnRDb2wgPCB0aGlzLl9lbmRDb2wgJiZcbiAgICAgICAgICAgIHN0YXJ0Um93IDw9IHRoaXMuX2VuZFJvdykgfHxcbiAgICAgICAgICAgICh0aGlzLl9zdGFydENvbCA+PSB0aGlzLl9lbmRDb2wgJiZcbiAgICAgICAgICAgICAgICBzdGFydFJvdyA8IHRoaXMuX2VuZFJvdykpIHtcbiAgICAgICAgICAgIHJldHVybiBcIkNcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJEXCI7XG4gICAgfTtcbiAgICBBbHRDbGlja0hhbmRsZXIucHJvdG90eXBlLl92ZXJ0aWNhbERpcmVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXJ0Um93ID4gdGhpcy5fZW5kUm93KSB7XG4gICAgICAgICAgICByZXR1cm4gXCJBXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiQlwiO1xuICAgIH07XG4gICAgQWx0Q2xpY2tIYW5kbGVyLnByb3RvdHlwZS5fYnVmZmVyTGluZSA9IGZ1bmN0aW9uIChzdGFydENvbCwgc3RhcnRSb3csIGVuZENvbCwgZW5kUm93LCBmb3J3YXJkKSB7XG4gICAgICAgIHZhciBjdXJyZW50Q29sID0gc3RhcnRDb2w7XG4gICAgICAgIHZhciBjdXJyZW50Um93ID0gc3RhcnRSb3c7XG4gICAgICAgIHZhciBidWZmZXJTdHIgPSAnJztcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRDb2wgIT09IGVuZENvbCB8fCBjdXJyZW50Um93ICE9PSBlbmRSb3cpIHtcbiAgICAgICAgICAgIGN1cnJlbnRDb2wgKz0gZm9yd2FyZCA/IDEgOiAtMTtcbiAgICAgICAgICAgIGlmIChmb3J3YXJkICYmIGN1cnJlbnRDb2wgPiB0aGlzLl90ZXJtaW5hbC5jb2xzIC0gMSkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlclN0ciArPSB0aGlzLl90ZXJtaW5hbC5idWZmZXIudHJhbnNsYXRlQnVmZmVyTGluZVRvU3RyaW5nKGN1cnJlbnRSb3csIGZhbHNlLCBzdGFydENvbCwgY3VycmVudENvbCk7XG4gICAgICAgICAgICAgICAgY3VycmVudENvbCA9IDA7XG4gICAgICAgICAgICAgICAgc3RhcnRDb2wgPSAwO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRSb3crKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFmb3J3YXJkICYmIGN1cnJlbnRDb2wgPCAwKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyU3RyICs9IHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci50cmFuc2xhdGVCdWZmZXJMaW5lVG9TdHJpbmcoY3VycmVudFJvdywgZmFsc2UsIDAsIHN0YXJ0Q29sICsgMSk7XG4gICAgICAgICAgICAgICAgY3VycmVudENvbCA9IHRoaXMuX3Rlcm1pbmFsLmNvbHMgLSAxO1xuICAgICAgICAgICAgICAgIHN0YXJ0Q29sID0gY3VycmVudENvbDtcbiAgICAgICAgICAgICAgICBjdXJyZW50Um93LS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlclN0ciArIHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci50cmFuc2xhdGVCdWZmZXJMaW5lVG9TdHJpbmcoY3VycmVudFJvdywgZmFsc2UsIHN0YXJ0Q29sLCBjdXJyZW50Q29sKTtcbiAgICB9O1xuICAgIEFsdENsaWNrSGFuZGxlci5wcm90b3R5cGUuX3NlcXVlbmNlID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgbW9kID0gdGhpcy5fdGVybWluYWwuYXBwbGljYXRpb25DdXJzb3IgPyAnTycgOiAnWyc7XG4gICAgICAgIHJldHVybiBFc2NhcGVTZXF1ZW5jZXNfMS5DMC5FU0MgKyBtb2QgKyBkaXJlY3Rpb247XG4gICAgfTtcbiAgICByZXR1cm4gQWx0Q2xpY2tIYW5kbGVyO1xufSgpKTtcbmV4cG9ydHMuQWx0Q2xpY2tIYW5kbGVyID0gQWx0Q2xpY2tIYW5kbGVyO1xuZnVuY3Rpb24gcmVwZWF0KGNvdW50LCBzdHIpIHtcbiAgICBjb3VudCA9IE1hdGguZmxvb3IoY291bnQpO1xuICAgIHZhciBycHQgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgcnB0ICs9IHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIHJwdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFsdENsaWNrSGFuZGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIHByZXBhcmVUZXh0Rm9yVGVybWluYWwodGV4dCkge1xuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1xccj9cXG4vZywgJ1xccicpO1xufVxuZXhwb3J0cy5wcmVwYXJlVGV4dEZvclRlcm1pbmFsID0gcHJlcGFyZVRleHRGb3JUZXJtaW5hbDtcbmZ1bmN0aW9uIGJyYWNrZXRUZXh0Rm9yUGFzdGUodGV4dCwgYnJhY2tldGVkUGFzdGVNb2RlKSB7XG4gICAgaWYgKGJyYWNrZXRlZFBhc3RlTW9kZSkge1xuICAgICAgICByZXR1cm4gJ1xceDFiWzIwMH4nICsgdGV4dCArICdcXHgxYlsyMDF+JztcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG59XG5leHBvcnRzLmJyYWNrZXRUZXh0Rm9yUGFzdGUgPSBicmFja2V0VGV4dEZvclBhc3RlO1xuZnVuY3Rpb24gY29weUhhbmRsZXIoZXYsIHRlcm0sIHNlbGVjdGlvbk1hbmFnZXIpIHtcbiAgICBpZiAodGVybS5icm93c2VyLmlzTVNJRSkge1xuICAgICAgICB3aW5kb3cuY2xpcGJvYXJkRGF0YS5zZXREYXRhKCdUZXh0Jywgc2VsZWN0aW9uTWFuYWdlci5zZWxlY3Rpb25UZXh0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGV2LmNsaXBib2FyZERhdGEuc2V0RGF0YSgndGV4dC9wbGFpbicsIHNlbGVjdGlvbk1hbmFnZXIuc2VsZWN0aW9uVGV4dCk7XG4gICAgfVxuICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG59XG5leHBvcnRzLmNvcHlIYW5kbGVyID0gY29weUhhbmRsZXI7XG5mdW5jdGlvbiBwYXN0ZUhhbmRsZXIoZXYsIHRlcm0pIHtcbiAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB2YXIgdGV4dDtcbiAgICB2YXIgZGlzcGF0Y2hQYXN0ZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHRleHQgPSBwcmVwYXJlVGV4dEZvclRlcm1pbmFsKHRleHQpO1xuICAgICAgICB0ZXh0ID0gYnJhY2tldFRleHRGb3JQYXN0ZSh0ZXh0LCB0ZXJtLmJyYWNrZXRlZFBhc3RlTW9kZSk7XG4gICAgICAgIHRlcm0uaGFuZGxlcih0ZXh0KTtcbiAgICAgICAgdGVybS50ZXh0YXJlYS52YWx1ZSA9ICcnO1xuICAgICAgICB0ZXJtLmVtaXQoJ3Bhc3RlJywgdGV4dCk7XG4gICAgICAgIHRlcm0uY2FuY2VsKGV2KTtcbiAgICB9O1xuICAgIGlmICh0ZXJtLmJyb3dzZXIuaXNNU0lFKSB7XG4gICAgICAgIGlmICh3aW5kb3cuY2xpcGJvYXJkRGF0YSkge1xuICAgICAgICAgICAgdGV4dCA9IHdpbmRvdy5jbGlwYm9hcmREYXRhLmdldERhdGEoJ1RleHQnKTtcbiAgICAgICAgICAgIGRpc3BhdGNoUGFzdGUodGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChldi5jbGlwYm9hcmREYXRhKSB7XG4gICAgICAgICAgICB0ZXh0ID0gZXYuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd0ZXh0L3BsYWluJyk7XG4gICAgICAgICAgICBkaXNwYXRjaFBhc3RlKHRleHQpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5wYXN0ZUhhbmRsZXIgPSBwYXN0ZUhhbmRsZXI7XG5mdW5jdGlvbiBtb3ZlVGV4dEFyZWFVbmRlck1vdXNlQ3Vyc29yKGV2LCB0ZXh0YXJlYSkge1xuICAgIHRleHRhcmVhLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICB0ZXh0YXJlYS5zdHlsZS53aWR0aCA9ICcyMHB4JztcbiAgICB0ZXh0YXJlYS5zdHlsZS5oZWlnaHQgPSAnMjBweCc7XG4gICAgdGV4dGFyZWEuc3R5bGUubGVmdCA9IChldi5jbGllbnRYIC0gMTApICsgJ3B4JztcbiAgICB0ZXh0YXJlYS5zdHlsZS50b3AgPSAoZXYuY2xpZW50WSAtIDEwKSArICdweCc7XG4gICAgdGV4dGFyZWEuc3R5bGUuekluZGV4ID0gJzEwMDAnO1xuICAgIHRleHRhcmVhLmZvY3VzKCk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRleHRhcmVhLnN0eWxlLnBvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUud2lkdGggPSBudWxsO1xuICAgICAgICB0ZXh0YXJlYS5zdHlsZS5oZWlnaHQgPSBudWxsO1xuICAgICAgICB0ZXh0YXJlYS5zdHlsZS5sZWZ0ID0gbnVsbDtcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUudG9wID0gbnVsbDtcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUuekluZGV4ID0gbnVsbDtcbiAgICB9LCAyMDApO1xufVxuZXhwb3J0cy5tb3ZlVGV4dEFyZWFVbmRlck1vdXNlQ3Vyc29yID0gbW92ZVRleHRBcmVhVW5kZXJNb3VzZUN1cnNvcjtcbmZ1bmN0aW9uIHJpZ2h0Q2xpY2tIYW5kbGVyKGV2LCB0ZXh0YXJlYSwgc2VsZWN0aW9uTWFuYWdlciwgc2hvdWxkU2VsZWN0V29yZCkge1xuICAgIG1vdmVUZXh0QXJlYVVuZGVyTW91c2VDdXJzb3IoZXYsIHRleHRhcmVhKTtcbiAgICBpZiAoc2hvdWxkU2VsZWN0V29yZCAmJiAhc2VsZWN0aW9uTWFuYWdlci5pc0NsaWNrSW5TZWxlY3Rpb24oZXYpKSB7XG4gICAgICAgIHNlbGVjdGlvbk1hbmFnZXIuc2VsZWN0V29yZEF0Q3Vyc29yKGV2KTtcbiAgICB9XG4gICAgdGV4dGFyZWEudmFsdWUgPSBzZWxlY3Rpb25NYW5hZ2VyLnNlbGVjdGlvblRleHQ7XG4gICAgdGV4dGFyZWEuc2VsZWN0KCk7XG59XG5leHBvcnRzLnJpZ2h0Q2xpY2tIYW5kbGVyID0gcmlnaHRDbGlja0hhbmRsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DbGlwYm9hcmQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgVGVybWluYWxfMSA9IHJlcXVpcmUoXCIuLi9UZXJtaW5hbFwiKTtcbnZhciBTdHJpbmdzID0gcmVxdWlyZShcIi4uL1N0cmluZ3NcIik7XG52YXIgVGVybWluYWwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRlcm1pbmFsKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fY29yZSA9IG5ldyBUZXJtaW5hbF8xLlRlcm1pbmFsKG9wdGlvbnMpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGVybWluYWwucHJvdG90eXBlLCBcImVsZW1lbnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvcmUuZWxlbWVudDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRlcm1pbmFsLnByb3RvdHlwZSwgXCJ0ZXh0YXJlYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29yZS50ZXh0YXJlYTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRlcm1pbmFsLnByb3RvdHlwZSwgXCJyb3dzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb3JlLnJvd3M7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXJtaW5hbC5wcm90b3R5cGUsIFwiY29sc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29yZS5jb2xzOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGVybWluYWwucHJvdG90eXBlLCBcIm1hcmtlcnNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvcmUubWFya2VyczsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVGVybWluYWwucHJvdG90eXBlLmJsdXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NvcmUuYmx1cigpO1xuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jb3JlLmZvY3VzKCk7XG4gICAgfTtcbiAgICBUZXJtaW5hbC5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fY29yZS5vbih0eXBlLCBsaXN0ZW5lcik7XG4gICAgfTtcbiAgICBUZXJtaW5hbC5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2NvcmUub2ZmKHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKHR5cGUsIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fY29yZS5lbWl0KHR5cGUsIGRhdGEpO1xuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLmFkZERpc3Bvc2FibGVMaXN0ZW5lciA9IGZ1bmN0aW9uICh0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb3JlLmFkZERpc3Bvc2FibGVMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTtcbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoY29sdW1ucywgcm93cykge1xuICAgICAgICB0aGlzLl9jb3JlLnJlc2l6ZShjb2x1bW5zLCByb3dzKTtcbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS53cml0ZWxuID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fY29yZS53cml0ZWxuKGRhdGEpO1xuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgIHRoaXMuX2NvcmUub3BlbihwYXJlbnQpO1xuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLmF0dGFjaEN1c3RvbUtleUV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIChjdXN0b21LZXlFdmVudEhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fY29yZS5hdHRhY2hDdXN0b21LZXlFdmVudEhhbmRsZXIoY3VzdG9tS2V5RXZlbnRIYW5kbGVyKTtcbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5yZWdpc3RlckxpbmtNYXRjaGVyID0gZnVuY3Rpb24gKHJlZ2V4LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb3JlLnJlZ2lzdGVyTGlua01hdGNoZXIocmVnZXgsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLmRlcmVnaXN0ZXJMaW5rTWF0Y2hlciA9IGZ1bmN0aW9uIChtYXRjaGVySWQpIHtcbiAgICAgICAgdGhpcy5fY29yZS5kZXJlZ2lzdGVyTGlua01hdGNoZXIobWF0Y2hlcklkKTtcbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5yZWdpc3RlckNoYXJhY3RlckpvaW5lciA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb3JlLnJlZ2lzdGVyQ2hhcmFjdGVySm9pbmVyKGhhbmRsZXIpO1xuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLmRlcmVnaXN0ZXJDaGFyYWN0ZXJKb2luZXIgPSBmdW5jdGlvbiAoam9pbmVySWQpIHtcbiAgICAgICAgdGhpcy5fY29yZS5kZXJlZ2lzdGVyQ2hhcmFjdGVySm9pbmVyKGpvaW5lcklkKTtcbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5hZGRNYXJrZXIgPSBmdW5jdGlvbiAoY3Vyc29yWU9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29yZS5hZGRNYXJrZXIoY3Vyc29yWU9mZnNldCk7XG4gICAgfTtcbiAgICBUZXJtaW5hbC5wcm90b3R5cGUuaGFzU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29yZS5oYXNTZWxlY3Rpb24oKTtcbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb3JlLmdldFNlbGVjdGlvbigpO1xuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLmNsZWFyU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jb3JlLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgfTtcbiAgICBUZXJtaW5hbC5wcm90b3R5cGUuc2VsZWN0QWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jb3JlLnNlbGVjdEFsbCgpO1xuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLnNlbGVjdExpbmVzID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy5fY29yZS5zZWxlY3RMaW5lcyhzdGFydCwgZW5kKTtcbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jb3JlLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jb3JlLmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5zY3JvbGxMaW5lcyA9IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgdGhpcy5fY29yZS5zY3JvbGxMaW5lcyhhbW91bnQpO1xuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLnNjcm9sbFBhZ2VzID0gZnVuY3Rpb24gKHBhZ2VDb3VudCkge1xuICAgICAgICB0aGlzLl9jb3JlLnNjcm9sbFBhZ2VzKHBhZ2VDb3VudCk7XG4gICAgfTtcbiAgICBUZXJtaW5hbC5wcm90b3R5cGUuc2Nyb2xsVG9Ub3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NvcmUuc2Nyb2xsVG9Ub3AoKTtcbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5zY3JvbGxUb0JvdHRvbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY29yZS5zY3JvbGxUb0JvdHRvbSgpO1xuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLnNjcm9sbFRvTGluZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHRoaXMuX2NvcmUuc2Nyb2xsVG9MaW5lKGxpbmUpO1xuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jb3JlLmNsZWFyKCk7XG4gICAgfTtcbiAgICBUZXJtaW5hbC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLl9jb3JlLndyaXRlKGRhdGEpO1xuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLmdldE9wdGlvbiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvcmUuZ2V0T3B0aW9uKGtleSk7XG4gICAgfTtcbiAgICBUZXJtaW5hbC5wcm90b3R5cGUuc2V0T3B0aW9uID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fY29yZS5zZXRPcHRpb24oa2V5LCB2YWx1ZSk7XG4gICAgfTtcbiAgICBUZXJtaW5hbC5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHRoaXMuX2NvcmUucmVmcmVzaChzdGFydCwgZW5kKTtcbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY29yZS5yZXNldCgpO1xuICAgIH07XG4gICAgVGVybWluYWwuYXBwbHlBZGRvbiA9IGZ1bmN0aW9uIChhZGRvbikge1xuICAgICAgICBhZGRvbi5hcHBseShUZXJtaW5hbCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGVybWluYWwsIFwic3RyaW5nc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZ3M7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBUZXJtaW5hbDtcbn0oKSk7XG5leHBvcnRzLlRlcm1pbmFsID0gVGVybWluYWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXJtaW5hbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBUeXBlc18xID0gcmVxdWlyZShcIi4vYXRsYXMvVHlwZXNcIik7XG52YXIgQ2hhckF0bGFzQ2FjaGVfMSA9IHJlcXVpcmUoXCIuL2F0bGFzL0NoYXJBdGxhc0NhY2hlXCIpO1xudmFyIEJ1ZmZlcl8xID0gcmVxdWlyZShcIi4uL0J1ZmZlclwiKTtcbnZhciBCYXNlUmVuZGVyTGF5ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJhc2VSZW5kZXJMYXllcihfY29udGFpbmVyLCBpZCwgekluZGV4LCBfYWxwaGEsIF9jb2xvcnMpIHtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gX2NvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5fYWxwaGEgPSBfYWxwaGE7XG4gICAgICAgIHRoaXMuX2NvbG9ycyA9IF9jb2xvcnM7XG4gICAgICAgIHRoaXMuX3NjYWxlZENoYXJXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMuX3NjYWxlZENoYXJIZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLl9zY2FsZWRDZWxsV2lkdGggPSAwO1xuICAgICAgICB0aGlzLl9zY2FsZWRDZWxsSGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5fc2NhbGVkQ2hhckxlZnQgPSAwO1xuICAgICAgICB0aGlzLl9zY2FsZWRDaGFyVG9wID0gMDtcbiAgICAgICAgdGhpcy5fY3VycmVudEdseXBoSWRlbnRpZmllciA9IHtcbiAgICAgICAgICAgIGNoYXJzOiAnJyxcbiAgICAgICAgICAgIGNvZGU6IDAsXG4gICAgICAgICAgICBiZzogMCxcbiAgICAgICAgICAgIGZnOiAwLFxuICAgICAgICAgICAgYm9sZDogZmFsc2UsXG4gICAgICAgICAgICBkaW06IGZhbHNlLFxuICAgICAgICAgICAgaXRhbGljOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdGhpcy5fY2FudmFzLmNsYXNzTGlzdC5hZGQoXCJ4dGVybS1cIiArIGlkICsgXCItbGF5ZXJcIik7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS56SW5kZXggPSB6SW5kZXgudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5faW5pdENhbnZhcygpO1xuICAgICAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fY2FudmFzKTtcbiAgICB9XG4gICAgQmFzZVJlbmRlckxheWVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5fY2FudmFzKTtcbiAgICAgICAgaWYgKHRoaXMuX2NoYXJBdGxhcykge1xuICAgICAgICAgICAgdGhpcy5fY2hhckF0bGFzLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmFzZVJlbmRlckxheWVyLnByb3RvdHlwZS5faW5pdENhbnZhcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY3R4ID0gdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJywgeyBhbHBoYTogdGhpcy5fYWxwaGEgfSk7XG4gICAgICAgIGlmICghdGhpcy5fYWxwaGEpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJBbGwoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmFzZVJlbmRlckxheWVyLnByb3RvdHlwZS5vbk9wdGlvbnNDaGFuZ2VkID0gZnVuY3Rpb24gKHRlcm1pbmFsKSB7IH07XG4gICAgQmFzZVJlbmRlckxheWVyLnByb3RvdHlwZS5vbkJsdXIgPSBmdW5jdGlvbiAodGVybWluYWwpIHsgfTtcbiAgICBCYXNlUmVuZGVyTGF5ZXIucHJvdG90eXBlLm9uRm9jdXMgPSBmdW5jdGlvbiAodGVybWluYWwpIHsgfTtcbiAgICBCYXNlUmVuZGVyTGF5ZXIucHJvdG90eXBlLm9uQ3Vyc29yTW92ZSA9IGZ1bmN0aW9uICh0ZXJtaW5hbCkgeyB9O1xuICAgIEJhc2VSZW5kZXJMYXllci5wcm90b3R5cGUub25HcmlkQ2hhbmdlZCA9IGZ1bmN0aW9uICh0ZXJtaW5hbCwgc3RhcnRSb3csIGVuZFJvdykgeyB9O1xuICAgIEJhc2VSZW5kZXJMYXllci5wcm90b3R5cGUub25TZWxlY3Rpb25DaGFuZ2VkID0gZnVuY3Rpb24gKHRlcm1pbmFsLCBzdGFydCwgZW5kLCBjb2x1bW5TZWxlY3RNb2RlKSB7XG4gICAgICAgIGlmIChjb2x1bW5TZWxlY3RNb2RlID09PSB2b2lkIDApIHsgY29sdW1uU2VsZWN0TW9kZSA9IGZhbHNlOyB9XG4gICAgfTtcbiAgICBCYXNlUmVuZGVyTGF5ZXIucHJvdG90eXBlLm9uVGhlbWVDaGFuZ2VkID0gZnVuY3Rpb24gKHRlcm1pbmFsLCBjb2xvclNldCkge1xuICAgICAgICB0aGlzLl9yZWZyZXNoQ2hhckF0bGFzKHRlcm1pbmFsLCBjb2xvclNldCk7XG4gICAgfTtcbiAgICBCYXNlUmVuZGVyTGF5ZXIucHJvdG90eXBlLnNldFRyYW5zcGFyZW5jeSA9IGZ1bmN0aW9uICh0ZXJtaW5hbCwgYWxwaGEpIHtcbiAgICAgICAgaWYgKGFscGhhID09PSB0aGlzLl9hbHBoYSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvbGRDYW52YXMgPSB0aGlzLl9jYW52YXM7XG4gICAgICAgIHRoaXMuX2FscGhhID0gYWxwaGE7XG4gICAgICAgIHRoaXMuX2NhbnZhcyA9IHRoaXMuX2NhbnZhcy5jbG9uZU5vZGUoKTtcbiAgICAgICAgdGhpcy5faW5pdENhbnZhcygpO1xuICAgICAgICB0aGlzLl9jb250YWluZXIucmVwbGFjZUNoaWxkKHRoaXMuX2NhbnZhcywgb2xkQ2FudmFzKTtcbiAgICAgICAgdGhpcy5fcmVmcmVzaENoYXJBdGxhcyh0ZXJtaW5hbCwgdGhpcy5fY29sb3JzKTtcbiAgICAgICAgdGhpcy5vbkdyaWRDaGFuZ2VkKHRlcm1pbmFsLCAwLCB0ZXJtaW5hbC5yb3dzIC0gMSk7XG4gICAgfTtcbiAgICBCYXNlUmVuZGVyTGF5ZXIucHJvdG90eXBlLl9yZWZyZXNoQ2hhckF0bGFzID0gZnVuY3Rpb24gKHRlcm1pbmFsLCBjb2xvclNldCkge1xuICAgICAgICBpZiAodGhpcy5fc2NhbGVkQ2hhcldpZHRoIDw9IDAgJiYgdGhpcy5fc2NhbGVkQ2hhckhlaWdodCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hhckF0bGFzID0gQ2hhckF0bGFzQ2FjaGVfMS5hY3F1aXJlQ2hhckF0bGFzKHRlcm1pbmFsLCBjb2xvclNldCwgdGhpcy5fc2NhbGVkQ2hhcldpZHRoLCB0aGlzLl9zY2FsZWRDaGFySGVpZ2h0KTtcbiAgICAgICAgdGhpcy5fY2hhckF0bGFzLndhcm1VcCgpO1xuICAgIH07XG4gICAgQmFzZVJlbmRlckxheWVyLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAodGVybWluYWwsIGRpbSkge1xuICAgICAgICB0aGlzLl9zY2FsZWRDZWxsV2lkdGggPSBkaW0uc2NhbGVkQ2VsbFdpZHRoO1xuICAgICAgICB0aGlzLl9zY2FsZWRDZWxsSGVpZ2h0ID0gZGltLnNjYWxlZENlbGxIZWlnaHQ7XG4gICAgICAgIHRoaXMuX3NjYWxlZENoYXJXaWR0aCA9IGRpbS5zY2FsZWRDaGFyV2lkdGg7XG4gICAgICAgIHRoaXMuX3NjYWxlZENoYXJIZWlnaHQgPSBkaW0uc2NhbGVkQ2hhckhlaWdodDtcbiAgICAgICAgdGhpcy5fc2NhbGVkQ2hhckxlZnQgPSBkaW0uc2NhbGVkQ2hhckxlZnQ7XG4gICAgICAgIHRoaXMuX3NjYWxlZENoYXJUb3AgPSBkaW0uc2NhbGVkQ2hhclRvcDtcbiAgICAgICAgdGhpcy5fY2FudmFzLndpZHRoID0gZGltLnNjYWxlZENhbnZhc1dpZHRoO1xuICAgICAgICB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gZGltLnNjYWxlZENhbnZhc0hlaWdodDtcbiAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLndpZHRoID0gZGltLmNhbnZhc1dpZHRoICsgXCJweFwiO1xuICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUuaGVpZ2h0ID0gZGltLmNhbnZhc0hlaWdodCArIFwicHhcIjtcbiAgICAgICAgaWYgKCF0aGlzLl9hbHBoYSkge1xuICAgICAgICAgICAgdGhpcy5jbGVhckFsbCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlZnJlc2hDaGFyQXRsYXModGVybWluYWwsIHRoaXMuX2NvbG9ycyk7XG4gICAgfTtcbiAgICBCYXNlUmVuZGVyTGF5ZXIucHJvdG90eXBlLmZpbGxDZWxscyA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsUmVjdCh4ICogdGhpcy5fc2NhbGVkQ2VsbFdpZHRoLCB5ICogdGhpcy5fc2NhbGVkQ2VsbEhlaWdodCwgd2lkdGggKiB0aGlzLl9zY2FsZWRDZWxsV2lkdGgsIGhlaWdodCAqIHRoaXMuX3NjYWxlZENlbGxIZWlnaHQpO1xuICAgIH07XG4gICAgQmFzZVJlbmRlckxheWVyLnByb3RvdHlwZS5maWxsQm90dG9tTGluZUF0Q2VsbHMgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgpIHtcbiAgICAgICAgaWYgKHdpZHRoID09PSB2b2lkIDApIHsgd2lkdGggPSAxOyB9XG4gICAgICAgIHRoaXMuX2N0eC5maWxsUmVjdCh4ICogdGhpcy5fc2NhbGVkQ2VsbFdpZHRoLCAoeSArIDEpICogdGhpcy5fc2NhbGVkQ2VsbEhlaWdodCAtIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIC0gMSwgd2lkdGggKiB0aGlzLl9zY2FsZWRDZWxsV2lkdGgsIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICB9O1xuICAgIEJhc2VSZW5kZXJMYXllci5wcm90b3R5cGUuZmlsbExlZnRMaW5lQXRDZWxsID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxSZWN0KHggKiB0aGlzLl9zY2FsZWRDZWxsV2lkdGgsIHkgKiB0aGlzLl9zY2FsZWRDZWxsSGVpZ2h0LCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbywgdGhpcy5fc2NhbGVkQ2VsbEhlaWdodCk7XG4gICAgfTtcbiAgICBCYXNlUmVuZGVyTGF5ZXIucHJvdG90eXBlLnN0cm9rZVJlY3RBdENlbGwgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLl9jdHgubGluZVdpZHRoID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2VSZWN0KHggKiB0aGlzLl9zY2FsZWRDZWxsV2lkdGggKyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyAvIDIsIHkgKiB0aGlzLl9zY2FsZWRDZWxsSGVpZ2h0ICsgKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIC8gMiksIHdpZHRoICogdGhpcy5fc2NhbGVkQ2VsbFdpZHRoIC0gd2luZG93LmRldmljZVBpeGVsUmF0aW8sIChoZWlnaHQgKiB0aGlzLl9zY2FsZWRDZWxsSGVpZ2h0KSAtIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICB9O1xuICAgIEJhc2VSZW5kZXJMYXllci5wcm90b3R5cGUuY2xlYXJBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9hbHBoYSkge1xuICAgICAgICAgICAgdGhpcy5fY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLl9jYW52YXMud2lkdGgsIHRoaXMuX2NhbnZhcy5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY3R4LmZpbGxTdHlsZSA9IHRoaXMuX2NvbG9ycy5iYWNrZ3JvdW5kLmNzcztcbiAgICAgICAgICAgIHRoaXMuX2N0eC5maWxsUmVjdCgwLCAwLCB0aGlzLl9jYW52YXMud2lkdGgsIHRoaXMuX2NhbnZhcy5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCYXNlUmVuZGVyTGF5ZXIucHJvdG90eXBlLmNsZWFyQ2VsbHMgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBpZiAodGhpcy5fYWxwaGEpIHtcbiAgICAgICAgICAgIHRoaXMuX2N0eC5jbGVhclJlY3QoeCAqIHRoaXMuX3NjYWxlZENlbGxXaWR0aCwgeSAqIHRoaXMuX3NjYWxlZENlbGxIZWlnaHQsIHdpZHRoICogdGhpcy5fc2NhbGVkQ2VsbFdpZHRoLCBoZWlnaHQgKiB0aGlzLl9zY2FsZWRDZWxsSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2N0eC5maWxsU3R5bGUgPSB0aGlzLl9jb2xvcnMuYmFja2dyb3VuZC5jc3M7XG4gICAgICAgICAgICB0aGlzLl9jdHguZmlsbFJlY3QoeCAqIHRoaXMuX3NjYWxlZENlbGxXaWR0aCwgeSAqIHRoaXMuX3NjYWxlZENlbGxIZWlnaHQsIHdpZHRoICogdGhpcy5fc2NhbGVkQ2VsbFdpZHRoLCBoZWlnaHQgKiB0aGlzLl9zY2FsZWRDZWxsSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmFzZVJlbmRlckxheWVyLnByb3RvdHlwZS5maWxsQ2hhclRydWVDb2xvciA9IGZ1bmN0aW9uICh0ZXJtaW5hbCwgY2hhckRhdGEsIHgsIHkpIHtcbiAgICAgICAgdGhpcy5fY3R4LmZvbnQgPSB0aGlzLl9nZXRGb250KHRlcm1pbmFsLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9jdHgudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG4gICAgICAgIHRoaXMuX2NsaXBSb3codGVybWluYWwsIHkpO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFRleHQoY2hhckRhdGFbQnVmZmVyXzEuQ0hBUl9EQVRBX0NIQVJfSU5ERVhdLCB4ICogdGhpcy5fc2NhbGVkQ2VsbFdpZHRoICsgdGhpcy5fc2NhbGVkQ2hhckxlZnQsIHkgKiB0aGlzLl9zY2FsZWRDZWxsSGVpZ2h0ICsgdGhpcy5fc2NhbGVkQ2hhclRvcCk7XG4gICAgfTtcbiAgICBCYXNlUmVuZGVyTGF5ZXIucHJvdG90eXBlLmRyYXdDaGFycyA9IGZ1bmN0aW9uICh0ZXJtaW5hbCwgY2hhcnMsIGNvZGUsIHdpZHRoLCB4LCB5LCBmZywgYmcsIGJvbGQsIGRpbSwgaXRhbGljKSB7XG4gICAgICAgIHZhciBkcmF3SW5CcmlnaHRDb2xvciA9IHRlcm1pbmFsLm9wdGlvbnMuZHJhd0JvbGRUZXh0SW5CcmlnaHRDb2xvcnMgJiYgYm9sZCAmJiBmZyA8IDggJiYgZmcgIT09IFR5cGVzXzEuSU5WRVJURURfREVGQVVMVF9DT0xPUjtcbiAgICAgICAgZmcgKz0gZHJhd0luQnJpZ2h0Q29sb3IgPyA4IDogMDtcbiAgICAgICAgdGhpcy5fY3VycmVudEdseXBoSWRlbnRpZmllci5jaGFycyA9IGNoYXJzO1xuICAgICAgICB0aGlzLl9jdXJyZW50R2x5cGhJZGVudGlmaWVyLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLl9jdXJyZW50R2x5cGhJZGVudGlmaWVyLmJnID0gYmc7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRHbHlwaElkZW50aWZpZXIuZmcgPSBmZztcbiAgICAgICAgdGhpcy5fY3VycmVudEdseXBoSWRlbnRpZmllci5ib2xkID0gYm9sZCAmJiB0ZXJtaW5hbC5vcHRpb25zLmVuYWJsZUJvbGQ7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRHbHlwaElkZW50aWZpZXIuZGltID0gZGltO1xuICAgICAgICB0aGlzLl9jdXJyZW50R2x5cGhJZGVudGlmaWVyLml0YWxpYyA9IGl0YWxpYztcbiAgICAgICAgdmFyIGF0bGFzRGlkRHJhdyA9IHRoaXMuX2NoYXJBdGxhcyAmJiB0aGlzLl9jaGFyQXRsYXMuZHJhdyh0aGlzLl9jdHgsIHRoaXMuX2N1cnJlbnRHbHlwaElkZW50aWZpZXIsIHggKiB0aGlzLl9zY2FsZWRDZWxsV2lkdGggKyB0aGlzLl9zY2FsZWRDaGFyTGVmdCwgeSAqIHRoaXMuX3NjYWxlZENlbGxIZWlnaHQgKyB0aGlzLl9zY2FsZWRDaGFyVG9wKTtcbiAgICAgICAgaWYgKCFhdGxhc0RpZERyYXcpIHtcbiAgICAgICAgICAgIHRoaXMuX2RyYXdVbmNhY2hlZENoYXJzKHRlcm1pbmFsLCBjaGFycywgd2lkdGgsIGZnLCB4LCB5LCBib2xkICYmIHRlcm1pbmFsLm9wdGlvbnMuZW5hYmxlQm9sZCwgZGltLCBpdGFsaWMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCYXNlUmVuZGVyTGF5ZXIucHJvdG90eXBlLl9kcmF3VW5jYWNoZWRDaGFycyA9IGZ1bmN0aW9uICh0ZXJtaW5hbCwgY2hhcnMsIHdpZHRoLCBmZywgeCwgeSwgYm9sZCwgZGltLCBpdGFsaWMpIHtcbiAgICAgICAgdGhpcy5fY3R4LnNhdmUoKTtcbiAgICAgICAgdGhpcy5fY3R4LmZvbnQgPSB0aGlzLl9nZXRGb250KHRlcm1pbmFsLCBib2xkLCBpdGFsaWMpO1xuICAgICAgICB0aGlzLl9jdHgudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG4gICAgICAgIGlmIChmZyA9PT0gVHlwZXNfMS5JTlZFUlRFRF9ERUZBVUxUX0NPTE9SKSB7XG4gICAgICAgICAgICB0aGlzLl9jdHguZmlsbFN0eWxlID0gdGhpcy5fY29sb3JzLmJhY2tncm91bmQuY3NzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZnIDwgMjU2KSB7XG4gICAgICAgICAgICB0aGlzLl9jdHguZmlsbFN0eWxlID0gdGhpcy5fY29sb3JzLmFuc2lbZmddLmNzcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2N0eC5maWxsU3R5bGUgPSB0aGlzLl9jb2xvcnMuZm9yZWdyb3VuZC5jc3M7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2xpcFJvdyh0ZXJtaW5hbCwgeSk7XG4gICAgICAgIGlmIChkaW0pIHtcbiAgICAgICAgICAgIHRoaXMuX2N0eC5nbG9iYWxBbHBoYSA9IFR5cGVzXzEuRElNX09QQUNJVFk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY3R4LmZpbGxUZXh0KGNoYXJzLCB4ICogdGhpcy5fc2NhbGVkQ2VsbFdpZHRoICsgdGhpcy5fc2NhbGVkQ2hhckxlZnQsIHkgKiB0aGlzLl9zY2FsZWRDZWxsSGVpZ2h0ICsgdGhpcy5fc2NhbGVkQ2hhclRvcCk7XG4gICAgICAgIHRoaXMuX2N0eC5yZXN0b3JlKCk7XG4gICAgfTtcbiAgICBCYXNlUmVuZGVyTGF5ZXIucHJvdG90eXBlLl9jbGlwUm93ID0gZnVuY3Rpb24gKHRlcm1pbmFsLCB5KSB7XG4gICAgICAgIHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fY3R4LnJlY3QoMCwgeSAqIHRoaXMuX3NjYWxlZENlbGxIZWlnaHQsIHRlcm1pbmFsLmNvbHMgKiB0aGlzLl9zY2FsZWRDZWxsV2lkdGgsIHRoaXMuX3NjYWxlZENlbGxIZWlnaHQpO1xuICAgICAgICB0aGlzLl9jdHguY2xpcCgpO1xuICAgIH07XG4gICAgQmFzZVJlbmRlckxheWVyLnByb3RvdHlwZS5fZ2V0Rm9udCA9IGZ1bmN0aW9uICh0ZXJtaW5hbCwgaXNCb2xkLCBpc0l0YWxpYykge1xuICAgICAgICB2YXIgZm9udFdlaWdodCA9IGlzQm9sZCA/IHRlcm1pbmFsLm9wdGlvbnMuZm9udFdlaWdodEJvbGQgOiB0ZXJtaW5hbC5vcHRpb25zLmZvbnRXZWlnaHQ7XG4gICAgICAgIHZhciBmb250U3R5bGUgPSBpc0l0YWxpYyA/ICdpdGFsaWMnIDogJyc7XG4gICAgICAgIHJldHVybiBmb250U3R5bGUgKyBcIiBcIiArIGZvbnRXZWlnaHQgKyBcIiBcIiArIHRlcm1pbmFsLm9wdGlvbnMuZm9udFNpemUgKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyArIFwicHggXCIgKyB0ZXJtaW5hbC5vcHRpb25zLmZvbnRGYW1pbHk7XG4gICAgfTtcbiAgICByZXR1cm4gQmFzZVJlbmRlckxheWVyO1xufSgpKTtcbmV4cG9ydHMuQmFzZVJlbmRlckxheWVyID0gQmFzZVJlbmRlckxheWVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZVJlbmRlckxheWVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEJ1ZmZlcl8xID0gcmVxdWlyZShcIi4uL0J1ZmZlclwiKTtcbnZhciBDaGFyYWN0ZXJKb2luZXJSZWdpc3RyeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2hhcmFjdGVySm9pbmVyUmVnaXN0cnkoX3Rlcm1pbmFsKSB7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsID0gX3Rlcm1pbmFsO1xuICAgICAgICB0aGlzLl9jaGFyYWN0ZXJKb2luZXJzID0gW107XG4gICAgICAgIHRoaXMuX25leHRDaGFyYWN0ZXJKb2luZXJJZCA9IDA7XG4gICAgfVxuICAgIENoYXJhY3RlckpvaW5lclJlZ2lzdHJ5LnByb3RvdHlwZS5yZWdpc3RlckNoYXJhY3RlckpvaW5lciA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIHZhciBqb2luZXIgPSB7XG4gICAgICAgICAgICBpZDogdGhpcy5fbmV4dENoYXJhY3RlckpvaW5lcklkKyssXG4gICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2NoYXJhY3RlckpvaW5lcnMucHVzaChqb2luZXIpO1xuICAgICAgICByZXR1cm4gam9pbmVyLmlkO1xuICAgIH07XG4gICAgQ2hhcmFjdGVySm9pbmVyUmVnaXN0cnkucHJvdG90eXBlLmRlcmVnaXN0ZXJDaGFyYWN0ZXJKb2luZXIgPSBmdW5jdGlvbiAoam9pbmVySWQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jaGFyYWN0ZXJKb2luZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2hhcmFjdGVySm9pbmVyc1tpXS5pZCA9PT0gam9pbmVySWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFyYWN0ZXJKb2luZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBDaGFyYWN0ZXJKb2luZXJSZWdpc3RyeS5wcm90b3R5cGUuZ2V0Sm9pbmVkQ2hhcmFjdGVycyA9IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NoYXJhY3RlckpvaW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLl90ZXJtaW5hbC5idWZmZXIubGluZXMuZ2V0KHJvdyk7XG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYW5nZXMgPSBbXTtcbiAgICAgICAgdmFyIGxpbmVTdHIgPSB0aGlzLl90ZXJtaW5hbC5idWZmZXIudHJhbnNsYXRlQnVmZmVyTGluZVRvU3RyaW5nKHJvdywgdHJ1ZSk7XG4gICAgICAgIHZhciByYW5nZVN0YXJ0Q29sdW1uID0gMDtcbiAgICAgICAgdmFyIGN1cnJlbnRTdHJpbmdJbmRleCA9IDA7XG4gICAgICAgIHZhciByYW5nZVN0YXJ0U3RyaW5nSW5kZXggPSAwO1xuICAgICAgICB2YXIgcmFuZ2VBdHRyID0gbGluZS5nZXQoMClbQnVmZmVyXzEuQ0hBUl9EQVRBX0FUVFJfSU5ERVhdID4+IDk7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdGhpcy5fdGVybWluYWwuY29sczsgeCsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhckRhdGEgPSBsaW5lLmdldCh4KTtcbiAgICAgICAgICAgIHZhciBjaGFycyA9IGNoYXJEYXRhW0J1ZmZlcl8xLkNIQVJfREFUQV9DSEFSX0lOREVYXTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGNoYXJEYXRhW0J1ZmZlcl8xLkNIQVJfREFUQV9XSURUSF9JTkRFWF07XG4gICAgICAgICAgICB2YXIgYXR0ciA9IGNoYXJEYXRhW0J1ZmZlcl8xLkNIQVJfREFUQV9BVFRSX0lOREVYXSA+PiA5O1xuICAgICAgICAgICAgaWYgKHdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXR0ciAhPT0gcmFuZ2VBdHRyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHggLSByYW5nZVN0YXJ0Q29sdW1uID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgam9pbmVkUmFuZ2VzID0gdGhpcy5fZ2V0Sm9pbmVkUmFuZ2VzKGxpbmVTdHIsIHJhbmdlU3RhcnRTdHJpbmdJbmRleCwgY3VycmVudFN0cmluZ0luZGV4LCBsaW5lLCByYW5nZVN0YXJ0Q29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBqb2luZWRSYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKGpvaW5lZFJhbmdlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmFuZ2VTdGFydENvbHVtbiA9IHg7XG4gICAgICAgICAgICAgICAgcmFuZ2VTdGFydFN0cmluZ0luZGV4ID0gY3VycmVudFN0cmluZ0luZGV4O1xuICAgICAgICAgICAgICAgIHJhbmdlQXR0ciA9IGF0dHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50U3RyaW5nSW5kZXggKz0gY2hhcnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl90ZXJtaW5hbC5jb2xzIC0gcmFuZ2VTdGFydENvbHVtbiA+IDEpIHtcbiAgICAgICAgICAgIHZhciBqb2luZWRSYW5nZXMgPSB0aGlzLl9nZXRKb2luZWRSYW5nZXMobGluZVN0ciwgcmFuZ2VTdGFydFN0cmluZ0luZGV4LCBjdXJyZW50U3RyaW5nSW5kZXgsIGxpbmUsIHJhbmdlU3RhcnRDb2x1bW4pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBqb2luZWRSYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChqb2luZWRSYW5nZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgfTtcbiAgICBDaGFyYWN0ZXJKb2luZXJSZWdpc3RyeS5wcm90b3R5cGUuX2dldEpvaW5lZFJhbmdlcyA9IGZ1bmN0aW9uIChsaW5lLCBzdGFydEluZGV4LCBlbmRJbmRleCwgbGluZURhdGEsIHN0YXJ0Q29sKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gbGluZS5zdWJzdHJpbmcoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICAgICAgICB2YXIgam9pbmVkUmFuZ2VzID0gdGhpcy5fY2hhcmFjdGVySm9pbmVyc1swXS5oYW5kbGVyKHRleHQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMuX2NoYXJhY3RlckpvaW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBqb2luZXJSYW5nZXMgPSB0aGlzLl9jaGFyYWN0ZXJKb2luZXJzW2ldLmhhbmRsZXIodGV4dCk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGpvaW5lclJhbmdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIENoYXJhY3RlckpvaW5lclJlZ2lzdHJ5Ll9tZXJnZVJhbmdlcyhqb2luZWRSYW5nZXMsIGpvaW5lclJhbmdlc1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RyaW5nUmFuZ2VzVG9DZWxsUmFuZ2VzKGpvaW5lZFJhbmdlcywgbGluZURhdGEsIHN0YXJ0Q29sKTtcbiAgICAgICAgcmV0dXJuIGpvaW5lZFJhbmdlcztcbiAgICB9O1xuICAgIENoYXJhY3RlckpvaW5lclJlZ2lzdHJ5LnByb3RvdHlwZS5fc3RyaW5nUmFuZ2VzVG9DZWxsUmFuZ2VzID0gZnVuY3Rpb24gKHJhbmdlcywgbGluZSwgc3RhcnRDb2wpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRSYW5nZUluZGV4ID0gMDtcbiAgICAgICAgdmFyIGN1cnJlbnRSYW5nZVN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGN1cnJlbnRTdHJpbmdJbmRleCA9IDA7XG4gICAgICAgIHZhciBjdXJyZW50UmFuZ2UgPSByYW5nZXNbY3VycmVudFJhbmdlSW5kZXhdO1xuICAgICAgICBpZiAoIWN1cnJlbnRSYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHggPSBzdGFydENvbDsgeCA8IHRoaXMuX3Rlcm1pbmFsLmNvbHM7IHgrKykge1xuICAgICAgICAgICAgdmFyIGNoYXJEYXRhID0gbGluZS5nZXQoeCk7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBjaGFyRGF0YVtCdWZmZXJfMS5DSEFSX0RBVEFfV0lEVEhfSU5ERVhdO1xuICAgICAgICAgICAgdmFyIGxlbmd0aF8xID0gY2hhckRhdGFbQnVmZmVyXzEuQ0hBUl9EQVRBX0NIQVJfSU5ERVhdLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh3aWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjdXJyZW50UmFuZ2VTdGFydGVkICYmIGN1cnJlbnRSYW5nZVswXSA8PSBjdXJyZW50U3RyaW5nSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UmFuZ2VbMF0gPSB4O1xuICAgICAgICAgICAgICAgIGN1cnJlbnRSYW5nZVN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRSYW5nZVsxXSA8PSBjdXJyZW50U3RyaW5nSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UmFuZ2VbMV0gPSB4O1xuICAgICAgICAgICAgICAgIGN1cnJlbnRSYW5nZSA9IHJhbmdlc1srK2N1cnJlbnRSYW5nZUluZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRSYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRSYW5nZVswXSA8PSBjdXJyZW50U3RyaW5nSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFJhbmdlWzBdID0geDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFJhbmdlU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmFuZ2VTdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFN0cmluZ0luZGV4ICs9IGxlbmd0aF8xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50UmFuZ2UpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSYW5nZVsxXSA9IHRoaXMuX3Rlcm1pbmFsLmNvbHM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENoYXJhY3RlckpvaW5lclJlZ2lzdHJ5Ll9tZXJnZVJhbmdlcyA9IGZ1bmN0aW9uIChyYW5nZXMsIG5ld1JhbmdlKSB7XG4gICAgICAgIHZhciBpblJhbmdlID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgICAgICBpZiAoIWluUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3UmFuZ2VbMV0gPD0gcmFuZ2VbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VzLnNwbGljZShpLCAwLCBuZXdSYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXdSYW5nZVsxXSA8PSByYW5nZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICByYW5nZVswXSA9IE1hdGgubWluKG5ld1JhbmdlWzBdLCByYW5nZVswXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXdSYW5nZVswXSA8IHJhbmdlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlWzBdID0gTWF0aC5taW4obmV3UmFuZ2VbMF0sIHJhbmdlWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgaW5SYW5nZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1JhbmdlWzFdIDw9IHJhbmdlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlc1tpIC0gMV1bMV0gPSBuZXdSYW5nZVsxXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5ld1JhbmdlWzFdIDw9IHJhbmdlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlc1tpIC0gMV1bMV0gPSBNYXRoLm1heChuZXdSYW5nZVsxXSwgcmFuZ2VbMV0pO1xuICAgICAgICAgICAgICAgICAgICByYW5nZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBpblJhbmdlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJhbmdlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpblJhbmdlKSB7XG4gICAgICAgICAgICByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdWzFdID0gbmV3UmFuZ2VbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByYW5nZXMucHVzaChuZXdSYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlcztcbiAgICB9O1xuICAgIHJldHVybiBDaGFyYWN0ZXJKb2luZXJSZWdpc3RyeTtcbn0oKSk7XG5leHBvcnRzLkNoYXJhY3RlckpvaW5lclJlZ2lzdHJ5ID0gQ2hhcmFjdGVySm9pbmVyUmVnaXN0cnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DaGFyYWN0ZXJKb2luZXJSZWdpc3RyeS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBERUZBVUxUX0ZPUkVHUk9VTkQgPSBmcm9tSGV4KCcjZmZmZmZmJyk7XG52YXIgREVGQVVMVF9CQUNLR1JPVU5EID0gZnJvbUhleCgnIzAwMDAwMCcpO1xudmFyIERFRkFVTFRfQ1VSU09SID0gZnJvbUhleCgnI2ZmZmZmZicpO1xudmFyIERFRkFVTFRfQ1VSU09SX0FDQ0VOVCA9IGZyb21IZXgoJyMwMDAwMDAnKTtcbnZhciBERUZBVUxUX1NFTEVDVElPTiA9IHtcbiAgICBjc3M6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMyknLFxuICAgIHJnYmE6IDB4RkZGRkZGNzdcbn07XG5leHBvcnRzLkRFRkFVTFRfQU5TSV9DT0xPUlMgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb2xvcnMgPSBbXG4gICAgICAgIGZyb21IZXgoJyMyZTM0MzYnKSxcbiAgICAgICAgZnJvbUhleCgnI2NjMDAwMCcpLFxuICAgICAgICBmcm9tSGV4KCcjNGU5YTA2JyksXG4gICAgICAgIGZyb21IZXgoJyNjNGEwMDAnKSxcbiAgICAgICAgZnJvbUhleCgnIzM0NjVhNCcpLFxuICAgICAgICBmcm9tSGV4KCcjNzU1MDdiJyksXG4gICAgICAgIGZyb21IZXgoJyMwNjk4OWEnKSxcbiAgICAgICAgZnJvbUhleCgnI2QzZDdjZicpLFxuICAgICAgICBmcm9tSGV4KCcjNTU1NzUzJyksXG4gICAgICAgIGZyb21IZXgoJyNlZjI5MjknKSxcbiAgICAgICAgZnJvbUhleCgnIzhhZTIzNCcpLFxuICAgICAgICBmcm9tSGV4KCcjZmNlOTRmJyksXG4gICAgICAgIGZyb21IZXgoJyM3MjlmY2YnKSxcbiAgICAgICAgZnJvbUhleCgnI2FkN2ZhOCcpLFxuICAgICAgICBmcm9tSGV4KCcjMzRlMmUyJyksXG4gICAgICAgIGZyb21IZXgoJyNlZWVlZWMnKVxuICAgIF07XG4gICAgdmFyIHYgPSBbMHgwMCwgMHg1ZiwgMHg4NywgMHhhZiwgMHhkNywgMHhmZl07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyMTY7IGkrKykge1xuICAgICAgICB2YXIgciA9IHZbKGkgLyAzNikgJSA2IHwgMF07XG4gICAgICAgIHZhciBnID0gdlsoaSAvIDYpICUgNiB8IDBdO1xuICAgICAgICB2YXIgYiA9IHZbaSAlIDZdO1xuICAgICAgICBjb2xvcnMucHVzaCh7XG4gICAgICAgICAgICBjc3M6IFwiI1wiICsgdG9QYWRkZWRIZXgocikgKyB0b1BhZGRlZEhleChnKSArIHRvUGFkZGVkSGV4KGIpLFxuICAgICAgICAgICAgcmdiYTogKChyIDw8IDI0KSB8IChnIDw8IDE2KSB8IChiIDw8IDgpIHwgMHhGRikgPj4+IDBcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuICAgICAgICB2YXIgYyA9IDggKyBpICogMTA7XG4gICAgICAgIHZhciBjaCA9IHRvUGFkZGVkSGV4KGMpO1xuICAgICAgICBjb2xvcnMucHVzaCh7XG4gICAgICAgICAgICBjc3M6IFwiI1wiICsgY2ggKyBjaCArIGNoLFxuICAgICAgICAgICAgcmdiYTogKChjIDw8IDI0KSB8IChjIDw8IDE2KSB8IChjIDw8IDgpIHwgMHhGRikgPj4+IDBcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjb2xvcnM7XG59KSgpO1xuZnVuY3Rpb24gZnJvbUhleChjc3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjc3M6IGNzcyxcbiAgICAgICAgcmdiYTogcGFyc2VJbnQoY3NzLnNsaWNlKDEpLCAxNikgPDwgOCB8IDB4RkZcbiAgICB9O1xufVxuZnVuY3Rpb24gdG9QYWRkZWRIZXgoYykge1xuICAgIHZhciBzID0gYy50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIHMubGVuZ3RoIDwgMiA/ICcwJyArIHMgOiBzO1xufVxudmFyIENvbG9yTWFuYWdlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29sb3JNYW5hZ2VyKGRvY3VtZW50LCBhbGxvd1RyYW5zcGFyZW5jeSkge1xuICAgICAgICB0aGlzLmFsbG93VHJhbnNwYXJlbmN5ID0gYWxsb3dUcmFuc3BhcmVuY3k7XG4gICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gMTtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IDE7XG4gICAgICAgIHRoaXMuX2N0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB0aGlzLl9jdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2NvcHknO1xuICAgICAgICB0aGlzLl9saXRtdXNDb2xvciA9IHRoaXMuX2N0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCAxLCAxKTtcbiAgICAgICAgdGhpcy5jb2xvcnMgPSB7XG4gICAgICAgICAgICBmb3JlZ3JvdW5kOiBERUZBVUxUX0ZPUkVHUk9VTkQsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiBERUZBVUxUX0JBQ0tHUk9VTkQsXG4gICAgICAgICAgICBjdXJzb3I6IERFRkFVTFRfQ1VSU09SLFxuICAgICAgICAgICAgY3Vyc29yQWNjZW50OiBERUZBVUxUX0NVUlNPUl9BQ0NFTlQsXG4gICAgICAgICAgICBzZWxlY3Rpb246IERFRkFVTFRfU0VMRUNUSU9OLFxuICAgICAgICAgICAgYW5zaTogZXhwb3J0cy5ERUZBVUxUX0FOU0lfQ09MT1JTLnNsaWNlKClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgQ29sb3JNYW5hZ2VyLnByb3RvdHlwZS5zZXRUaGVtZSA9IGZ1bmN0aW9uICh0aGVtZSkge1xuICAgICAgICB0aGlzLmNvbG9ycy5mb3JlZ3JvdW5kID0gdGhpcy5fcGFyc2VDb2xvcih0aGVtZS5mb3JlZ3JvdW5kLCBERUZBVUxUX0ZPUkVHUk9VTkQpO1xuICAgICAgICB0aGlzLmNvbG9ycy5iYWNrZ3JvdW5kID0gdGhpcy5fcGFyc2VDb2xvcih0aGVtZS5iYWNrZ3JvdW5kLCBERUZBVUxUX0JBQ0tHUk9VTkQpO1xuICAgICAgICB0aGlzLmNvbG9ycy5jdXJzb3IgPSB0aGlzLl9wYXJzZUNvbG9yKHRoZW1lLmN1cnNvciwgREVGQVVMVF9DVVJTT1IsIHRydWUpO1xuICAgICAgICB0aGlzLmNvbG9ycy5jdXJzb3JBY2NlbnQgPSB0aGlzLl9wYXJzZUNvbG9yKHRoZW1lLmN1cnNvckFjY2VudCwgREVGQVVMVF9DVVJTT1JfQUNDRU5ULCB0cnVlKTtcbiAgICAgICAgdGhpcy5jb2xvcnMuc2VsZWN0aW9uID0gdGhpcy5fcGFyc2VDb2xvcih0aGVtZS5zZWxlY3Rpb24sIERFRkFVTFRfU0VMRUNUSU9OLCB0cnVlKTtcbiAgICAgICAgdGhpcy5jb2xvcnMuYW5zaVswXSA9IHRoaXMuX3BhcnNlQ29sb3IodGhlbWUuYmxhY2ssIGV4cG9ydHMuREVGQVVMVF9BTlNJX0NPTE9SU1swXSk7XG4gICAgICAgIHRoaXMuY29sb3JzLmFuc2lbMV0gPSB0aGlzLl9wYXJzZUNvbG9yKHRoZW1lLnJlZCwgZXhwb3J0cy5ERUZBVUxUX0FOU0lfQ09MT1JTWzFdKTtcbiAgICAgICAgdGhpcy5jb2xvcnMuYW5zaVsyXSA9IHRoaXMuX3BhcnNlQ29sb3IodGhlbWUuZ3JlZW4sIGV4cG9ydHMuREVGQVVMVF9BTlNJX0NPTE9SU1syXSk7XG4gICAgICAgIHRoaXMuY29sb3JzLmFuc2lbM10gPSB0aGlzLl9wYXJzZUNvbG9yKHRoZW1lLnllbGxvdywgZXhwb3J0cy5ERUZBVUxUX0FOU0lfQ09MT1JTWzNdKTtcbiAgICAgICAgdGhpcy5jb2xvcnMuYW5zaVs0XSA9IHRoaXMuX3BhcnNlQ29sb3IodGhlbWUuYmx1ZSwgZXhwb3J0cy5ERUZBVUxUX0FOU0lfQ09MT1JTWzRdKTtcbiAgICAgICAgdGhpcy5jb2xvcnMuYW5zaVs1XSA9IHRoaXMuX3BhcnNlQ29sb3IodGhlbWUubWFnZW50YSwgZXhwb3J0cy5ERUZBVUxUX0FOU0lfQ09MT1JTWzVdKTtcbiAgICAgICAgdGhpcy5jb2xvcnMuYW5zaVs2XSA9IHRoaXMuX3BhcnNlQ29sb3IodGhlbWUuY3lhbiwgZXhwb3J0cy5ERUZBVUxUX0FOU0lfQ09MT1JTWzZdKTtcbiAgICAgICAgdGhpcy5jb2xvcnMuYW5zaVs3XSA9IHRoaXMuX3BhcnNlQ29sb3IodGhlbWUud2hpdGUsIGV4cG9ydHMuREVGQVVMVF9BTlNJX0NPTE9SU1s3XSk7XG4gICAgICAgIHRoaXMuY29sb3JzLmFuc2lbOF0gPSB0aGlzLl9wYXJzZUNvbG9yKHRoZW1lLmJyaWdodEJsYWNrLCBleHBvcnRzLkRFRkFVTFRfQU5TSV9DT0xPUlNbOF0pO1xuICAgICAgICB0aGlzLmNvbG9ycy5hbnNpWzldID0gdGhpcy5fcGFyc2VDb2xvcih0aGVtZS5icmlnaHRSZWQsIGV4cG9ydHMuREVGQVVMVF9BTlNJX0NPTE9SU1s5XSk7XG4gICAgICAgIHRoaXMuY29sb3JzLmFuc2lbMTBdID0gdGhpcy5fcGFyc2VDb2xvcih0aGVtZS5icmlnaHRHcmVlbiwgZXhwb3J0cy5ERUZBVUxUX0FOU0lfQ09MT1JTWzEwXSk7XG4gICAgICAgIHRoaXMuY29sb3JzLmFuc2lbMTFdID0gdGhpcy5fcGFyc2VDb2xvcih0aGVtZS5icmlnaHRZZWxsb3csIGV4cG9ydHMuREVGQVVMVF9BTlNJX0NPTE9SU1sxMV0pO1xuICAgICAgICB0aGlzLmNvbG9ycy5hbnNpWzEyXSA9IHRoaXMuX3BhcnNlQ29sb3IodGhlbWUuYnJpZ2h0Qmx1ZSwgZXhwb3J0cy5ERUZBVUxUX0FOU0lfQ09MT1JTWzEyXSk7XG4gICAgICAgIHRoaXMuY29sb3JzLmFuc2lbMTNdID0gdGhpcy5fcGFyc2VDb2xvcih0aGVtZS5icmlnaHRNYWdlbnRhLCBleHBvcnRzLkRFRkFVTFRfQU5TSV9DT0xPUlNbMTNdKTtcbiAgICAgICAgdGhpcy5jb2xvcnMuYW5zaVsxNF0gPSB0aGlzLl9wYXJzZUNvbG9yKHRoZW1lLmJyaWdodEN5YW4sIGV4cG9ydHMuREVGQVVMVF9BTlNJX0NPTE9SU1sxNF0pO1xuICAgICAgICB0aGlzLmNvbG9ycy5hbnNpWzE1XSA9IHRoaXMuX3BhcnNlQ29sb3IodGhlbWUuYnJpZ2h0V2hpdGUsIGV4cG9ydHMuREVGQVVMVF9BTlNJX0NPTE9SU1sxNV0pO1xuICAgIH07XG4gICAgQ29sb3JNYW5hZ2VyLnByb3RvdHlwZS5fcGFyc2VDb2xvciA9IGZ1bmN0aW9uIChjc3MsIGZhbGxiYWNrLCBhbGxvd1RyYW5zcGFyZW5jeSkge1xuICAgICAgICBpZiAoYWxsb3dUcmFuc3BhcmVuY3kgPT09IHZvaWQgMCkgeyBhbGxvd1RyYW5zcGFyZW5jeSA9IHRoaXMuYWxsb3dUcmFuc3BhcmVuY3k7IH1cbiAgICAgICAgaWYgKCFjc3MpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdHguZmlsbFN0eWxlID0gdGhpcy5fbGl0bXVzQ29sb3I7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsU3R5bGUgPSBjc3M7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fY3R4LmZpbGxTdHlsZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNvbG9yOiBcIiArIGNzcyArIFwiIGlzIGludmFsaWQgdXNpbmcgZmFsbGJhY2sgXCIgKyBmYWxsYmFjay5jc3MpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N0eC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9jdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpLmRhdGE7XG4gICAgICAgIGlmICghYWxsb3dUcmFuc3BhcmVuY3kgJiYgZGF0YVszXSAhPT0gMHhGRikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ29sb3I6IFwiICsgY3NzICsgXCIgaXMgdXNpbmcgdHJhbnNwYXJlbmN5LCBidXQgYWxsb3dUcmFuc3BhcmVuY3kgaXMgZmFsc2UuIFwiICtcbiAgICAgICAgICAgICAgICAoXCJVc2luZyBmYWxsYmFjayBcIiArIGZhbGxiYWNrLmNzcyArIFwiLlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNzczogY3NzLFxuICAgICAgICAgICAgcmdiYTogKGRhdGFbMF0gPDwgMjQgfCBkYXRhWzFdIDw8IDE2IHwgZGF0YVsyXSA8PCA4IHwgZGF0YVszXSkgPj4+IDBcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBDb2xvck1hbmFnZXI7XG59KCkpO1xuZXhwb3J0cy5Db2xvck1hbmFnZXIgPSBDb2xvck1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xvck1hbmFnZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEJ1ZmZlcl8xID0gcmVxdWlyZShcIi4uL0J1ZmZlclwiKTtcbnZhciBCYXNlUmVuZGVyTGF5ZXJfMSA9IHJlcXVpcmUoXCIuL0Jhc2VSZW5kZXJMYXllclwiKTtcbnZhciBCTElOS19JTlRFUlZBTCA9IDYwMDtcbnZhciBDdXJzb3JSZW5kZXJMYXllciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEN1cnNvclJlbmRlckxheWVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEN1cnNvclJlbmRlckxheWVyKGNvbnRhaW5lciwgekluZGV4LCBjb2xvcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGFpbmVyLCAnY3Vyc29yJywgekluZGV4LCB0cnVlLCBjb2xvcnMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9zdGF0ZSA9IHtcbiAgICAgICAgICAgIHg6IG51bGwsXG4gICAgICAgICAgICB5OiBudWxsLFxuICAgICAgICAgICAgaXNGb2N1c2VkOiBudWxsLFxuICAgICAgICAgICAgc3R5bGU6IG51bGwsXG4gICAgICAgICAgICB3aWR0aDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5fY3Vyc29yUmVuZGVyZXJzID0ge1xuICAgICAgICAgICAgJ2Jhcic6IF90aGlzLl9yZW5kZXJCYXJDdXJzb3IuYmluZChfdGhpcyksXG4gICAgICAgICAgICAnYmxvY2snOiBfdGhpcy5fcmVuZGVyQmxvY2tDdXJzb3IuYmluZChfdGhpcyksXG4gICAgICAgICAgICAndW5kZXJsaW5lJzogX3RoaXMuX3JlbmRlclVuZGVybGluZUN1cnNvci5iaW5kKF90aGlzKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEN1cnNvclJlbmRlckxheWVyLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAodGVybWluYWwsIGRpbSkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnJlc2l6ZS5jYWxsKHRoaXMsIHRlcm1pbmFsLCBkaW0pO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IHtcbiAgICAgICAgICAgIHg6IG51bGwsXG4gICAgICAgICAgICB5OiBudWxsLFxuICAgICAgICAgICAgaXNGb2N1c2VkOiBudWxsLFxuICAgICAgICAgICAgc3R5bGU6IG51bGwsXG4gICAgICAgICAgICB3aWR0aDogbnVsbFxuICAgICAgICB9O1xuICAgIH07XG4gICAgQ3Vyc29yUmVuZGVyTGF5ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKHRlcm1pbmFsKSB7XG4gICAgICAgIHRoaXMuX2NsZWFyQ3Vyc29yKCk7XG4gICAgICAgIGlmICh0aGlzLl9jdXJzb3JCbGlua1N0YXRlTWFuYWdlcikge1xuICAgICAgICAgICAgdGhpcy5fY3Vyc29yQmxpbmtTdGF0ZU1hbmFnZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5fY3Vyc29yQmxpbmtTdGF0ZU1hbmFnZXIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5vbk9wdGlvbnNDaGFuZ2VkKHRlcm1pbmFsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ3Vyc29yUmVuZGVyTGF5ZXIucHJvdG90eXBlLm9uQmx1ciA9IGZ1bmN0aW9uICh0ZXJtaW5hbCkge1xuICAgICAgICBpZiAodGhpcy5fY3Vyc29yQmxpbmtTdGF0ZU1hbmFnZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvckJsaW5rU3RhdGVNYW5hZ2VyLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGVybWluYWwucmVmcmVzaCh0ZXJtaW5hbC5idWZmZXIueSwgdGVybWluYWwuYnVmZmVyLnkpO1xuICAgIH07XG4gICAgQ3Vyc29yUmVuZGVyTGF5ZXIucHJvdG90eXBlLm9uRm9jdXMgPSBmdW5jdGlvbiAodGVybWluYWwpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnNvckJsaW5rU3RhdGVNYW5hZ2VyKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJzb3JCbGlua1N0YXRlTWFuYWdlci5yZXN1bWUodGVybWluYWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGVybWluYWwucmVmcmVzaCh0ZXJtaW5hbC5idWZmZXIueSwgdGVybWluYWwuYnVmZmVyLnkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDdXJzb3JSZW5kZXJMYXllci5wcm90b3R5cGUub25PcHRpb25zQ2hhbmdlZCA9IGZ1bmN0aW9uICh0ZXJtaW5hbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGVybWluYWwub3B0aW9ucy5jdXJzb3JCbGluaykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jdXJzb3JCbGlua1N0YXRlTWFuYWdlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnNvckJsaW5rU3RhdGVNYW5hZ2VyID0gbmV3IEN1cnNvckJsaW5rU3RhdGVNYW5hZ2VyKHRlcm1pbmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZW5kZXIodGVybWluYWwsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnNvckJsaW5rU3RhdGVNYW5hZ2VyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3Vyc29yQmxpbmtTdGF0ZU1hbmFnZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnNvckJsaW5rU3RhdGVNYW5hZ2VyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlcm1pbmFsLnJlZnJlc2godGVybWluYWwuYnVmZmVyLnksIHRlcm1pbmFsLmJ1ZmZlci55KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ3Vyc29yUmVuZGVyTGF5ZXIucHJvdG90eXBlLm9uQ3Vyc29yTW92ZSA9IGZ1bmN0aW9uICh0ZXJtaW5hbCkge1xuICAgICAgICBpZiAodGhpcy5fY3Vyc29yQmxpbmtTdGF0ZU1hbmFnZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvckJsaW5rU3RhdGVNYW5hZ2VyLnJlc3RhcnRCbGlua0FuaW1hdGlvbih0ZXJtaW5hbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEN1cnNvclJlbmRlckxheWVyLnByb3RvdHlwZS5vbkdyaWRDaGFuZ2VkID0gZnVuY3Rpb24gKHRlcm1pbmFsLCBzdGFydFJvdywgZW5kUm93KSB7XG4gICAgICAgIGlmICghdGhpcy5fY3Vyc29yQmxpbmtTdGF0ZU1hbmFnZXIgfHwgdGhpcy5fY3Vyc29yQmxpbmtTdGF0ZU1hbmFnZXIuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcih0ZXJtaW5hbCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY3Vyc29yQmxpbmtTdGF0ZU1hbmFnZXIucmVzdGFydEJsaW5rQW5pbWF0aW9uKHRlcm1pbmFsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ3Vyc29yUmVuZGVyTGF5ZXIucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAodGVybWluYWwsIHRyaWdnZXJlZEJ5QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgaWYgKCF0ZXJtaW5hbC5jdXJzb3JTdGF0ZSB8fCB0ZXJtaW5hbC5jdXJzb3JIaWRkZW4pIHtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyQ3Vyc29yKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnNvclkgPSB0ZXJtaW5hbC5idWZmZXIueWJhc2UgKyB0ZXJtaW5hbC5idWZmZXIueTtcbiAgICAgICAgdmFyIHZpZXdwb3J0UmVsYXRpdmVDdXJzb3JZID0gY3Vyc29yWSAtIHRlcm1pbmFsLmJ1ZmZlci55ZGlzcDtcbiAgICAgICAgaWYgKHZpZXdwb3J0UmVsYXRpdmVDdXJzb3JZIDwgMCB8fCB2aWV3cG9ydFJlbGF0aXZlQ3Vyc29yWSA+PSB0ZXJtaW5hbC5yb3dzKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGVhckN1cnNvcigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFyRGF0YSA9IHRlcm1pbmFsLmJ1ZmZlci5saW5lcy5nZXQoY3Vyc29yWSkuZ2V0KHRlcm1pbmFsLmJ1ZmZlci54KTtcbiAgICAgICAgaWYgKCFjaGFyRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGVybWluYWwuaXNGb2N1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGVhckN1cnNvcigpO1xuICAgICAgICAgICAgdGhpcy5fY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIHRoaXMuX2N0eC5maWxsU3R5bGUgPSB0aGlzLl9jb2xvcnMuY3Vyc29yLmNzcztcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckJsdXJDdXJzb3IodGVybWluYWwsIHRlcm1pbmFsLmJ1ZmZlci54LCB2aWV3cG9ydFJlbGF0aXZlQ3Vyc29yWSwgY2hhckRhdGEpO1xuICAgICAgICAgICAgdGhpcy5fY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlLnggPSB0ZXJtaW5hbC5idWZmZXIueDtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlLnkgPSB2aWV3cG9ydFJlbGF0aXZlQ3Vyc29yWTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlLmlzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUuc3R5bGUgPSB0ZXJtaW5hbC5vcHRpb25zLmN1cnNvclN0eWxlO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUud2lkdGggPSBjaGFyRGF0YVtCdWZmZXJfMS5DSEFSX0RBVEFfV0lEVEhfSU5ERVhdO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jdXJzb3JCbGlua1N0YXRlTWFuYWdlciAmJiAhdGhpcy5fY3Vyc29yQmxpbmtTdGF0ZU1hbmFnZXIuaXNDdXJzb3JWaXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGVhckN1cnNvcigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnggPT09IHRlcm1pbmFsLmJ1ZmZlci54ICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUueSA9PT0gdmlld3BvcnRSZWxhdGl2ZUN1cnNvclkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZS5pc0ZvY3VzZWQgPT09IHRlcm1pbmFsLmlzRm9jdXNlZCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlLnN0eWxlID09PSB0ZXJtaW5hbC5vcHRpb25zLmN1cnNvclN0eWxlICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUud2lkdGggPT09IGNoYXJEYXRhW0J1ZmZlcl8xLkNIQVJfREFUQV9XSURUSF9JTkRFWF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jbGVhckN1cnNvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N0eC5zYXZlKCk7XG4gICAgICAgIHRoaXMuX2N1cnNvclJlbmRlcmVyc1t0ZXJtaW5hbC5vcHRpb25zLmN1cnNvclN0eWxlIHx8ICdibG9jayddKHRlcm1pbmFsLCB0ZXJtaW5hbC5idWZmZXIueCwgdmlld3BvcnRSZWxhdGl2ZUN1cnNvclksIGNoYXJEYXRhKTtcbiAgICAgICAgdGhpcy5fY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgdGhpcy5fc3RhdGUueCA9IHRlcm1pbmFsLmJ1ZmZlci54O1xuICAgICAgICB0aGlzLl9zdGF0ZS55ID0gdmlld3BvcnRSZWxhdGl2ZUN1cnNvclk7XG4gICAgICAgIHRoaXMuX3N0YXRlLmlzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdGF0ZS5zdHlsZSA9IHRlcm1pbmFsLm9wdGlvbnMuY3Vyc29yU3R5bGU7XG4gICAgICAgIHRoaXMuX3N0YXRlLndpZHRoID0gY2hhckRhdGFbQnVmZmVyXzEuQ0hBUl9EQVRBX1dJRFRIX0lOREVYXTtcbiAgICB9O1xuICAgIEN1cnNvclJlbmRlckxheWVyLnByb3RvdHlwZS5fY2xlYXJDdXJzb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5jbGVhckNlbGxzKHRoaXMuX3N0YXRlLngsIHRoaXMuX3N0YXRlLnksIHRoaXMuX3N0YXRlLndpZHRoLCAxKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0ge1xuICAgICAgICAgICAgICAgIHg6IG51bGwsXG4gICAgICAgICAgICAgICAgeTogbnVsbCxcbiAgICAgICAgICAgICAgICBpc0ZvY3VzZWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgc3R5bGU6IG51bGwsXG4gICAgICAgICAgICAgICAgd2lkdGg6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEN1cnNvclJlbmRlckxheWVyLnByb3RvdHlwZS5fcmVuZGVyQmFyQ3Vyc29yID0gZnVuY3Rpb24gKHRlcm1pbmFsLCB4LCB5LCBjaGFyRGF0YSkge1xuICAgICAgICB0aGlzLl9jdHguc2F2ZSgpO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFN0eWxlID0gdGhpcy5fY29sb3JzLmN1cnNvci5jc3M7XG4gICAgICAgIHRoaXMuZmlsbExlZnRMaW5lQXRDZWxsKHgsIHkpO1xuICAgICAgICB0aGlzLl9jdHgucmVzdG9yZSgpO1xuICAgIH07XG4gICAgQ3Vyc29yUmVuZGVyTGF5ZXIucHJvdG90eXBlLl9yZW5kZXJCbG9ja0N1cnNvciA9IGZ1bmN0aW9uICh0ZXJtaW5hbCwgeCwgeSwgY2hhckRhdGEpIHtcbiAgICAgICAgdGhpcy5fY3R4LnNhdmUoKTtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxTdHlsZSA9IHRoaXMuX2NvbG9ycy5jdXJzb3IuY3NzO1xuICAgICAgICB0aGlzLmZpbGxDZWxscyh4LCB5LCBjaGFyRGF0YVtCdWZmZXJfMS5DSEFSX0RBVEFfV0lEVEhfSU5ERVhdLCAxKTtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxTdHlsZSA9IHRoaXMuX2NvbG9ycy5jdXJzb3JBY2NlbnQuY3NzO1xuICAgICAgICB0aGlzLmZpbGxDaGFyVHJ1ZUNvbG9yKHRlcm1pbmFsLCBjaGFyRGF0YSwgeCwgeSk7XG4gICAgICAgIHRoaXMuX2N0eC5yZXN0b3JlKCk7XG4gICAgfTtcbiAgICBDdXJzb3JSZW5kZXJMYXllci5wcm90b3R5cGUuX3JlbmRlclVuZGVybGluZUN1cnNvciA9IGZ1bmN0aW9uICh0ZXJtaW5hbCwgeCwgeSwgY2hhckRhdGEpIHtcbiAgICAgICAgdGhpcy5fY3R4LnNhdmUoKTtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxTdHlsZSA9IHRoaXMuX2NvbG9ycy5jdXJzb3IuY3NzO1xuICAgICAgICB0aGlzLmZpbGxCb3R0b21MaW5lQXRDZWxscyh4LCB5KTtcbiAgICAgICAgdGhpcy5fY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIEN1cnNvclJlbmRlckxheWVyLnByb3RvdHlwZS5fcmVuZGVyQmx1ckN1cnNvciA9IGZ1bmN0aW9uICh0ZXJtaW5hbCwgeCwgeSwgY2hhckRhdGEpIHtcbiAgICAgICAgdGhpcy5fY3R4LnNhdmUoKTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5fY29sb3JzLmN1cnNvci5jc3M7XG4gICAgICAgIHRoaXMuc3Ryb2tlUmVjdEF0Q2VsbCh4LCB5LCBjaGFyRGF0YVtCdWZmZXJfMS5DSEFSX0RBVEFfV0lEVEhfSU5ERVhdLCAxKTtcbiAgICAgICAgdGhpcy5fY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIHJldHVybiBDdXJzb3JSZW5kZXJMYXllcjtcbn0oQmFzZVJlbmRlckxheWVyXzEuQmFzZVJlbmRlckxheWVyKSk7XG5leHBvcnRzLkN1cnNvclJlbmRlckxheWVyID0gQ3Vyc29yUmVuZGVyTGF5ZXI7XG52YXIgQ3Vyc29yQmxpbmtTdGF0ZU1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEN1cnNvckJsaW5rU3RhdGVNYW5hZ2VyKHRlcm1pbmFsLCBfcmVuZGVyQ2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyQ2FsbGJhY2sgPSBfcmVuZGVyQ2FsbGJhY2s7XG4gICAgICAgIHRoaXMuaXNDdXJzb3JWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRlcm1pbmFsLmlzRm9jdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVzdGFydEludGVydmFsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEN1cnNvckJsaW5rU3RhdGVNYW5hZ2VyLnByb3RvdHlwZSwgXCJpc1BhdXNlZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gISh0aGlzLl9ibGlua1N0YXJ0VGltZW91dCB8fCB0aGlzLl9ibGlua0ludGVydmFsKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ3Vyc29yQmxpbmtTdGF0ZU1hbmFnZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9ibGlua0ludGVydmFsKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLl9ibGlua0ludGVydmFsKTtcbiAgICAgICAgICAgIHRoaXMuX2JsaW5rSW50ZXJ2YWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9ibGlua1N0YXJ0VGltZW91dCkge1xuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLl9ibGlua1N0YXJ0VGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLl9ibGlua1N0YXJ0VGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2FuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fYW5pbWF0aW9uRnJhbWUpO1xuICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uRnJhbWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDdXJzb3JCbGlua1N0YXRlTWFuYWdlci5wcm90b3R5cGUucmVzdGFydEJsaW5rQW5pbWF0aW9uID0gZnVuY3Rpb24gKHRlcm1pbmFsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmlzUGF1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uVGltZVJlc3RhcnRlZCA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuaXNDdXJzb3JWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLl9hbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVuZGVyQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fYW5pbWF0aW9uRnJhbWUgPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEN1cnNvckJsaW5rU3RhdGVNYW5hZ2VyLnByb3RvdHlwZS5fcmVzdGFydEludGVydmFsID0gZnVuY3Rpb24gKHRpbWVUb1N0YXJ0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aW1lVG9TdGFydCA9PT0gdm9pZCAwKSB7IHRpbWVUb1N0YXJ0ID0gQkxJTktfSU5URVJWQUw7IH1cbiAgICAgICAgaWYgKHRoaXMuX2JsaW5rSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuX2JsaW5rSW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2JsaW5rU3RhcnRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX2FuaW1hdGlvblRpbWVSZXN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGltZSA9IEJMSU5LX0lOVEVSVkFMIC0gKERhdGUubm93KCkgLSBfdGhpcy5fYW5pbWF0aW9uVGltZVJlc3RhcnRlZCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2FuaW1hdGlvblRpbWVSZXN0YXJ0ZWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVzdGFydEludGVydmFsKHRpbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuaXNDdXJzb3JWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBfdGhpcy5fYW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVuZGVyQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fYW5pbWF0aW9uRnJhbWUgPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpcy5fYmxpbmtJbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2FuaW1hdGlvblRpbWVSZXN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWUgPSBCTElOS19JTlRFUlZBTCAtIChEYXRlLm5vdygpIC0gX3RoaXMuX2FuaW1hdGlvblRpbWVSZXN0YXJ0ZWQpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYW5pbWF0aW9uVGltZVJlc3RhcnRlZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXN0YXJ0SW50ZXJ2YWwodGltZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuaXNDdXJzb3JWaXNpYmxlID0gIV90aGlzLmlzQ3Vyc29yVmlzaWJsZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fYW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlbmRlckNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9hbmltYXRpb25GcmFtZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBCTElOS19JTlRFUlZBTCk7XG4gICAgICAgIH0sIHRpbWVUb1N0YXJ0KTtcbiAgICB9O1xuICAgIEN1cnNvckJsaW5rU3RhdGVNYW5hZ2VyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc0N1cnNvclZpc2libGUgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fYmxpbmtJbnRlcnZhbCkge1xuICAgICAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5fYmxpbmtJbnRlcnZhbCk7XG4gICAgICAgICAgICB0aGlzLl9ibGlua0ludGVydmFsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYmxpbmtTdGFydFRpbWVvdXQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5fYmxpbmtTdGFydFRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5fYmxpbmtTdGFydFRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9hbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX2FuaW1hdGlvbkZyYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbkZyYW1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ3Vyc29yQmxpbmtTdGF0ZU1hbmFnZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICh0ZXJtaW5hbCkge1xuICAgICAgICB0aGlzLl9hbmltYXRpb25UaW1lUmVzdGFydGVkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmVzdGFydEludGVydmFsKCk7XG4gICAgICAgIHRoaXMucmVzdGFydEJsaW5rQW5pbWF0aW9uKHRlcm1pbmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBDdXJzb3JCbGlua1N0YXRlTWFuYWdlcjtcbn0oKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DdXJzb3JSZW5kZXJMYXllci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBHcmlkQ2FjaGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdyaWRDYWNoZSgpIHtcbiAgICAgICAgdGhpcy5jYWNoZSA9IFtdO1xuICAgIH1cbiAgICBHcmlkQ2FjaGUucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FjaGUubGVuZ3RoIDw9IHgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlLnB1c2goW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgeSA9IHRoaXMuY2FjaGVbeF0ubGVuZ3RoOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlW3hdLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNhY2hlW3hdLmxlbmd0aCA9IGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhY2hlLmxlbmd0aCA9IHdpZHRoO1xuICAgIH07XG4gICAgR3JpZENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB0aGlzLmNhY2hlLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHRoaXMuY2FjaGVbeF0ubGVuZ3RoOyB5KyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlW3hdW3ldID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEdyaWRDYWNoZTtcbn0oKSk7XG5leHBvcnRzLkdyaWRDYWNoZSA9IEdyaWRDYWNoZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyaWRDYWNoZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQmFzZVJlbmRlckxheWVyXzEgPSByZXF1aXJlKFwiLi9CYXNlUmVuZGVyTGF5ZXJcIik7XG52YXIgVHlwZXNfMSA9IHJlcXVpcmUoXCIuL2F0bGFzL1R5cGVzXCIpO1xudmFyIExpbmtSZW5kZXJMYXllciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpbmtSZW5kZXJMYXllciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaW5rUmVuZGVyTGF5ZXIoY29udGFpbmVyLCB6SW5kZXgsIGNvbG9ycywgdGVybWluYWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGFpbmVyLCAnbGluaycsIHpJbmRleCwgdHJ1ZSwgY29sb3JzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fc3RhdGUgPSBudWxsO1xuICAgICAgICB0ZXJtaW5hbC5saW5raWZpZXIub24oXCJsaW5raG92ZXJcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLl9vbkxpbmtIb3ZlcihlKTsgfSk7XG4gICAgICAgIHRlcm1pbmFsLmxpbmtpZmllci5vbihcImxpbmtsZWF2ZVwiLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3RoaXMuX29uTGlua0xlYXZlKGUpOyB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBMaW5rUmVuZGVyTGF5ZXIucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uICh0ZXJtaW5hbCwgZGltKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUucmVzaXplLmNhbGwodGhpcywgdGVybWluYWwsIGRpbSk7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gbnVsbDtcbiAgICB9O1xuICAgIExpbmtSZW5kZXJMYXllci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAodGVybWluYWwpIHtcbiAgICAgICAgdGhpcy5fY2xlYXJDdXJyZW50TGluaygpO1xuICAgIH07XG4gICAgTGlua1JlbmRlckxheWVyLnByb3RvdHlwZS5fY2xlYXJDdXJyZW50TGluayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyQ2VsbHModGhpcy5fc3RhdGUueDEsIHRoaXMuX3N0YXRlLnkxLCB0aGlzLl9zdGF0ZS5jb2xzIC0gdGhpcy5fc3RhdGUueDEsIDEpO1xuICAgICAgICAgICAgdmFyIG1pZGRsZVJvd0NvdW50ID0gdGhpcy5fc3RhdGUueTIgLSB0aGlzLl9zdGF0ZS55MSAtIDE7XG4gICAgICAgICAgICBpZiAobWlkZGxlUm93Q291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckNlbGxzKDAsIHRoaXMuX3N0YXRlLnkxICsgMSwgdGhpcy5fc3RhdGUuY29scywgbWlkZGxlUm93Q291bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbGVhckNlbGxzKDAsIHRoaXMuX3N0YXRlLnkyLCB0aGlzLl9zdGF0ZS54MiwgMSk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExpbmtSZW5kZXJMYXllci5wcm90b3R5cGUuX29uTGlua0hvdmVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUuZmcgPT09IFR5cGVzXzEuSU5WRVJURURfREVGQVVMVF9DT0xPUikge1xuICAgICAgICAgICAgdGhpcy5fY3R4LmZpbGxTdHlsZSA9IHRoaXMuX2NvbG9ycy5iYWNrZ3JvdW5kLmNzcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlLmZnIDwgMjU2KSB7XG4gICAgICAgICAgICB0aGlzLl9jdHguZmlsbFN0eWxlID0gdGhpcy5fY29sb3JzLmFuc2lbZS5mZ10uY3NzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY3R4LmZpbGxTdHlsZSA9IHRoaXMuX2NvbG9ycy5mb3JlZ3JvdW5kLmNzcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS55MSA9PT0gZS55Mikge1xuICAgICAgICAgICAgdGhpcy5maWxsQm90dG9tTGluZUF0Q2VsbHMoZS54MSwgZS55MSwgZS54MiAtIGUueDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5maWxsQm90dG9tTGluZUF0Q2VsbHMoZS54MSwgZS55MSwgZS5jb2xzIC0gZS54MSk7XG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gZS55MSArIDE7IHkgPCBlLnkyOyB5KyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGxCb3R0b21MaW5lQXRDZWxscygwLCB5LCBlLmNvbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5maWxsQm90dG9tTGluZUF0Q2VsbHMoMCwgZS55MiwgZS54Mik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhdGUgPSBlO1xuICAgIH07XG4gICAgTGlua1JlbmRlckxheWVyLnByb3RvdHlwZS5fb25MaW5rTGVhdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl9jbGVhckN1cnJlbnRMaW5rKCk7XG4gICAgfTtcbiAgICByZXR1cm4gTGlua1JlbmRlckxheWVyO1xufShCYXNlUmVuZGVyTGF5ZXJfMS5CYXNlUmVuZGVyTGF5ZXIpKTtcbmV4cG9ydHMuTGlua1JlbmRlckxheWVyID0gTGlua1JlbmRlckxheWVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGlua1JlbmRlckxheWVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBUZXh0UmVuZGVyTGF5ZXJfMSA9IHJlcXVpcmUoXCIuL1RleHRSZW5kZXJMYXllclwiKTtcbnZhciBTZWxlY3Rpb25SZW5kZXJMYXllcl8xID0gcmVxdWlyZShcIi4vU2VsZWN0aW9uUmVuZGVyTGF5ZXJcIik7XG52YXIgQ3Vyc29yUmVuZGVyTGF5ZXJfMSA9IHJlcXVpcmUoXCIuL0N1cnNvclJlbmRlckxheWVyXCIpO1xudmFyIENvbG9yTWFuYWdlcl8xID0gcmVxdWlyZShcIi4vQ29sb3JNYW5hZ2VyXCIpO1xudmFyIExpbmtSZW5kZXJMYXllcl8xID0gcmVxdWlyZShcIi4vTGlua1JlbmRlckxheWVyXCIpO1xudmFyIEV2ZW50RW1pdHRlcl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9FdmVudEVtaXR0ZXJcIik7XG52YXIgUmVuZGVyRGVib3VuY2VyXzEgPSByZXF1aXJlKFwiLi4vdWkvUmVuZGVyRGVib3VuY2VyXCIpO1xudmFyIFNjcmVlbkRwck1vbml0b3JfMSA9IHJlcXVpcmUoXCIuLi91aS9TY3JlZW5EcHJNb25pdG9yXCIpO1xudmFyIENoYXJhY3RlckpvaW5lclJlZ2lzdHJ5XzEgPSByZXF1aXJlKFwiLi4vcmVuZGVyZXIvQ2hhcmFjdGVySm9pbmVyUmVnaXN0cnlcIik7XG52YXIgUmVuZGVyZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZW5kZXJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZW5kZXJlcihfdGVybWluYWwsIHRoZW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl90ZXJtaW5hbCA9IF90ZXJtaW5hbDtcbiAgICAgICAgX3RoaXMuX2lzUGF1c2VkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLl9uZWVkc0Z1bGxSZWZyZXNoID0gZmFsc2U7XG4gICAgICAgIHZhciBhbGxvd1RyYW5zcGFyZW5jeSA9IF90aGlzLl90ZXJtaW5hbC5vcHRpb25zLmFsbG93VHJhbnNwYXJlbmN5O1xuICAgICAgICBfdGhpcy5jb2xvck1hbmFnZXIgPSBuZXcgQ29sb3JNYW5hZ2VyXzEuQ29sb3JNYW5hZ2VyKGRvY3VtZW50LCBhbGxvd1RyYW5zcGFyZW5jeSk7XG4gICAgICAgIF90aGlzLl9jaGFyYWN0ZXJKb2luZXJSZWdpc3RyeSA9IG5ldyBDaGFyYWN0ZXJKb2luZXJSZWdpc3RyeV8xLkNoYXJhY3RlckpvaW5lclJlZ2lzdHJ5KF90ZXJtaW5hbCk7XG4gICAgICAgIGlmICh0aGVtZSkge1xuICAgICAgICAgICAgX3RoaXMuY29sb3JNYW5hZ2VyLnNldFRoZW1lKHRoZW1lKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5fcmVuZGVyTGF5ZXJzID0gW1xuICAgICAgICAgICAgbmV3IFRleHRSZW5kZXJMYXllcl8xLlRleHRSZW5kZXJMYXllcihfdGhpcy5fdGVybWluYWwuc2NyZWVuRWxlbWVudCwgMCwgX3RoaXMuY29sb3JNYW5hZ2VyLmNvbG9ycywgX3RoaXMuX2NoYXJhY3RlckpvaW5lclJlZ2lzdHJ5LCBhbGxvd1RyYW5zcGFyZW5jeSksXG4gICAgICAgICAgICBuZXcgU2VsZWN0aW9uUmVuZGVyTGF5ZXJfMS5TZWxlY3Rpb25SZW5kZXJMYXllcihfdGhpcy5fdGVybWluYWwuc2NyZWVuRWxlbWVudCwgMSwgX3RoaXMuY29sb3JNYW5hZ2VyLmNvbG9ycyksXG4gICAgICAgICAgICBuZXcgTGlua1JlbmRlckxheWVyXzEuTGlua1JlbmRlckxheWVyKF90aGlzLl90ZXJtaW5hbC5zY3JlZW5FbGVtZW50LCAyLCBfdGhpcy5jb2xvck1hbmFnZXIuY29sb3JzLCBfdGhpcy5fdGVybWluYWwpLFxuICAgICAgICAgICAgbmV3IEN1cnNvclJlbmRlckxheWVyXzEuQ3Vyc29yUmVuZGVyTGF5ZXIoX3RoaXMuX3Rlcm1pbmFsLnNjcmVlbkVsZW1lbnQsIDMsIF90aGlzLmNvbG9yTWFuYWdlci5jb2xvcnMpXG4gICAgICAgIF07XG4gICAgICAgIF90aGlzLmRpbWVuc2lvbnMgPSB7XG4gICAgICAgICAgICBzY2FsZWRDaGFyV2lkdGg6IG51bGwsXG4gICAgICAgICAgICBzY2FsZWRDaGFySGVpZ2h0OiBudWxsLFxuICAgICAgICAgICAgc2NhbGVkQ2VsbFdpZHRoOiBudWxsLFxuICAgICAgICAgICAgc2NhbGVkQ2VsbEhlaWdodDogbnVsbCxcbiAgICAgICAgICAgIHNjYWxlZENoYXJMZWZ0OiBudWxsLFxuICAgICAgICAgICAgc2NhbGVkQ2hhclRvcDogbnVsbCxcbiAgICAgICAgICAgIHNjYWxlZENhbnZhc1dpZHRoOiBudWxsLFxuICAgICAgICAgICAgc2NhbGVkQ2FudmFzSGVpZ2h0OiBudWxsLFxuICAgICAgICAgICAgY2FudmFzV2lkdGg6IG51bGwsXG4gICAgICAgICAgICBjYW52YXNIZWlnaHQ6IG51bGwsXG4gICAgICAgICAgICBhY3R1YWxDZWxsV2lkdGg6IG51bGwsXG4gICAgICAgICAgICBhY3R1YWxDZWxsSGVpZ2h0OiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLl9kZXZpY2VQaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgIF90aGlzLl91cGRhdGVEaW1lbnNpb25zKCk7XG4gICAgICAgIF90aGlzLm9uT3B0aW9uc0NoYW5nZWQoKTtcbiAgICAgICAgX3RoaXMuX3JlbmRlckRlYm91bmNlciA9IG5ldyBSZW5kZXJEZWJvdW5jZXJfMS5SZW5kZXJEZWJvdW5jZXIoX3RoaXMuX3Rlcm1pbmFsLCBfdGhpcy5fcmVuZGVyUm93cy5iaW5kKF90aGlzKSk7XG4gICAgICAgIF90aGlzLl9zY3JlZW5EcHJNb25pdG9yID0gbmV3IFNjcmVlbkRwck1vbml0b3JfMS5TY3JlZW5EcHJNb25pdG9yKCk7XG4gICAgICAgIF90aGlzLl9zY3JlZW5EcHJNb25pdG9yLnNldExpc3RlbmVyKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm9uV2luZG93UmVzaXplKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTsgfSk7XG4gICAgICAgIF90aGlzLnJlZ2lzdGVyKF90aGlzLl9zY3JlZW5EcHJNb25pdG9yKTtcbiAgICAgICAgaWYgKCdJbnRlcnNlY3Rpb25PYnNlcnZlcicgaW4gd2luZG93KSB7XG4gICAgICAgICAgICB2YXIgb2JzZXJ2ZXJfMSA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3RoaXMub25JbnRlcnNlY3Rpb25DaGFuZ2UoZVswXSk7IH0sIHsgdGhyZXNob2xkOiAwIH0pO1xuICAgICAgICAgICAgb2JzZXJ2ZXJfMS5vYnNlcnZlKF90aGlzLl90ZXJtaW5hbC5lbGVtZW50KTtcbiAgICAgICAgICAgIF90aGlzLnJlZ2lzdGVyKHsgZGlzcG9zZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JzZXJ2ZXJfMS5kaXNjb25uZWN0KCk7IH0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZW5kZXJlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX3JlbmRlckxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7IHJldHVybiBsLmRpc3Bvc2UoKTsgfSk7XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUub25JbnRlcnNlY3Rpb25DaGFuZ2UgPSBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyA9PT0gMDtcbiAgICAgICAgaWYgKCF0aGlzLl9pc1BhdXNlZCAmJiB0aGlzLl9uZWVkc0Z1bGxSZWZyZXNoKSB7XG4gICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC5yZWZyZXNoKDAsIHRoaXMuX3Rlcm1pbmFsLnJvd3MgLSAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLm9uV2luZG93UmVzaXplID0gZnVuY3Rpb24gKGRldmljZVBpeGVsUmF0aW8pIHtcbiAgICAgICAgaWYgKHRoaXMuX2RldmljZVBpeGVsUmF0aW8gIT09IGRldmljZVBpeGVsUmF0aW8pIHtcbiAgICAgICAgICAgIHRoaXMuX2RldmljZVBpeGVsUmF0aW8gPSBkZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICAgICAgdGhpcy5vblJlc2l6ZSh0aGlzLl90ZXJtaW5hbC5jb2xzLCB0aGlzLl90ZXJtaW5hbC5yb3dzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnNldFRoZW1lID0gZnVuY3Rpb24gKHRoZW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY29sb3JNYW5hZ2VyLnNldFRoZW1lKHRoZW1lKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyTGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICAgIGwub25UaGVtZUNoYW5nZWQoX3RoaXMuX3Rlcm1pbmFsLCBfdGhpcy5jb2xvck1hbmFnZXIuY29sb3JzKTtcbiAgICAgICAgICAgIGwucmVzZXQoX3RoaXMuX3Rlcm1pbmFsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLl9pc1BhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNGdWxsUmVmcmVzaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC5yZWZyZXNoKDAsIHRoaXMuX3Rlcm1pbmFsLnJvd3MgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb2xvck1hbmFnZXIuY29sb3JzO1xuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLm9uUmVzaXplID0gZnVuY3Rpb24gKGNvbHMsIHJvd3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fdXBkYXRlRGltZW5zaW9ucygpO1xuICAgICAgICB0aGlzLl9yZW5kZXJMYXllcnMuZm9yRWFjaChmdW5jdGlvbiAobCkgeyByZXR1cm4gbC5yZXNpemUoX3RoaXMuX3Rlcm1pbmFsLCBfdGhpcy5kaW1lbnNpb25zKTsgfSk7XG4gICAgICAgIGlmICh0aGlzLl9pc1BhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNGdWxsUmVmcmVzaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC5yZWZyZXNoKDAsIHRoaXMuX3Rlcm1pbmFsLnJvd3MgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90ZXJtaW5hbC5zY3JlZW5FbGVtZW50LnN0eWxlLndpZHRoID0gdGhpcy5kaW1lbnNpb25zLmNhbnZhc1dpZHRoICsgXCJweFwiO1xuICAgICAgICB0aGlzLl90ZXJtaW5hbC5zY3JlZW5FbGVtZW50LnN0eWxlLmhlaWdodCA9IHRoaXMuZGltZW5zaW9ucy5jYW52YXNIZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuZW1pdCgncmVzaXplJywge1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMuZGltZW5zaW9ucy5jYW52YXNXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5kaW1lbnNpb25zLmNhbnZhc0hlaWdodFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5vbkNoYXJTaXplQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vblJlc2l6ZSh0aGlzLl90ZXJtaW5hbC5jb2xzLCB0aGlzLl90ZXJtaW5hbC5yb3dzKTtcbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5vbkJsdXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3J1bk9wZXJhdGlvbihmdW5jdGlvbiAobCkgeyByZXR1cm4gbC5vbkJsdXIoX3RoaXMuX3Rlcm1pbmFsKTsgfSk7XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUub25Gb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fcnVuT3BlcmF0aW9uKGZ1bmN0aW9uIChsKSB7IHJldHVybiBsLm9uRm9jdXMoX3RoaXMuX3Rlcm1pbmFsKTsgfSk7XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUub25TZWxlY3Rpb25DaGFuZ2VkID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIGNvbHVtblNlbGVjdE1vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGNvbHVtblNlbGVjdE1vZGUgPT09IHZvaWQgMCkgeyBjb2x1bW5TZWxlY3RNb2RlID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy5fcnVuT3BlcmF0aW9uKGZ1bmN0aW9uIChsKSB7IHJldHVybiBsLm9uU2VsZWN0aW9uQ2hhbmdlZChfdGhpcy5fdGVybWluYWwsIHN0YXJ0LCBlbmQsIGNvbHVtblNlbGVjdE1vZGUpOyB9KTtcbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5vbkN1cnNvck1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3J1bk9wZXJhdGlvbihmdW5jdGlvbiAobCkgeyByZXR1cm4gbC5vbkN1cnNvck1vdmUoX3RoaXMuX3Rlcm1pbmFsKTsgfSk7XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUub25PcHRpb25zQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jb2xvck1hbmFnZXIuYWxsb3dUcmFuc3BhcmVuY3kgPSB0aGlzLl90ZXJtaW5hbC5vcHRpb25zLmFsbG93VHJhbnNwYXJlbmN5O1xuICAgICAgICB0aGlzLl9ydW5PcGVyYXRpb24oZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGwub25PcHRpb25zQ2hhbmdlZChfdGhpcy5fdGVybWluYWwpOyB9KTtcbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fcnVuT3BlcmF0aW9uKGZ1bmN0aW9uIChsKSB7IHJldHVybiBsLnJlc2V0KF90aGlzLl90ZXJtaW5hbCk7IH0pO1xuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLl9ydW5PcGVyYXRpb24gPSBmdW5jdGlvbiAob3BlcmF0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1BhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNGdWxsUmVmcmVzaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJMYXllcnMuZm9yRWFjaChmdW5jdGlvbiAobCkgeyByZXR1cm4gb3BlcmF0aW9uKGwpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnJlZnJlc2hSb3dzID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzUGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc0Z1bGxSZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW5kZXJEZWJvdW5jZXIucmVmcmVzaChzdGFydCwgZW5kKTtcbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5fcmVuZGVyUm93cyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3JlbmRlckxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7IHJldHVybiBsLm9uR3JpZENoYW5nZWQoX3RoaXMuX3Rlcm1pbmFsLCBzdGFydCwgZW5kKTsgfSk7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsLmVtaXQoJ3JlZnJlc2gnLCB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfSk7XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZURpbWVuc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdGVybWluYWwuY2hhck1lYXN1cmUud2lkdGggfHwgIXRoaXMuX3Rlcm1pbmFsLmNoYXJNZWFzdXJlLmhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGltZW5zaW9ucy5zY2FsZWRDaGFyV2lkdGggPSBNYXRoLmZsb29yKHRoaXMuX3Rlcm1pbmFsLmNoYXJNZWFzdXJlLndpZHRoICogd2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xuICAgICAgICB0aGlzLmRpbWVuc2lvbnMuc2NhbGVkQ2hhckhlaWdodCA9IE1hdGguY2VpbCh0aGlzLl90ZXJtaW5hbC5jaGFyTWVhc3VyZS5oZWlnaHQgKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgICAgIHRoaXMuZGltZW5zaW9ucy5zY2FsZWRDZWxsSGVpZ2h0ID0gTWF0aC5mbG9vcih0aGlzLmRpbWVuc2lvbnMuc2NhbGVkQ2hhckhlaWdodCAqIHRoaXMuX3Rlcm1pbmFsLm9wdGlvbnMubGluZUhlaWdodCk7XG4gICAgICAgIHRoaXMuZGltZW5zaW9ucy5zY2FsZWRDaGFyVG9wID0gdGhpcy5fdGVybWluYWwub3B0aW9ucy5saW5lSGVpZ2h0ID09PSAxID8gMCA6IE1hdGgucm91bmQoKHRoaXMuZGltZW5zaW9ucy5zY2FsZWRDZWxsSGVpZ2h0IC0gdGhpcy5kaW1lbnNpb25zLnNjYWxlZENoYXJIZWlnaHQpIC8gMik7XG4gICAgICAgIHRoaXMuZGltZW5zaW9ucy5zY2FsZWRDZWxsV2lkdGggPSB0aGlzLmRpbWVuc2lvbnMuc2NhbGVkQ2hhcldpZHRoICsgTWF0aC5yb3VuZCh0aGlzLl90ZXJtaW5hbC5vcHRpb25zLmxldHRlclNwYWNpbmcpO1xuICAgICAgICB0aGlzLmRpbWVuc2lvbnMuc2NhbGVkQ2hhckxlZnQgPSBNYXRoLmZsb29yKHRoaXMuX3Rlcm1pbmFsLm9wdGlvbnMubGV0dGVyU3BhY2luZyAvIDIpO1xuICAgICAgICB0aGlzLmRpbWVuc2lvbnMuc2NhbGVkQ2FudmFzSGVpZ2h0ID0gdGhpcy5fdGVybWluYWwucm93cyAqIHRoaXMuZGltZW5zaW9ucy5zY2FsZWRDZWxsSGVpZ2h0O1xuICAgICAgICB0aGlzLmRpbWVuc2lvbnMuc2NhbGVkQ2FudmFzV2lkdGggPSB0aGlzLl90ZXJtaW5hbC5jb2xzICogdGhpcy5kaW1lbnNpb25zLnNjYWxlZENlbGxXaWR0aDtcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zLmNhbnZhc0hlaWdodCA9IE1hdGgucm91bmQodGhpcy5kaW1lbnNpb25zLnNjYWxlZENhbnZhc0hlaWdodCAvIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zLmNhbnZhc1dpZHRoID0gTWF0aC5yb3VuZCh0aGlzLmRpbWVuc2lvbnMuc2NhbGVkQ2FudmFzV2lkdGggLyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgICAgIHRoaXMuZGltZW5zaW9ucy5hY3R1YWxDZWxsSGVpZ2h0ID0gdGhpcy5kaW1lbnNpb25zLmNhbnZhc0hlaWdodCAvIHRoaXMuX3Rlcm1pbmFsLnJvd3M7XG4gICAgICAgIHRoaXMuZGltZW5zaW9ucy5hY3R1YWxDZWxsV2lkdGggPSB0aGlzLmRpbWVuc2lvbnMuY2FudmFzV2lkdGggLyB0aGlzLl90ZXJtaW5hbC5jb2xzO1xuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnJlZ2lzdGVyQ2hhcmFjdGVySm9pbmVyID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYXJhY3RlckpvaW5lclJlZ2lzdHJ5LnJlZ2lzdGVyQ2hhcmFjdGVySm9pbmVyKGhhbmRsZXIpO1xuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLmRlcmVnaXN0ZXJDaGFyYWN0ZXJKb2luZXIgPSBmdW5jdGlvbiAoam9pbmVySWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYXJhY3RlckpvaW5lclJlZ2lzdHJ5LmRlcmVnaXN0ZXJDaGFyYWN0ZXJKb2luZXIoam9pbmVySWQpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlbmRlcmVyO1xufShFdmVudEVtaXR0ZXJfMS5FdmVudEVtaXR0ZXIpKTtcbmV4cG9ydHMuUmVuZGVyZXIgPSBSZW5kZXJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlbmRlcmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBCYXNlUmVuZGVyTGF5ZXJfMSA9IHJlcXVpcmUoXCIuL0Jhc2VSZW5kZXJMYXllclwiKTtcbnZhciBTZWxlY3Rpb25SZW5kZXJMYXllciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlbGVjdGlvblJlbmRlckxheWVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlbGVjdGlvblJlbmRlckxheWVyKGNvbnRhaW5lciwgekluZGV4LCBjb2xvcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGFpbmVyLCAnc2VsZWN0aW9uJywgekluZGV4LCB0cnVlLCBjb2xvcnMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9jbGVhclN0YXRlKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU2VsZWN0aW9uUmVuZGVyTGF5ZXIucHJvdG90eXBlLl9jbGVhclN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBudWxsLFxuICAgICAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICAgICAgY29sdW1uU2VsZWN0TW9kZTogbnVsbCxcbiAgICAgICAgICAgIHlkaXNwOiBudWxsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBTZWxlY3Rpb25SZW5kZXJMYXllci5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKHRlcm1pbmFsLCBkaW0pIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5yZXNpemUuY2FsbCh0aGlzLCB0ZXJtaW5hbCwgZGltKTtcbiAgICAgICAgdGhpcy5fY2xlYXJTdGF0ZSgpO1xuICAgIH07XG4gICAgU2VsZWN0aW9uUmVuZGVyTGF5ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKHRlcm1pbmFsKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zdGFydCAmJiB0aGlzLl9zdGF0ZS5lbmQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyU3RhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJBbGwoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2VsZWN0aW9uUmVuZGVyTGF5ZXIucHJvdG90eXBlLm9uU2VsZWN0aW9uQ2hhbmdlZCA9IGZ1bmN0aW9uICh0ZXJtaW5hbCwgc3RhcnQsIGVuZCwgY29sdW1uU2VsZWN0TW9kZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2RpZFN0YXRlQ2hhbmdlKHN0YXJ0LCBlbmQsIGNvbHVtblNlbGVjdE1vZGUsIHRlcm1pbmFsLmJ1ZmZlci55ZGlzcCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyQWxsKCk7XG4gICAgICAgIGlmICghc3RhcnQgfHwgIWVuZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2aWV3cG9ydFN0YXJ0Um93ID0gc3RhcnRbMV0gLSB0ZXJtaW5hbC5idWZmZXIueWRpc3A7XG4gICAgICAgIHZhciB2aWV3cG9ydEVuZFJvdyA9IGVuZFsxXSAtIHRlcm1pbmFsLmJ1ZmZlci55ZGlzcDtcbiAgICAgICAgdmFyIHZpZXdwb3J0Q2FwcGVkU3RhcnRSb3cgPSBNYXRoLm1heCh2aWV3cG9ydFN0YXJ0Um93LCAwKTtcbiAgICAgICAgdmFyIHZpZXdwb3J0Q2FwcGVkRW5kUm93ID0gTWF0aC5taW4odmlld3BvcnRFbmRSb3csIHRlcm1pbmFsLnJvd3MgLSAxKTtcbiAgICAgICAgaWYgKHZpZXdwb3J0Q2FwcGVkU3RhcnRSb3cgPj0gdGVybWluYWwucm93cyB8fCB2aWV3cG9ydENhcHBlZEVuZFJvdyA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdHguZmlsbFN0eWxlID0gdGhpcy5fY29sb3JzLnNlbGVjdGlvbi5jc3M7XG4gICAgICAgIGlmIChjb2x1bW5TZWxlY3RNb2RlKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRDb2wgPSBzdGFydFswXTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGVuZFswXSAtIHN0YXJ0Q29sO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHZpZXdwb3J0Q2FwcGVkRW5kUm93IC0gdmlld3BvcnRDYXBwZWRTdGFydFJvdyArIDE7XG4gICAgICAgICAgICB0aGlzLmZpbGxDZWxscyhzdGFydENvbCwgdmlld3BvcnRDYXBwZWRTdGFydFJvdywgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRDb2wgPSB2aWV3cG9ydFN0YXJ0Um93ID09PSB2aWV3cG9ydENhcHBlZFN0YXJ0Um93ID8gc3RhcnRbMF0gOiAwO1xuICAgICAgICAgICAgdmFyIHN0YXJ0Um93RW5kQ29sID0gdmlld3BvcnRDYXBwZWRTdGFydFJvdyA9PT0gdmlld3BvcnRDYXBwZWRFbmRSb3cgPyBlbmRbMF0gOiB0ZXJtaW5hbC5jb2xzO1xuICAgICAgICAgICAgdGhpcy5maWxsQ2VsbHMoc3RhcnRDb2wsIHZpZXdwb3J0Q2FwcGVkU3RhcnRSb3csIHN0YXJ0Um93RW5kQ29sIC0gc3RhcnRDb2wsIDEpO1xuICAgICAgICAgICAgdmFyIG1pZGRsZVJvd3NDb3VudCA9IE1hdGgubWF4KHZpZXdwb3J0Q2FwcGVkRW5kUm93IC0gdmlld3BvcnRDYXBwZWRTdGFydFJvdyAtIDEsIDApO1xuICAgICAgICAgICAgdGhpcy5maWxsQ2VsbHMoMCwgdmlld3BvcnRDYXBwZWRTdGFydFJvdyArIDEsIHRlcm1pbmFsLmNvbHMsIG1pZGRsZVJvd3NDb3VudCk7XG4gICAgICAgICAgICBpZiAodmlld3BvcnRDYXBwZWRTdGFydFJvdyAhPT0gdmlld3BvcnRDYXBwZWRFbmRSb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW5kQ29sID0gdmlld3BvcnRFbmRSb3cgPT09IHZpZXdwb3J0Q2FwcGVkRW5kUm93ID8gZW5kWzBdIDogdGVybWluYWwuY29scztcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGxDZWxscygwLCB2aWV3cG9ydENhcHBlZEVuZFJvdywgZW5kQ29sLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGF0ZS5zdGFydCA9IFtzdGFydFswXSwgc3RhcnRbMV1dO1xuICAgICAgICB0aGlzLl9zdGF0ZS5lbmQgPSBbZW5kWzBdLCBlbmRbMV1dO1xuICAgICAgICB0aGlzLl9zdGF0ZS5jb2x1bW5TZWxlY3RNb2RlID0gY29sdW1uU2VsZWN0TW9kZTtcbiAgICAgICAgdGhpcy5fc3RhdGUueWRpc3AgPSB0ZXJtaW5hbC5idWZmZXIueWRpc3A7XG4gICAgfTtcbiAgICBTZWxlY3Rpb25SZW5kZXJMYXllci5wcm90b3R5cGUuX2RpZFN0YXRlQ2hhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIGNvbHVtblNlbGVjdE1vZGUsIHlkaXNwKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5fYXJlQ29vcmRpbmF0ZXNFcXVhbChzdGFydCwgdGhpcy5fc3RhdGUuc3RhcnQpIHx8XG4gICAgICAgICAgICAhdGhpcy5fYXJlQ29vcmRpbmF0ZXNFcXVhbChlbmQsIHRoaXMuX3N0YXRlLmVuZCkgfHxcbiAgICAgICAgICAgIGNvbHVtblNlbGVjdE1vZGUgIT09IHRoaXMuX3N0YXRlLmNvbHVtblNlbGVjdE1vZGUgfHxcbiAgICAgICAgICAgIHlkaXNwICE9PSB0aGlzLl9zdGF0ZS55ZGlzcDtcbiAgICB9O1xuICAgIFNlbGVjdGlvblJlbmRlckxheWVyLnByb3RvdHlwZS5fYXJlQ29vcmRpbmF0ZXNFcXVhbCA9IGZ1bmN0aW9uIChjb29yZDEsIGNvb3JkMikge1xuICAgICAgICBpZiAoIWNvb3JkMSB8fCAhY29vcmQyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvb3JkMVswXSA9PT0gY29vcmQyWzBdICYmIGNvb3JkMVsxXSA9PT0gY29vcmQyWzFdO1xuICAgIH07XG4gICAgcmV0dXJuIFNlbGVjdGlvblJlbmRlckxheWVyO1xufShCYXNlUmVuZGVyTGF5ZXJfMS5CYXNlUmVuZGVyTGF5ZXIpKTtcbmV4cG9ydHMuU2VsZWN0aW9uUmVuZGVyTGF5ZXIgPSBTZWxlY3Rpb25SZW5kZXJMYXllcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNlbGVjdGlvblJlbmRlckxheWVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBCdWZmZXJfMSA9IHJlcXVpcmUoXCIuLi9CdWZmZXJcIik7XG52YXIgVHlwZXNfMSA9IHJlcXVpcmUoXCIuL2F0bGFzL1R5cGVzXCIpO1xudmFyIEdyaWRDYWNoZV8xID0gcmVxdWlyZShcIi4vR3JpZENhY2hlXCIpO1xudmFyIEJhc2VSZW5kZXJMYXllcl8xID0gcmVxdWlyZShcIi4vQmFzZVJlbmRlckxheWVyXCIpO1xudmFyIFRleHRSZW5kZXJMYXllciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRleHRSZW5kZXJMYXllciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUZXh0UmVuZGVyTGF5ZXIoY29udGFpbmVyLCB6SW5kZXgsIGNvbG9ycywgY2hhcmFjdGVySm9pbmVyUmVnaXN0cnksIGFscGhhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRhaW5lciwgJ3RleHQnLCB6SW5kZXgsIGFscGhhLCBjb2xvcnMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9jaGFyYWN0ZXJPdmVybGFwQ2FjaGUgPSB7fTtcbiAgICAgICAgX3RoaXMuX3N0YXRlID0gbmV3IEdyaWRDYWNoZV8xLkdyaWRDYWNoZSgpO1xuICAgICAgICBfdGhpcy5fY2hhcmFjdGVySm9pbmVyUmVnaXN0cnkgPSBjaGFyYWN0ZXJKb2luZXJSZWdpc3RyeTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUZXh0UmVuZGVyTGF5ZXIucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uICh0ZXJtaW5hbCwgZGltKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUucmVzaXplLmNhbGwodGhpcywgdGVybWluYWwsIGRpbSk7XG4gICAgICAgIHZhciB0ZXJtaW5hbEZvbnQgPSB0aGlzLl9nZXRGb250KHRlcm1pbmFsLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5fY2hhcmFjdGVyV2lkdGggIT09IGRpbS5zY2FsZWRDaGFyV2lkdGggfHwgdGhpcy5fY2hhcmFjdGVyRm9udCAhPT0gdGVybWluYWxGb250KSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFyYWN0ZXJXaWR0aCA9IGRpbS5zY2FsZWRDaGFyV2lkdGg7XG4gICAgICAgICAgICB0aGlzLl9jaGFyYWN0ZXJGb250ID0gdGVybWluYWxGb250O1xuICAgICAgICAgICAgdGhpcy5fY2hhcmFjdGVyT3ZlcmxhcENhY2hlID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhdGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fc3RhdGUucmVzaXplKHRlcm1pbmFsLmNvbHMsIHRlcm1pbmFsLnJvd3MpO1xuICAgIH07XG4gICAgVGV4dFJlbmRlckxheWVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICh0ZXJtaW5hbCkge1xuICAgICAgICB0aGlzLl9zdGF0ZS5jbGVhcigpO1xuICAgICAgICB0aGlzLmNsZWFyQWxsKCk7XG4gICAgfTtcbiAgICBUZXh0UmVuZGVyTGF5ZXIucHJvdG90eXBlLl9mb3JFYWNoQ2VsbCA9IGZ1bmN0aW9uICh0ZXJtaW5hbCwgZmlyc3RSb3csIGxhc3RSb3csIGpvaW5lclJlZ2lzdHJ5LCBjYWxsYmFjaykge1xuICAgICAgICBmb3IgKHZhciB5ID0gZmlyc3RSb3c7IHkgPD0gbGFzdFJvdzsgeSsrKSB7XG4gICAgICAgICAgICB2YXIgcm93ID0geSArIHRlcm1pbmFsLmJ1ZmZlci55ZGlzcDtcbiAgICAgICAgICAgIHZhciBsaW5lID0gdGVybWluYWwuYnVmZmVyLmxpbmVzLmdldChyb3cpO1xuICAgICAgICAgICAgdmFyIGpvaW5lZFJhbmdlcyA9IGpvaW5lclJlZ2lzdHJ5ID8gam9pbmVyUmVnaXN0cnkuZ2V0Sm9pbmVkQ2hhcmFjdGVycyhyb3cpIDogW107XG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHRlcm1pbmFsLmNvbHM7IHgrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGFyRGF0YSA9IGxpbmUuZ2V0KHgpO1xuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gY2hhckRhdGFbQnVmZmVyXzEuQ0hBUl9EQVRBX0NPREVfSU5ERVhdO1xuICAgICAgICAgICAgICAgIHZhciBjaGFycyA9IGNoYXJEYXRhW0J1ZmZlcl8xLkNIQVJfREFUQV9DSEFSX0lOREVYXTtcbiAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IGNoYXJEYXRhW0J1ZmZlcl8xLkNIQVJfREFUQV9BVFRSX0lOREVYXTtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBjaGFyRGF0YVtCdWZmZXJfMS5DSEFSX0RBVEFfV0lEVEhfSU5ERVhdO1xuICAgICAgICAgICAgICAgIHZhciBpc0pvaW5lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciBsYXN0Q2hhclggPSB4O1xuICAgICAgICAgICAgICAgIGlmICh3aWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGpvaW5lZFJhbmdlcy5sZW5ndGggPiAwICYmIHggPT09IGpvaW5lZFJhbmdlc1swXVswXSkge1xuICAgICAgICAgICAgICAgICAgICBpc0pvaW5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGpvaW5lZFJhbmdlcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjaGFycyA9IHRlcm1pbmFsLmJ1ZmZlci50cmFuc2xhdGVCdWZmZXJMaW5lVG9TdHJpbmcocm93LCB0cnVlLCByYW5nZVswXSwgcmFuZ2VbMV0pO1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHJhbmdlWzFdIC0gcmFuZ2VbMF07XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdENoYXJYID0gcmFuZ2VbMV0gLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWlzSm9pbmVkICYmIHRoaXMuX2lzT3ZlcmxhcHBpbmcoY2hhckRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0Q2hhclggPCBsaW5lLmxlbmd0aCAtIDEgJiYgbGluZS5nZXQobGFzdENoYXJYICsgMSlbQnVmZmVyXzEuQ0hBUl9EQVRBX0NPREVfSU5ERVhdID09PSBCdWZmZXJfMS5OVUxMX0NFTExfQ09ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBmbGFncyA9IGF0dHIgPj4gMTg7XG4gICAgICAgICAgICAgICAgdmFyIGJnID0gYXR0ciAmIDB4MWZmO1xuICAgICAgICAgICAgICAgIHZhciBmZyA9IChhdHRyID4+IDkpICYgMHgxZmY7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzICYgOCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IGJnO1xuICAgICAgICAgICAgICAgICAgICBiZyA9IGZnO1xuICAgICAgICAgICAgICAgICAgICBmZyA9IHRlbXA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmZyA9PT0gMjU2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmZyA9IFR5cGVzXzEuSU5WRVJURURfREVGQVVMVF9DT0xPUjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYmcgPT09IDI1Nykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmcgPSBUeXBlc18xLklOVkVSVEVEX0RFRkFVTFRfQ09MT1I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soY29kZSwgY2hhcnMsIHdpZHRoLCB4LCB5LCBmZywgYmcsIGZsYWdzKTtcbiAgICAgICAgICAgICAgICB4ID0gbGFzdENoYXJYO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUZXh0UmVuZGVyTGF5ZXIucHJvdG90eXBlLl9kcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uICh0ZXJtaW5hbCwgZmlyc3RSb3csIGxhc3RSb3cpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgdmFyIGNvbHMgPSB0ZXJtaW5hbC5jb2xzO1xuICAgICAgICB2YXIgc3RhcnRYID0gMDtcbiAgICAgICAgdmFyIHN0YXJ0WSA9IDA7XG4gICAgICAgIHZhciBwcmV2RmlsbFN0eWxlID0gbnVsbDtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgdGhpcy5fZm9yRWFjaENlbGwodGVybWluYWwsIGZpcnN0Um93LCBsYXN0Um93LCBudWxsLCBmdW5jdGlvbiAoY29kZSwgY2hhcnMsIHdpZHRoLCB4LCB5LCBmZywgYmcsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgbmV4dEZpbGxTdHlsZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAoYmcgPT09IFR5cGVzXzEuSU5WRVJURURfREVGQVVMVF9DT0xPUikge1xuICAgICAgICAgICAgICAgIG5leHRGaWxsU3R5bGUgPSBfdGhpcy5fY29sb3JzLmZvcmVncm91bmQuY3NzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmcgPCAyNTYpIHtcbiAgICAgICAgICAgICAgICBuZXh0RmlsbFN0eWxlID0gX3RoaXMuX2NvbG9ycy5hbnNpW2JnXS5jc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldkZpbGxTdHlsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0WCA9IHg7XG4gICAgICAgICAgICAgICAgc3RhcnRZID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5ICE9PSBzdGFydFkpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gcHJldkZpbGxTdHlsZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5maWxsQ2VsbHMoc3RhcnRYLCBzdGFydFksIGNvbHMgLSBzdGFydFgsIDEpO1xuICAgICAgICAgICAgICAgIHN0YXJ0WCA9IHg7XG4gICAgICAgICAgICAgICAgc3RhcnRZID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByZXZGaWxsU3R5bGUgIT09IG5leHRGaWxsU3R5bGUpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gcHJldkZpbGxTdHlsZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5maWxsQ2VsbHMoc3RhcnRYLCBzdGFydFksIHggLSBzdGFydFgsIDEpO1xuICAgICAgICAgICAgICAgIHN0YXJ0WCA9IHg7XG4gICAgICAgICAgICAgICAgc3RhcnRZID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZGaWxsU3R5bGUgPSBuZXh0RmlsbFN0eWxlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByZXZGaWxsU3R5bGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBwcmV2RmlsbFN0eWxlO1xuICAgICAgICAgICAgdGhpcy5maWxsQ2VsbHMoc3RhcnRYLCBzdGFydFksIGNvbHMgLSBzdGFydFgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcbiAgICBUZXh0UmVuZGVyTGF5ZXIucHJvdG90eXBlLl9kcmF3Rm9yZWdyb3VuZCA9IGZ1bmN0aW9uICh0ZXJtaW5hbCwgZmlyc3RSb3csIGxhc3RSb3cpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fZm9yRWFjaENlbGwodGVybWluYWwsIGZpcnN0Um93LCBsYXN0Um93LCB0aGlzLl9jaGFyYWN0ZXJKb2luZXJSZWdpc3RyeSwgZnVuY3Rpb24gKGNvZGUsIGNoYXJzLCB3aWR0aCwgeCwgeSwgZmcsIGJnLCBmbGFncykge1xuICAgICAgICAgICAgaWYgKGZsYWdzICYgMTYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmxhZ3MgJiAyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2N0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGZnID09PSBUeXBlc18xLklOVkVSVEVEX0RFRkFVTFRfQ09MT1IpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2N0eC5maWxsU3R5bGUgPSBfdGhpcy5fY29sb3JzLmJhY2tncm91bmQuY3NzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmZyA8IDI1Nikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY3R4LmZpbGxTdHlsZSA9IF90aGlzLl9jb2xvcnMuYW5zaVtmZ10uY3NzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2N0eC5maWxsU3R5bGUgPSBfdGhpcy5fY29sb3JzLmZvcmVncm91bmQuY3NzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5maWxsQm90dG9tTGluZUF0Q2VsbHMoeCwgeSwgd2lkdGgpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9jdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuZHJhd0NoYXJzKHRlcm1pbmFsLCBjaGFycywgY29kZSwgd2lkdGgsIHgsIHksIGZnLCBiZywgISEoZmxhZ3MgJiAxKSwgISEoZmxhZ3MgJiAzMiksICEhKGZsYWdzICYgNjQpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUZXh0UmVuZGVyTGF5ZXIucHJvdG90eXBlLm9uR3JpZENoYW5nZWQgPSBmdW5jdGlvbiAodGVybWluYWwsIGZpcnN0Um93LCBsYXN0Um93KSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5jYWNoZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY2hhckF0bGFzKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFyQXRsYXMuYmVnaW5GcmFtZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJDZWxscygwLCBmaXJzdFJvdywgdGVybWluYWwuY29scywgbGFzdFJvdyAtIGZpcnN0Um93ICsgMSk7XG4gICAgICAgIHRoaXMuX2RyYXdCYWNrZ3JvdW5kKHRlcm1pbmFsLCBmaXJzdFJvdywgbGFzdFJvdyk7XG4gICAgICAgIHRoaXMuX2RyYXdGb3JlZ3JvdW5kKHRlcm1pbmFsLCBmaXJzdFJvdywgbGFzdFJvdyk7XG4gICAgfTtcbiAgICBUZXh0UmVuZGVyTGF5ZXIucHJvdG90eXBlLm9uT3B0aW9uc0NoYW5nZWQgPSBmdW5jdGlvbiAodGVybWluYWwpIHtcbiAgICAgICAgdGhpcy5zZXRUcmFuc3BhcmVuY3kodGVybWluYWwsIHRlcm1pbmFsLm9wdGlvbnMuYWxsb3dUcmFuc3BhcmVuY3kpO1xuICAgIH07XG4gICAgVGV4dFJlbmRlckxheWVyLnByb3RvdHlwZS5faXNPdmVybGFwcGluZyA9IGZ1bmN0aW9uIChjaGFyRGF0YSkge1xuICAgICAgICBpZiAoY2hhckRhdGFbQnVmZmVyXzEuQ0hBUl9EQVRBX1dJRFRIX0lOREVYXSAhPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2RlID0gY2hhckRhdGFbQnVmZmVyXzEuQ0hBUl9EQVRBX0NPREVfSU5ERVhdO1xuICAgICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFyID0gY2hhckRhdGFbQnVmZmVyXzEuQ0hBUl9EQVRBX0NIQVJfSU5ERVhdO1xuICAgICAgICBpZiAodGhpcy5fY2hhcmFjdGVyT3ZlcmxhcENhY2hlLmhhc093blByb3BlcnR5KGNoYXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hhcmFjdGVyT3ZlcmxhcENhY2hlW2NoYXJdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N0eC5zYXZlKCk7XG4gICAgICAgIHRoaXMuX2N0eC5mb250ID0gdGhpcy5fY2hhcmFjdGVyRm9udDtcbiAgICAgICAgdmFyIG92ZXJsYXBzID0gTWF0aC5mbG9vcih0aGlzLl9jdHgubWVhc3VyZVRleHQoY2hhcikud2lkdGgpID4gdGhpcy5fY2hhcmFjdGVyV2lkdGg7XG4gICAgICAgIHRoaXMuX2N0eC5yZXN0b3JlKCk7XG4gICAgICAgIHRoaXMuX2NoYXJhY3Rlck92ZXJsYXBDYWNoZVtjaGFyXSA9IG92ZXJsYXBzO1xuICAgICAgICByZXR1cm4gb3ZlcmxhcHM7XG4gICAgfTtcbiAgICByZXR1cm4gVGV4dFJlbmRlckxheWVyO1xufShCYXNlUmVuZGVyTGF5ZXJfMS5CYXNlUmVuZGVyTGF5ZXIpKTtcbmV4cG9ydHMuVGV4dFJlbmRlckxheWVyID0gVGV4dFJlbmRlckxheWVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dFJlbmRlckxheWVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEJhc2VDaGFyQXRsYXMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJhc2VDaGFyQXRsYXMoKSB7XG4gICAgICAgIHRoaXMuX2RpZFdhcm1VcCA9IGZhbHNlO1xuICAgIH1cbiAgICBCYXNlQ2hhckF0bGFzLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIEJhc2VDaGFyQXRsYXMucHJvdG90eXBlLndhcm1VcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kaWRXYXJtVXApIHtcbiAgICAgICAgICAgIHRoaXMuX2RvV2FybVVwKCk7XG4gICAgICAgICAgICB0aGlzLl9kaWRXYXJtVXAgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCYXNlQ2hhckF0bGFzLnByb3RvdHlwZS5fZG9XYXJtVXAgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgQmFzZUNoYXJBdGxhcy5wcm90b3R5cGUuYmVnaW5GcmFtZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICByZXR1cm4gQmFzZUNoYXJBdGxhcztcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBCYXNlQ2hhckF0bGFzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZUNoYXJBdGxhcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBDaGFyQXRsYXNVdGlsc18xID0gcmVxdWlyZShcIi4vQ2hhckF0bGFzVXRpbHNcIik7XG52YXIgRHluYW1pY0NoYXJBdGxhc18xID0gcmVxdWlyZShcIi4vRHluYW1pY0NoYXJBdGxhc1wiKTtcbnZhciBOb25lQ2hhckF0bGFzXzEgPSByZXF1aXJlKFwiLi9Ob25lQ2hhckF0bGFzXCIpO1xudmFyIFN0YXRpY0NoYXJBdGxhc18xID0gcmVxdWlyZShcIi4vU3RhdGljQ2hhckF0bGFzXCIpO1xudmFyIGNoYXJBdGxhc0ltcGxlbWVudGF0aW9ucyA9IHtcbiAgICAnbm9uZSc6IE5vbmVDaGFyQXRsYXNfMS5kZWZhdWx0LFxuICAgICdzdGF0aWMnOiBTdGF0aWNDaGFyQXRsYXNfMS5kZWZhdWx0LFxuICAgICdkeW5hbWljJzogRHluYW1pY0NoYXJBdGxhc18xLmRlZmF1bHRcbn07XG52YXIgY2hhckF0bGFzQ2FjaGUgPSBbXTtcbmZ1bmN0aW9uIGFjcXVpcmVDaGFyQXRsYXModGVybWluYWwsIGNvbG9ycywgc2NhbGVkQ2hhcldpZHRoLCBzY2FsZWRDaGFySGVpZ2h0KSB7XG4gICAgdmFyIG5ld0NvbmZpZyA9IENoYXJBdGxhc1V0aWxzXzEuZ2VuZXJhdGVDb25maWcoc2NhbGVkQ2hhcldpZHRoLCBzY2FsZWRDaGFySGVpZ2h0LCB0ZXJtaW5hbCwgY29sb3JzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJBdGxhc0NhY2hlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGNoYXJBdGxhc0NhY2hlW2ldO1xuICAgICAgICB2YXIgb3duZWRCeUluZGV4ID0gZW50cnkub3duZWRCeS5pbmRleE9mKHRlcm1pbmFsKTtcbiAgICAgICAgaWYgKG93bmVkQnlJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICBpZiAoQ2hhckF0bGFzVXRpbHNfMS5jb25maWdFcXVhbHMoZW50cnkuY29uZmlnLCBuZXdDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5LmF0bGFzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudHJ5Lm93bmVkQnkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgY2hhckF0bGFzQ2FjaGUuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZW50cnkub3duZWRCeS5zcGxpY2Uob3duZWRCeUluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhckF0bGFzQ2FjaGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gY2hhckF0bGFzQ2FjaGVbaV07XG4gICAgICAgIGlmIChDaGFyQXRsYXNVdGlsc18xLmNvbmZpZ0VxdWFscyhlbnRyeS5jb25maWcsIG5ld0NvbmZpZykpIHtcbiAgICAgICAgICAgIGVudHJ5Lm93bmVkQnkucHVzaCh0ZXJtaW5hbCk7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkuYXRsYXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIG5ld0VudHJ5ID0ge1xuICAgICAgICBhdGxhczogbmV3IGNoYXJBdGxhc0ltcGxlbWVudGF0aW9uc1t0ZXJtaW5hbC5vcHRpb25zLmV4cGVyaW1lbnRhbENoYXJBdGxhc10oZG9jdW1lbnQsIG5ld0NvbmZpZyksXG4gICAgICAgIGNvbmZpZzogbmV3Q29uZmlnLFxuICAgICAgICBvd25lZEJ5OiBbdGVybWluYWxdXG4gICAgfTtcbiAgICBjaGFyQXRsYXNDYWNoZS5wdXNoKG5ld0VudHJ5KTtcbiAgICByZXR1cm4gbmV3RW50cnkuYXRsYXM7XG59XG5leHBvcnRzLmFjcXVpcmVDaGFyQXRsYXMgPSBhY3F1aXJlQ2hhckF0bGFzO1xuZnVuY3Rpb24gcmVtb3ZlVGVybWluYWxGcm9tQ2FjaGUodGVybWluYWwpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJBdGxhc0NhY2hlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGNoYXJBdGxhc0NhY2hlW2ldLm93bmVkQnkuaW5kZXhPZih0ZXJtaW5hbCk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChjaGFyQXRsYXNDYWNoZVtpXS5vd25lZEJ5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGNoYXJBdGxhc0NhY2hlLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoYXJBdGxhc0NhY2hlW2ldLm93bmVkQnkuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5yZW1vdmVUZXJtaW5hbEZyb21DYWNoZSA9IHJlbW92ZVRlcm1pbmFsRnJvbUNhY2hlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2hhckF0bGFzQ2FjaGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBnZW5lcmF0ZUNvbmZpZyhzY2FsZWRDaGFyV2lkdGgsIHNjYWxlZENoYXJIZWlnaHQsIHRlcm1pbmFsLCBjb2xvcnMpIHtcbiAgICB2YXIgY2xvbmVkQ29sb3JzID0ge1xuICAgICAgICBmb3JlZ3JvdW5kOiBjb2xvcnMuZm9yZWdyb3VuZCxcbiAgICAgICAgYmFja2dyb3VuZDogY29sb3JzLmJhY2tncm91bmQsXG4gICAgICAgIGN1cnNvcjogbnVsbCxcbiAgICAgICAgY3Vyc29yQWNjZW50OiBudWxsLFxuICAgICAgICBzZWxlY3Rpb246IG51bGwsXG4gICAgICAgIGFuc2k6IGNvbG9ycy5hbnNpLnNsaWNlKDAsIDE2KVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdGVybWluYWwub3B0aW9ucy5leHBlcmltZW50YWxDaGFyQXRsYXMsXG4gICAgICAgIGRldmljZVBpeGVsUmF0aW86IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLFxuICAgICAgICBzY2FsZWRDaGFyV2lkdGg6IHNjYWxlZENoYXJXaWR0aCxcbiAgICAgICAgc2NhbGVkQ2hhckhlaWdodDogc2NhbGVkQ2hhckhlaWdodCxcbiAgICAgICAgZm9udEZhbWlseTogdGVybWluYWwub3B0aW9ucy5mb250RmFtaWx5LFxuICAgICAgICBmb250U2l6ZTogdGVybWluYWwub3B0aW9ucy5mb250U2l6ZSxcbiAgICAgICAgZm9udFdlaWdodDogdGVybWluYWwub3B0aW9ucy5mb250V2VpZ2h0LFxuICAgICAgICBmb250V2VpZ2h0Qm9sZDogdGVybWluYWwub3B0aW9ucy5mb250V2VpZ2h0Qm9sZCxcbiAgICAgICAgYWxsb3dUcmFuc3BhcmVuY3k6IHRlcm1pbmFsLm9wdGlvbnMuYWxsb3dUcmFuc3BhcmVuY3ksXG4gICAgICAgIGNvbG9yczogY2xvbmVkQ29sb3JzXG4gICAgfTtcbn1cbmV4cG9ydHMuZ2VuZXJhdGVDb25maWcgPSBnZW5lcmF0ZUNvbmZpZztcbmZ1bmN0aW9uIGNvbmZpZ0VxdWFscyhhLCBiKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmNvbG9ycy5hbnNpLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhLmNvbG9ycy5hbnNpW2ldLnJnYmEgIT09IGIuY29sb3JzLmFuc2lbaV0ucmdiYSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhLnR5cGUgPT09IGIudHlwZSAmJlxuICAgICAgICBhLmRldmljZVBpeGVsUmF0aW8gPT09IGIuZGV2aWNlUGl4ZWxSYXRpbyAmJlxuICAgICAgICBhLmZvbnRGYW1pbHkgPT09IGIuZm9udEZhbWlseSAmJlxuICAgICAgICBhLmZvbnRTaXplID09PSBiLmZvbnRTaXplICYmXG4gICAgICAgIGEuZm9udFdlaWdodCA9PT0gYi5mb250V2VpZ2h0ICYmXG4gICAgICAgIGEuZm9udFdlaWdodEJvbGQgPT09IGIuZm9udFdlaWdodEJvbGQgJiZcbiAgICAgICAgYS5hbGxvd1RyYW5zcGFyZW5jeSA9PT0gYi5hbGxvd1RyYW5zcGFyZW5jeSAmJlxuICAgICAgICBhLnNjYWxlZENoYXJXaWR0aCA9PT0gYi5zY2FsZWRDaGFyV2lkdGggJiZcbiAgICAgICAgYS5zY2FsZWRDaGFySGVpZ2h0ID09PSBiLnNjYWxlZENoYXJIZWlnaHQgJiZcbiAgICAgICAgYS5jb2xvcnMuZm9yZWdyb3VuZCA9PT0gYi5jb2xvcnMuZm9yZWdyb3VuZCAmJlxuICAgICAgICBhLmNvbG9ycy5iYWNrZ3JvdW5kID09PSBiLmNvbG9ycy5iYWNrZ3JvdW5kO1xufVxuZXhwb3J0cy5jb25maWdFcXVhbHMgPSBjb25maWdFcXVhbHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DaGFyQXRsYXNVdGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgVHlwZXNfMSA9IHJlcXVpcmUoXCIuL1R5cGVzXCIpO1xudmFyIEJhc2VDaGFyQXRsYXNfMSA9IHJlcXVpcmUoXCIuL0Jhc2VDaGFyQXRsYXNcIik7XG52YXIgQ29sb3JNYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi4vQ29sb3JNYW5hZ2VyXCIpO1xudmFyIENoYXJBdGxhc0dlbmVyYXRvcl8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9hdGxhcy9DaGFyQXRsYXNHZW5lcmF0b3JcIik7XG52YXIgTFJVTWFwXzEgPSByZXF1aXJlKFwiLi9MUlVNYXBcIik7XG52YXIgQnJvd3Nlcl8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC91dGlscy9Ccm93c2VyXCIpO1xudmFyIFRFWFRVUkVfV0lEVEggPSAxMDI0O1xudmFyIFRFWFRVUkVfSEVJR0hUID0gMTAyNDtcbnZhciBUUkFOU1BBUkVOVF9DT0xPUiA9IHtcbiAgICBjc3M6ICdyZ2JhKDAsIDAsIDAsIDApJyxcbiAgICByZ2JhOiAwXG59O1xudmFyIEZSQU1FX0NBQ0hFX0RSQVdfTElNSVQgPSAxMDA7XG52YXIgR0xZUEhfQklUTUFQX0NPTU1JVF9ERUxBWSA9IDEwMDtcbmZ1bmN0aW9uIGdldEdseXBoQ2FjaGVLZXkoZ2x5cGgpIHtcbiAgICByZXR1cm4gZ2x5cGguY29kZSA8PCAyMSB8IGdseXBoLmJnIDw8IDEyIHwgZ2x5cGguZmcgPDwgMyB8IChnbHlwaC5ib2xkID8gMCA6IDQpICsgKGdseXBoLmRpbSA/IDAgOiAyKSArIChnbHlwaC5pdGFsaWMgPyAwIDogMSk7XG59XG52YXIgRHluYW1pY0NoYXJBdGxhcyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKER5bmFtaWNDaGFyQXRsYXMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRHluYW1pY0NoYXJBdGxhcyhkb2N1bWVudCwgX2NvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fY29uZmlnID0gX2NvbmZpZztcbiAgICAgICAgX3RoaXMuX2RyYXdUb0NhY2hlQ291bnQgPSAwO1xuICAgICAgICBfdGhpcy5fZ2x5cGhzV2FpdGluZ09uQml0bWFwID0gW107XG4gICAgICAgIF90aGlzLl9iaXRtYXBDb21taXRUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX2JpdG1hcCA9IG51bGw7XG4gICAgICAgIF90aGlzLl9jYWNoZUNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBfdGhpcy5fY2FjaGVDYW52YXMud2lkdGggPSBURVhUVVJFX1dJRFRIO1xuICAgICAgICBfdGhpcy5fY2FjaGVDYW52YXMuaGVpZ2h0ID0gVEVYVFVSRV9IRUlHSFQ7XG4gICAgICAgIF90aGlzLl9jYWNoZUN0eCA9IF90aGlzLl9jYWNoZUNhbnZhcy5nZXRDb250ZXh0KCcyZCcsIHsgYWxwaGE6IHRydWUgfSk7XG4gICAgICAgIHZhciB0bXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdG1wQ2FudmFzLndpZHRoID0gX3RoaXMuX2NvbmZpZy5zY2FsZWRDaGFyV2lkdGg7XG4gICAgICAgIHRtcENhbnZhcy5oZWlnaHQgPSBfdGhpcy5fY29uZmlnLnNjYWxlZENoYXJIZWlnaHQ7XG4gICAgICAgIF90aGlzLl90bXBDdHggPSB0bXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnLCB7IGFscGhhOiBfdGhpcy5fY29uZmlnLmFsbG93VHJhbnNwYXJlbmN5IH0pO1xuICAgICAgICBfdGhpcy5fd2lkdGggPSBNYXRoLmZsb29yKFRFWFRVUkVfV0lEVEggLyBfdGhpcy5fY29uZmlnLnNjYWxlZENoYXJXaWR0aCk7XG4gICAgICAgIF90aGlzLl9oZWlnaHQgPSBNYXRoLmZsb29yKFRFWFRVUkVfSEVJR0hUIC8gX3RoaXMuX2NvbmZpZy5zY2FsZWRDaGFySGVpZ2h0KTtcbiAgICAgICAgdmFyIGNhcGFjaXR5ID0gX3RoaXMuX3dpZHRoICogX3RoaXMuX2hlaWdodDtcbiAgICAgICAgX3RoaXMuX2NhY2hlTWFwID0gbmV3IExSVU1hcF8xLmRlZmF1bHQoY2FwYWNpdHkpO1xuICAgICAgICBfdGhpcy5fY2FjaGVNYXAucHJlYWxsb2MoY2FwYWNpdHkpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIER5bmFtaWNDaGFyQXRsYXMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9iaXRtYXBDb21taXRUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX2JpdG1hcENvbW1pdFRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5fYml0bWFwQ29tbWl0VGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIER5bmFtaWNDaGFyQXRsYXMucHJvdG90eXBlLmJlZ2luRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2RyYXdUb0NhY2hlQ291bnQgPSAwO1xuICAgIH07XG4gICAgRHluYW1pY0NoYXJBdGxhcy5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgsIGdseXBoLCB4LCB5KSB7XG4gICAgICAgIGlmIChnbHlwaC5jb2RlID09PSAzMikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdseXBoS2V5ID0gZ2V0R2x5cGhDYWNoZUtleShnbHlwaCk7XG4gICAgICAgIHZhciBjYWNoZVZhbHVlID0gdGhpcy5fY2FjaGVNYXAuZ2V0KGdseXBoS2V5KTtcbiAgICAgICAgaWYgKGNhY2hlVmFsdWUgIT09IG51bGwgJiYgY2FjaGVWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9kcmF3RnJvbUNhY2hlKGN0eCwgY2FjaGVWYWx1ZSwgeCwgeSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9jYW5DYWNoZShnbHlwaCkgJiYgdGhpcy5fZHJhd1RvQ2FjaGVDb3VudCA8IEZSQU1FX0NBQ0hFX0RSQVdfTElNSVQpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYWNoZU1hcC5zaXplIDwgdGhpcy5fY2FjaGVNYXAuY2FwYWNpdHkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuX2NhY2hlTWFwLnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuX2NhY2hlTWFwLnBlZWsoKS5pbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjYWNoZVZhbHVlXzEgPSB0aGlzLl9kcmF3VG9DYWNoZShnbHlwaCwgaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVNYXAuc2V0KGdseXBoS2V5LCBjYWNoZVZhbHVlXzEpO1xuICAgICAgICAgICAgdGhpcy5fZHJhd0Zyb21DYWNoZShjdHgsIGNhY2hlVmFsdWVfMSwgeCwgeSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBEeW5hbWljQ2hhckF0bGFzLnByb3RvdHlwZS5fY2FuQ2FjaGUgPSBmdW5jdGlvbiAoZ2x5cGgpIHtcbiAgICAgICAgcmV0dXJuIGdseXBoLmNvZGUgPCAyNTY7XG4gICAgfTtcbiAgICBEeW5hbWljQ2hhckF0bGFzLnByb3RvdHlwZS5fdG9Db29yZGluYXRlWCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gKGluZGV4ICUgdGhpcy5fd2lkdGgpICogdGhpcy5fY29uZmlnLnNjYWxlZENoYXJXaWR0aDtcbiAgICB9O1xuICAgIER5bmFtaWNDaGFyQXRsYXMucHJvdG90eXBlLl90b0Nvb3JkaW5hdGVZID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5fd2lkdGgpICogdGhpcy5fY29uZmlnLnNjYWxlZENoYXJIZWlnaHQ7XG4gICAgfTtcbiAgICBEeW5hbWljQ2hhckF0bGFzLnByb3RvdHlwZS5fZHJhd0Zyb21DYWNoZSA9IGZ1bmN0aW9uIChjdHgsIGNhY2hlVmFsdWUsIHgsIHkpIHtcbiAgICAgICAgaWYgKGNhY2hlVmFsdWUuaXNFbXB0eSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYWNoZVggPSB0aGlzLl90b0Nvb3JkaW5hdGVYKGNhY2hlVmFsdWUuaW5kZXgpO1xuICAgICAgICB2YXIgY2FjaGVZID0gdGhpcy5fdG9Db29yZGluYXRlWShjYWNoZVZhbHVlLmluZGV4KTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZShjYWNoZVZhbHVlLmluQml0bWFwID8gdGhpcy5fYml0bWFwIDogdGhpcy5fY2FjaGVDYW52YXMsIGNhY2hlWCwgY2FjaGVZLCB0aGlzLl9jb25maWcuc2NhbGVkQ2hhcldpZHRoLCB0aGlzLl9jb25maWcuc2NhbGVkQ2hhckhlaWdodCwgeCwgeSwgdGhpcy5fY29uZmlnLnNjYWxlZENoYXJXaWR0aCwgdGhpcy5fY29uZmlnLnNjYWxlZENoYXJIZWlnaHQpO1xuICAgIH07XG4gICAgRHluYW1pY0NoYXJBdGxhcy5wcm90b3R5cGUuX2dldENvbG9yRnJvbUFuc2lJbmRleCA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgaWYgKGlkeCA8IHRoaXMuX2NvbmZpZy5jb2xvcnMuYW5zaS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb25maWcuY29sb3JzLmFuc2lbaWR4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ29sb3JNYW5hZ2VyXzEuREVGQVVMVF9BTlNJX0NPTE9SU1tpZHhdO1xuICAgIH07XG4gICAgRHluYW1pY0NoYXJBdGxhcy5wcm90b3R5cGUuX2dldEJhY2tncm91bmRDb2xvciA9IGZ1bmN0aW9uIChnbHlwaCkge1xuICAgICAgICBpZiAodGhpcy5fY29uZmlnLmFsbG93VHJhbnNwYXJlbmN5KSB7XG4gICAgICAgICAgICByZXR1cm4gVFJBTlNQQVJFTlRfQ09MT1I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ2x5cGguYmcgPT09IFR5cGVzXzEuSU5WRVJURURfREVGQVVMVF9DT0xPUikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5jb2xvcnMuZm9yZWdyb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChnbHlwaC5iZyA8IDI1Nikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldENvbG9yRnJvbUFuc2lJbmRleChnbHlwaC5iZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5jb2xvcnMuYmFja2dyb3VuZDtcbiAgICB9O1xuICAgIER5bmFtaWNDaGFyQXRsYXMucHJvdG90eXBlLl9nZXRGb3JlZ3JvdW5kQ29sb3IgPSBmdW5jdGlvbiAoZ2x5cGgpIHtcbiAgICAgICAgaWYgKGdseXBoLmZnID09PSBUeXBlc18xLklOVkVSVEVEX0RFRkFVTFRfQ09MT1IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb25maWcuY29sb3JzLmJhY2tncm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ2x5cGguZmcgPCAyNTYpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRDb2xvckZyb21BbnNpSW5kZXgoZ2x5cGguZmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25maWcuY29sb3JzLmZvcmVncm91bmQ7XG4gICAgfTtcbiAgICBEeW5hbWljQ2hhckF0bGFzLnByb3RvdHlwZS5fZHJhd1RvQ2FjaGUgPSBmdW5jdGlvbiAoZ2x5cGgsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuX2RyYXdUb0NhY2hlQ291bnQrKztcbiAgICAgICAgdGhpcy5fdG1wQ3R4LnNhdmUoKTtcbiAgICAgICAgdmFyIGJhY2tncm91bmRDb2xvciA9IHRoaXMuX2dldEJhY2tncm91bmRDb2xvcihnbHlwaCk7XG4gICAgICAgIHRoaXMuX3RtcEN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnY29weSc7XG4gICAgICAgIHRoaXMuX3RtcEN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3IuY3NzO1xuICAgICAgICB0aGlzLl90bXBDdHguZmlsbFJlY3QoMCwgMCwgdGhpcy5fY29uZmlnLnNjYWxlZENoYXJXaWR0aCwgdGhpcy5fY29uZmlnLnNjYWxlZENoYXJIZWlnaHQpO1xuICAgICAgICB0aGlzLl90bXBDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgdmFyIGZvbnRXZWlnaHQgPSBnbHlwaC5ib2xkID8gdGhpcy5fY29uZmlnLmZvbnRXZWlnaHRCb2xkIDogdGhpcy5fY29uZmlnLmZvbnRXZWlnaHQ7XG4gICAgICAgIHZhciBmb250U3R5bGUgPSBnbHlwaC5pdGFsaWMgPyAnaXRhbGljJyA6ICcnO1xuICAgICAgICB0aGlzLl90bXBDdHguZm9udCA9XG4gICAgICAgICAgICBmb250U3R5bGUgKyBcIiBcIiArIGZvbnRXZWlnaHQgKyBcIiBcIiArIHRoaXMuX2NvbmZpZy5mb250U2l6ZSAqIHRoaXMuX2NvbmZpZy5kZXZpY2VQaXhlbFJhdGlvICsgXCJweCBcIiArIHRoaXMuX2NvbmZpZy5mb250RmFtaWx5O1xuICAgICAgICB0aGlzLl90bXBDdHgudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG4gICAgICAgIHRoaXMuX3RtcEN0eC5maWxsU3R5bGUgPSB0aGlzLl9nZXRGb3JlZ3JvdW5kQ29sb3IoZ2x5cGgpLmNzcztcbiAgICAgICAgaWYgKGdseXBoLmRpbSkge1xuICAgICAgICAgICAgdGhpcy5fdG1wQ3R4Lmdsb2JhbEFscGhhID0gVHlwZXNfMS5ESU1fT1BBQ0lUWTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90bXBDdHguZmlsbFRleHQoZ2x5cGguY2hhcnMsIDAsIDApO1xuICAgICAgICB0aGlzLl90bXBDdHgucmVzdG9yZSgpO1xuICAgICAgICB2YXIgaW1hZ2VEYXRhID0gdGhpcy5fdG1wQ3R4LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLl9jb25maWcuc2NhbGVkQ2hhcldpZHRoLCB0aGlzLl9jb25maWcuc2NhbGVkQ2hhckhlaWdodCk7XG4gICAgICAgIHZhciBpc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5fY29uZmlnLmFsbG93VHJhbnNwYXJlbmN5KSB7XG4gICAgICAgICAgICBpc0VtcHR5ID0gQ2hhckF0bGFzR2VuZXJhdG9yXzEuY2xlYXJDb2xvcihpbWFnZURhdGEsIGJhY2tncm91bmRDb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHggPSB0aGlzLl90b0Nvb3JkaW5hdGVYKGluZGV4KTtcbiAgICAgICAgdmFyIHkgPSB0aGlzLl90b0Nvb3JkaW5hdGVZKGluZGV4KTtcbiAgICAgICAgdGhpcy5fY2FjaGVDdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgeCwgeSk7XG4gICAgICAgIHZhciBjYWNoZVZhbHVlID0ge1xuICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgaXNFbXB0eTogaXNFbXB0eSxcbiAgICAgICAgICAgIGluQml0bWFwOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9hZGRHbHlwaFRvQml0bWFwKGNhY2hlVmFsdWUpO1xuICAgICAgICByZXR1cm4gY2FjaGVWYWx1ZTtcbiAgICB9O1xuICAgIER5bmFtaWNDaGFyQXRsYXMucHJvdG90eXBlLl9hZGRHbHlwaFRvQml0bWFwID0gZnVuY3Rpb24gKGNhY2hlVmFsdWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCEoJ2NyZWF0ZUltYWdlQml0bWFwJyBpbiB3aW5kb3cpIHx8IEJyb3dzZXJfMS5pc0ZpcmVmb3ggfHwgQnJvd3Nlcl8xLmlzU2FmYXJpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ2x5cGhzV2FpdGluZ09uQml0bWFwLnB1c2goY2FjaGVWYWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLl9iaXRtYXBDb21taXRUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYml0bWFwQ29tbWl0VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9nZW5lcmF0ZUJpdG1hcCgpOyB9LCBHTFlQSF9CSVRNQVBfQ09NTUlUX0RFTEFZKTtcbiAgICB9O1xuICAgIER5bmFtaWNDaGFyQXRsYXMucHJvdG90eXBlLl9nZW5lcmF0ZUJpdG1hcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGdseXBoc01vdmluZ1RvQml0bWFwID0gdGhpcy5fZ2x5cGhzV2FpdGluZ09uQml0bWFwO1xuICAgICAgICB0aGlzLl9nbHlwaHNXYWl0aW5nT25CaXRtYXAgPSBbXTtcbiAgICAgICAgd2luZG93LmNyZWF0ZUltYWdlQml0bWFwKHRoaXMuX2NhY2hlQ2FudmFzKS50aGVuKGZ1bmN0aW9uIChiaXRtYXApIHtcbiAgICAgICAgICAgIF90aGlzLl9iaXRtYXAgPSBiaXRtYXA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBoc01vdmluZ1RvQml0bWFwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2x5cGhzTW92aW5nVG9CaXRtYXBbaV07XG4gICAgICAgICAgICAgICAgdmFsdWUuaW5CaXRtYXAgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fYml0bWFwQ29tbWl0VGltZW91dCA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gRHluYW1pY0NoYXJBdGxhcztcbn0oQmFzZUNoYXJBdGxhc18xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IER5bmFtaWNDaGFyQXRsYXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EeW5hbWljQ2hhckF0bGFzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIExSVU1hcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTFJVTWFwKGNhcGFjaXR5KSB7XG4gICAgICAgIHRoaXMuY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICAgICAgdGhpcy5fbWFwID0ge307XG4gICAgICAgIHRoaXMuX2hlYWQgPSBudWxsO1xuICAgICAgICB0aGlzLl90YWlsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbm9kZVBvb2wgPSBbXTtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG4gICAgTFJVTWFwLnByb3RvdHlwZS5fdW5saW5rTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBwcmV2ID0gbm9kZS5wcmV2O1xuICAgICAgICB2YXIgbmV4dCA9IG5vZGUubmV4dDtcbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMuX2hlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlID09PSB0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gcHJldjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJldi5uZXh0ID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbmV4dC5wcmV2ID0gcHJldjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTFJVTWFwLnByb3RvdHlwZS5fYXBwZW5kTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciB0YWlsID0gdGhpcy5fdGFpbDtcbiAgICAgICAgaWYgKHRhaWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRhaWwubmV4dCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5wcmV2ID0gdGFpbDtcbiAgICAgICAgbm9kZS5uZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdGFpbCA9IG5vZGU7XG4gICAgICAgIGlmICh0aGlzLl9oZWFkID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gbm9kZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTFJVTWFwLnByb3RvdHlwZS5wcmVhbGxvYyA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgICAgICB2YXIgbm9kZVBvb2wgPSB0aGlzLl9ub2RlUG9vbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBub2RlUG9vbC5wdXNoKHtcbiAgICAgICAgICAgICAgICBwcmV2OiBudWxsLFxuICAgICAgICAgICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgICAgICAgICAga2V5OiBudWxsLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTFJVTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5fbWFwW2tleV07XG4gICAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3VubGlua05vZGUobm9kZSk7XG4gICAgICAgICAgICB0aGlzLl9hcHBlbmROb2RlKG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBMUlVNYXAucHJvdG90eXBlLnBlZWtWYWx1ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9tYXBba2V5XTtcbiAgICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBMUlVNYXAucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoZWFkID0gdGhpcy5faGVhZDtcbiAgICAgICAgcmV0dXJuIGhlYWQgPT09IG51bGwgPyBudWxsIDogaGVhZC52YWx1ZTtcbiAgICB9O1xuICAgIExSVU1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9tYXBba2V5XTtcbiAgICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMuX21hcFtrZXldO1xuICAgICAgICAgICAgdGhpcy5fdW5saW5rTm9kZShub2RlKTtcbiAgICAgICAgICAgIG5vZGUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNpemUgPj0gdGhpcy5jYXBhY2l0eSkge1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMuX2hlYWQ7XG4gICAgICAgICAgICB0aGlzLl91bmxpbmtOb2RlKG5vZGUpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX21hcFtub2RlLmtleV07XG4gICAgICAgICAgICBub2RlLmtleSA9IGtleTtcbiAgICAgICAgICAgIG5vZGUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX21hcFtrZXldID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBub2RlUG9vbCA9IHRoaXMuX25vZGVQb29sO1xuICAgICAgICAgICAgaWYgKG5vZGVQb29sLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZVBvb2wucG9wKCk7XG4gICAgICAgICAgICAgICAgbm9kZS5rZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcHJldjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tYXBba2V5XSA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLnNpemUrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hcHBlbmROb2RlKG5vZGUpO1xuICAgIH07XG4gICAgcmV0dXJuIExSVU1hcDtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBMUlVNYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MUlVNYXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEJhc2VDaGFyQXRsYXNfMSA9IHJlcXVpcmUoXCIuL0Jhc2VDaGFyQXRsYXNcIik7XG52YXIgTm9uZUNoYXJBdGxhcyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5vbmVDaGFyQXRsYXMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTm9uZUNoYXJBdGxhcyhkb2N1bWVudCwgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBOb25lQ2hhckF0bGFzLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCwgZ2x5cGgsIHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgcmV0dXJuIE5vbmVDaGFyQXRsYXM7XG59KEJhc2VDaGFyQXRsYXNfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBOb25lQ2hhckF0bGFzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Tm9uZUNoYXJBdGxhcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgVHlwZXNfMSA9IHJlcXVpcmUoXCIuL1R5cGVzXCIpO1xudmFyIFR5cGVzXzIgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2F0bGFzL1R5cGVzXCIpO1xudmFyIENoYXJBdGxhc0dlbmVyYXRvcl8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9hdGxhcy9DaGFyQXRsYXNHZW5lcmF0b3JcIik7XG52YXIgQmFzZUNoYXJBdGxhc18xID0gcmVxdWlyZShcIi4vQmFzZUNoYXJBdGxhc1wiKTtcbnZhciBTdGF0aWNDaGFyQXRsYXMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdGF0aWNDaGFyQXRsYXMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3RhdGljQ2hhckF0bGFzKF9kb2N1bWVudCwgX2NvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fZG9jdW1lbnQgPSBfZG9jdW1lbnQ7XG4gICAgICAgIF90aGlzLl9jb25maWcgPSBfY29uZmlnO1xuICAgICAgICBfdGhpcy5fY2FudmFzRmFjdG9yeSA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgY2FudmFzID0gX3RoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTdGF0aWNDaGFyQXRsYXMucHJvdG90eXBlLl9kb1dhcm1VcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlc3VsdCA9IENoYXJBdGxhc0dlbmVyYXRvcl8xLmdlbmVyYXRlU3RhdGljQ2hhckF0bGFzVGV4dHVyZSh3aW5kb3csIHRoaXMuX2NhbnZhc0ZhY3RvcnksIHRoaXMuX2NvbmZpZyk7XG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC50aGVuKGZ1bmN0aW9uICh0ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RleHR1cmUgPSB0ZXh0dXJlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0YXRpY0NoYXJBdGxhcy5wcm90b3R5cGUuX2lzQ2FjaGVkID0gZnVuY3Rpb24gKGdseXBoLCBjb2xvckluZGV4KSB7XG4gICAgICAgIHZhciBpc0FzY2lpID0gZ2x5cGguY29kZSA8IDI1NjtcbiAgICAgICAgdmFyIGlzQmFzaWNDb2xvciA9IGdseXBoLmZnIDwgMTY7XG4gICAgICAgIHZhciBpc0RlZmF1bHRDb2xvciA9IGdseXBoLmZnID49IDI1NjtcbiAgICAgICAgdmFyIGlzRGVmYXVsdEJhY2tncm91bmQgPSBnbHlwaC5iZyA+PSAyNTY7XG4gICAgICAgIHJldHVybiBpc0FzY2lpICYmIChpc0Jhc2ljQ29sb3IgfHwgaXNEZWZhdWx0Q29sb3IpICYmIGlzRGVmYXVsdEJhY2tncm91bmQgJiYgIWdseXBoLml0YWxpYztcbiAgICB9O1xuICAgIFN0YXRpY0NoYXJBdGxhcy5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgsIGdseXBoLCB4LCB5KSB7XG4gICAgICAgIGlmICh0aGlzLl90ZXh0dXJlID09PSBudWxsIHx8IHRoaXMuX3RleHR1cmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2xvckluZGV4ID0gMDtcbiAgICAgICAgaWYgKGdseXBoLmZnIDwgMjU2KSB7XG4gICAgICAgICAgICBjb2xvckluZGV4ID0gMiArIGdseXBoLmZnICsgKGdseXBoLmJvbGQgPyAxNiA6IDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGdseXBoLmJvbGQpIHtcbiAgICAgICAgICAgICAgICBjb2xvckluZGV4ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2lzQ2FjaGVkKGdseXBoLCBjb2xvckluZGV4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIHZhciBjaGFyQXRsYXNDZWxsV2lkdGggPSB0aGlzLl9jb25maWcuc2NhbGVkQ2hhcldpZHRoICsgVHlwZXNfMi5DSEFSX0FUTEFTX0NFTExfU1BBQ0lORztcbiAgICAgICAgdmFyIGNoYXJBdGxhc0NlbGxIZWlnaHQgPSB0aGlzLl9jb25maWcuc2NhbGVkQ2hhckhlaWdodCArIFR5cGVzXzIuQ0hBUl9BVExBU19DRUxMX1NQQUNJTkc7XG4gICAgICAgIGlmIChnbHlwaC5kaW0pIHtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IFR5cGVzXzEuRElNX09QQUNJVFk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLl90ZXh0dXJlLCBnbHlwaC5jb2RlICogY2hhckF0bGFzQ2VsbFdpZHRoLCBjb2xvckluZGV4ICogY2hhckF0bGFzQ2VsbEhlaWdodCwgY2hhckF0bGFzQ2VsbFdpZHRoLCB0aGlzLl9jb25maWcuc2NhbGVkQ2hhckhlaWdodCwgeCwgeSwgY2hhckF0bGFzQ2VsbFdpZHRoLCB0aGlzLl9jb25maWcuc2NhbGVkQ2hhckhlaWdodCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRpY0NoYXJBdGxhcztcbn0oQmFzZUNoYXJBdGxhc18xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFN0YXRpY0NoYXJBdGxhcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0YXRpY0NoYXJBdGxhcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSU5WRVJURURfREVGQVVMVF9DT0xPUiA9IC0xO1xuZXhwb3J0cy5ESU1fT1BBQ0lUWSA9IDAuNTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVR5cGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBFdmVudEVtaXR0ZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vRXZlbnRFbWl0dGVyXCIpO1xudmFyIENvbG9yTWFuYWdlcl8xID0gcmVxdWlyZShcIi4uL0NvbG9yTWFuYWdlclwiKTtcbnZhciBSZW5kZXJEZWJvdW5jZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi91aS9SZW5kZXJEZWJvdW5jZXJcIik7XG52YXIgRG9tUmVuZGVyZXJSb3dGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi9Eb21SZW5kZXJlclJvd0ZhY3RvcnlcIik7XG52YXIgVEVSTUlOQUxfQ0xBU1NfUFJFRklYID0gJ3h0ZXJtLWRvbS1yZW5kZXJlci1vd25lci0nO1xudmFyIFJPV19DT05UQUlORVJfQ0xBU1MgPSAneHRlcm0tcm93cyc7XG52YXIgRkdfQ0xBU1NfUFJFRklYID0gJ3h0ZXJtLWZnLSc7XG52YXIgQkdfQ0xBU1NfUFJFRklYID0gJ3h0ZXJtLWJnLSc7XG52YXIgRk9DVVNfQ0xBU1MgPSAneHRlcm0tZm9jdXMnO1xudmFyIFNFTEVDVElPTl9DTEFTUyA9ICd4dGVybS1zZWxlY3Rpb24nO1xudmFyIG5leHRUZXJtaW5hbElkID0gMTtcbnZhciBEb21SZW5kZXJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERvbVJlbmRlcmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERvbVJlbmRlcmVyKF90ZXJtaW5hbCwgdGhlbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3Rlcm1pbmFsID0gX3Rlcm1pbmFsO1xuICAgICAgICBfdGhpcy5fdGVybWluYWxDbGFzcyA9IG5leHRUZXJtaW5hbElkKys7XG4gICAgICAgIF90aGlzLl9yb3dFbGVtZW50cyA9IFtdO1xuICAgICAgICB2YXIgYWxsb3dUcmFuc3BhcmVuY3kgPSBfdGhpcy5fdGVybWluYWwub3B0aW9ucy5hbGxvd1RyYW5zcGFyZW5jeTtcbiAgICAgICAgX3RoaXMuY29sb3JNYW5hZ2VyID0gbmV3IENvbG9yTWFuYWdlcl8xLkNvbG9yTWFuYWdlcihkb2N1bWVudCwgYWxsb3dUcmFuc3BhcmVuY3kpO1xuICAgICAgICBfdGhpcy5zZXRUaGVtZSh0aGVtZSk7XG4gICAgICAgIF90aGlzLl9yb3dDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgX3RoaXMuX3Jvd0NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFJPV19DT05UQUlORVJfQ0xBU1MpO1xuICAgICAgICBfdGhpcy5fcm93Q29udGFpbmVyLnN0eWxlLmxpbmVIZWlnaHQgPSAnbm9ybWFsJztcbiAgICAgICAgX3RoaXMuX3Jvd0NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICAgICAgX3RoaXMuX3JlZnJlc2hSb3dFbGVtZW50cyhfdGhpcy5fdGVybWluYWwuY29scywgX3RoaXMuX3Rlcm1pbmFsLnJvd3MpO1xuICAgICAgICBfdGhpcy5fc2VsZWN0aW9uQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIF90aGlzLl9zZWxlY3Rpb25Db250YWluZXIuY2xhc3NMaXN0LmFkZChTRUxFQ1RJT05fQ0xBU1MpO1xuICAgICAgICBfdGhpcy5fc2VsZWN0aW9uQ29udGFpbmVyLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgICAgICBfdGhpcy5kaW1lbnNpb25zID0ge1xuICAgICAgICAgICAgc2NhbGVkQ2hhcldpZHRoOiBudWxsLFxuICAgICAgICAgICAgc2NhbGVkQ2hhckhlaWdodDogbnVsbCxcbiAgICAgICAgICAgIHNjYWxlZENlbGxXaWR0aDogbnVsbCxcbiAgICAgICAgICAgIHNjYWxlZENlbGxIZWlnaHQ6IG51bGwsXG4gICAgICAgICAgICBzY2FsZWRDaGFyTGVmdDogbnVsbCxcbiAgICAgICAgICAgIHNjYWxlZENoYXJUb3A6IG51bGwsXG4gICAgICAgICAgICBzY2FsZWRDYW52YXNXaWR0aDogbnVsbCxcbiAgICAgICAgICAgIHNjYWxlZENhbnZhc0hlaWdodDogbnVsbCxcbiAgICAgICAgICAgIGNhbnZhc1dpZHRoOiBudWxsLFxuICAgICAgICAgICAgY2FudmFzSGVpZ2h0OiBudWxsLFxuICAgICAgICAgICAgYWN0dWFsQ2VsbFdpZHRoOiBudWxsLFxuICAgICAgICAgICAgYWN0dWFsQ2VsbEhlaWdodDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5fdXBkYXRlRGltZW5zaW9ucygpO1xuICAgICAgICBfdGhpcy5fcmVuZGVyRGVib3VuY2VyID0gbmV3IFJlbmRlckRlYm91bmNlcl8xLlJlbmRlckRlYm91bmNlcihfdGhpcy5fdGVybWluYWwsIF90aGlzLl9yZW5kZXJSb3dzLmJpbmQoX3RoaXMpKTtcbiAgICAgICAgX3RoaXMuX3Jvd0ZhY3RvcnkgPSBuZXcgRG9tUmVuZGVyZXJSb3dGYWN0b3J5XzEuRG9tUmVuZGVyZXJSb3dGYWN0b3J5KGRvY3VtZW50KTtcbiAgICAgICAgX3RoaXMuX3Rlcm1pbmFsLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChURVJNSU5BTF9DTEFTU19QUkVGSVggKyBfdGhpcy5fdGVybWluYWxDbGFzcyk7XG4gICAgICAgIF90aGlzLl90ZXJtaW5hbC5zY3JlZW5FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzLl9yb3dDb250YWluZXIpO1xuICAgICAgICBfdGhpcy5fdGVybWluYWwuc2NyZWVuRWxlbWVudC5hcHBlbmRDaGlsZChfdGhpcy5fc2VsZWN0aW9uQ29udGFpbmVyKTtcbiAgICAgICAgX3RoaXMuX3Rlcm1pbmFsLmxpbmtpZmllci5vbihcImxpbmtob3ZlclwiLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3RoaXMuX29uTGlua0hvdmVyKGUpOyB9KTtcbiAgICAgICAgX3RoaXMuX3Rlcm1pbmFsLmxpbmtpZmllci5vbihcImxpbmtsZWF2ZVwiLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3RoaXMuX29uTGlua0xlYXZlKGUpOyB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdGVybWluYWwuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFRFUk1JTkFMX0NMQVNTX1BSRUZJWCArIHRoaXMuX3Rlcm1pbmFsQ2xhc3MpO1xuICAgICAgICB0aGlzLl90ZXJtaW5hbC5zY3JlZW5FbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuX3Jvd0NvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsLnNjcmVlbkVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5fc2VsZWN0aW9uQ29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5fdGVybWluYWwuc2NyZWVuRWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLl90aGVtZVN0eWxlRWxlbWVudCk7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsLnNjcmVlbkVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5fZGltZW5zaW9uc1N0eWxlRWxlbWVudCk7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGVEaW1lbnNpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmRpbWVuc2lvbnMuc2NhbGVkQ2hhcldpZHRoID0gdGhpcy5fdGVybWluYWwuY2hhck1lYXN1cmUud2lkdGggKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zLnNjYWxlZENoYXJIZWlnaHQgPSB0aGlzLl90ZXJtaW5hbC5jaGFyTWVhc3VyZS5oZWlnaHQgKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zLnNjYWxlZENlbGxXaWR0aCA9IHRoaXMuZGltZW5zaW9ucy5zY2FsZWRDaGFyV2lkdGg7XG4gICAgICAgIHRoaXMuZGltZW5zaW9ucy5zY2FsZWRDZWxsSGVpZ2h0ID0gdGhpcy5kaW1lbnNpb25zLnNjYWxlZENoYXJIZWlnaHQ7XG4gICAgICAgIHRoaXMuZGltZW5zaW9ucy5zY2FsZWRDaGFyTGVmdCA9IDA7XG4gICAgICAgIHRoaXMuZGltZW5zaW9ucy5zY2FsZWRDaGFyVG9wID0gMDtcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zLnNjYWxlZENhbnZhc1dpZHRoID0gdGhpcy5kaW1lbnNpb25zLnNjYWxlZENlbGxXaWR0aCAqIHRoaXMuX3Rlcm1pbmFsLmNvbHM7XG4gICAgICAgIHRoaXMuZGltZW5zaW9ucy5zY2FsZWRDYW52YXNIZWlnaHQgPSB0aGlzLmRpbWVuc2lvbnMuc2NhbGVkQ2VsbEhlaWdodCAqIHRoaXMuX3Rlcm1pbmFsLnJvd3M7XG4gICAgICAgIHRoaXMuZGltZW5zaW9ucy5jYW52YXNXaWR0aCA9IHRoaXMuX3Rlcm1pbmFsLmNoYXJNZWFzdXJlLndpZHRoICogdGhpcy5fdGVybWluYWwuY29scztcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zLmNhbnZhc0hlaWdodCA9IHRoaXMuX3Rlcm1pbmFsLmNoYXJNZWFzdXJlLmhlaWdodCAqIHRoaXMuX3Rlcm1pbmFsLnJvd3M7XG4gICAgICAgIHRoaXMuZGltZW5zaW9ucy5hY3R1YWxDZWxsV2lkdGggPSB0aGlzLl90ZXJtaW5hbC5jaGFyTWVhc3VyZS53aWR0aDtcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zLmFjdHVhbENlbGxIZWlnaHQgPSB0aGlzLl90ZXJtaW5hbC5jaGFyTWVhc3VyZS5oZWlnaHQ7XG4gICAgICAgIHRoaXMuX3Jvd0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSBfdGhpcy5kaW1lbnNpb25zLmNhbnZhc1dpZHRoICsgXCJweFwiO1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBfdGhpcy5fdGVybWluYWwuY2hhck1lYXN1cmUuaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF0aGlzLl9kaW1lbnNpb25zU3R5bGVFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1lbnNpb25zU3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLnNjcmVlbkVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fZGltZW5zaW9uc1N0eWxlRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0eWxlcyA9IHRoaXMuX3Rlcm1pbmFsU2VsZWN0b3IgKyBcIiAuXCIgKyBST1dfQ09OVEFJTkVSX0NMQVNTICsgXCIgc3BhbiB7XCIgK1xuICAgICAgICAgICAgXCIgZGlzcGxheTogaW5saW5lLWJsb2NrO1wiICtcbiAgICAgICAgICAgIFwiIGhlaWdodDogMTAwJTtcIiArXG4gICAgICAgICAgICBcIiB2ZXJ0aWNhbC1hbGlnbjogdG9wO1wiICtcbiAgICAgICAgICAgIChcIiB3aWR0aDogXCIgKyB0aGlzLl90ZXJtaW5hbC5jaGFyTWVhc3VyZS53aWR0aCArIFwicHhcIikgK1xuICAgICAgICAgICAgXCJ9XCI7XG4gICAgICAgIHRoaXMuX2RpbWVuc2lvbnNTdHlsZUVsZW1lbnQuaW5uZXJIVE1MID0gc3R5bGVzO1xuICAgICAgICB0aGlzLl9zZWxlY3Rpb25Db250YWluZXIuc3R5bGUuaGVpZ2h0ID0gdGhpcy5fdGVybWluYWwuX3ZpZXdwb3J0RWxlbWVudC5zdHlsZS5oZWlnaHQ7XG4gICAgICAgIHRoaXMuX3Jvd0NvbnRhaW5lci5zdHlsZS53aWR0aCA9IHRoaXMuZGltZW5zaW9ucy5jYW52YXNXaWR0aCArIFwicHhcIjtcbiAgICAgICAgdGhpcy5fcm93Q29udGFpbmVyLnN0eWxlLmhlaWdodCA9IHRoaXMuZGltZW5zaW9ucy5jYW52YXNIZWlnaHQgKyBcInB4XCI7XG4gICAgfTtcbiAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuc2V0VGhlbWUgPSBmdW5jdGlvbiAodGhlbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoZW1lKSB7XG4gICAgICAgICAgICB0aGlzLmNvbG9yTWFuYWdlci5zZXRUaGVtZSh0aGVtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl90aGVtZVN0eWxlRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fdGhlbWVTdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuc2NyZWVuRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl90aGVtZVN0eWxlRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0eWxlcyA9IHRoaXMuX3Rlcm1pbmFsU2VsZWN0b3IgKyBcIiAuXCIgKyBST1dfQ09OVEFJTkVSX0NMQVNTICsgXCIge1wiICtcbiAgICAgICAgICAgIChcIiBjb2xvcjogXCIgKyB0aGlzLmNvbG9yTWFuYWdlci5jb2xvcnMuZm9yZWdyb3VuZC5jc3MgKyBcIjtcIikgK1xuICAgICAgICAgICAgKFwiIGJhY2tncm91bmQtY29sb3I6IFwiICsgdGhpcy5jb2xvck1hbmFnZXIuY29sb3JzLmJhY2tncm91bmQuY3NzICsgXCI7XCIpICtcbiAgICAgICAgICAgIChcIiBmb250LWZhbWlseTogXCIgKyB0aGlzLl90ZXJtaW5hbC5nZXRPcHRpb24oJ2ZvbnRGYW1pbHknKSArIFwiO1wiKSArXG4gICAgICAgICAgICAoXCIgZm9udC1zaXplOiBcIiArIHRoaXMuX3Rlcm1pbmFsLmdldE9wdGlvbignZm9udFNpemUnKSArIFwicHg7XCIpICtcbiAgICAgICAgICAgIFwifVwiO1xuICAgICAgICBzdHlsZXMgKz1cbiAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsU2VsZWN0b3IgKyBcIiBzcGFuOm5vdCguXCIgKyBEb21SZW5kZXJlclJvd0ZhY3RvcnlfMS5CT0xEX0NMQVNTICsgXCIpIHtcIiArXG4gICAgICAgICAgICAgICAgKFwiIGZvbnQtd2VpZ2h0OiBcIiArIHRoaXMuX3Rlcm1pbmFsLm9wdGlvbnMuZm9udFdlaWdodCArIFwiO1wiKSArXG4gICAgICAgICAgICAgICAgXCJ9XCIgK1xuICAgICAgICAgICAgICAgICh0aGlzLl90ZXJtaW5hbFNlbGVjdG9yICsgXCIgc3Bhbi5cIiArIERvbVJlbmRlcmVyUm93RmFjdG9yeV8xLkJPTERfQ0xBU1MgKyBcIiB7XCIpICtcbiAgICAgICAgICAgICAgICAoXCIgZm9udC13ZWlnaHQ6IFwiICsgdGhpcy5fdGVybWluYWwub3B0aW9ucy5mb250V2VpZ2h0Qm9sZCArIFwiO1wiKSArXG4gICAgICAgICAgICAgICAgXCJ9XCIgK1xuICAgICAgICAgICAgICAgICh0aGlzLl90ZXJtaW5hbFNlbGVjdG9yICsgXCIgc3Bhbi5cIiArIERvbVJlbmRlcmVyUm93RmFjdG9yeV8xLklUQUxJQ19DTEFTUyArIFwiIHtcIikgK1xuICAgICAgICAgICAgICAgIFwiIGZvbnQtc3R5bGU6IGl0YWxpYztcIiArXG4gICAgICAgICAgICAgICAgXCJ9XCI7XG4gICAgICAgIHN0eWxlcyArPVxuICAgICAgICAgICAgdGhpcy5fdGVybWluYWxTZWxlY3RvciArIFwiIC5cIiArIFJPV19DT05UQUlORVJfQ0xBU1MgKyBcIjpub3QoLlwiICsgRk9DVVNfQ0xBU1MgKyBcIikgLlwiICsgRG9tUmVuZGVyZXJSb3dGYWN0b3J5XzEuQ1VSU09SX0NMQVNTICsgXCIge1wiICtcbiAgICAgICAgICAgICAgICAoXCIgb3V0bGluZTogMXB4IHNvbGlkIFwiICsgdGhpcy5jb2xvck1hbmFnZXIuY29sb3JzLmN1cnNvci5jc3MgKyBcIjtcIikgK1xuICAgICAgICAgICAgICAgIFwiIG91dGxpbmUtb2Zmc2V0OiAtMXB4O1wiICtcbiAgICAgICAgICAgICAgICBcIn1cIiArXG4gICAgICAgICAgICAgICAgKHRoaXMuX3Rlcm1pbmFsU2VsZWN0b3IgKyBcIiAuXCIgKyBST1dfQ09OVEFJTkVSX0NMQVNTICsgXCIuXCIgKyBGT0NVU19DTEFTUyArIFwiIC5cIiArIERvbVJlbmRlcmVyUm93RmFjdG9yeV8xLkNVUlNPUl9DTEFTUyArIFwiLlwiICsgRG9tUmVuZGVyZXJSb3dGYWN0b3J5XzEuQ1VSU09SX1NUWUxFX0JMT0NLX0NMQVNTICsgXCIge1wiKSArXG4gICAgICAgICAgICAgICAgKFwiIGJhY2tncm91bmQtY29sb3I6IFwiICsgdGhpcy5jb2xvck1hbmFnZXIuY29sb3JzLmN1cnNvci5jc3MgKyBcIjtcIikgK1xuICAgICAgICAgICAgICAgIChcIiBjb2xvcjogXCIgKyB0aGlzLmNvbG9yTWFuYWdlci5jb2xvcnMuY3Vyc29yQWNjZW50LmNzcyArIFwiO1wiKSArXG4gICAgICAgICAgICAgICAgXCJ9XCIgK1xuICAgICAgICAgICAgICAgICh0aGlzLl90ZXJtaW5hbFNlbGVjdG9yICsgXCIgLlwiICsgUk9XX0NPTlRBSU5FUl9DTEFTUyArIFwiLlwiICsgRk9DVVNfQ0xBU1MgKyBcIiAuXCIgKyBEb21SZW5kZXJlclJvd0ZhY3RvcnlfMS5DVVJTT1JfQ0xBU1MgKyBcIi5cIiArIERvbVJlbmRlcmVyUm93RmFjdG9yeV8xLkNVUlNPUl9TVFlMRV9CQVJfQ0xBU1MgKyBcIiB7XCIpICtcbiAgICAgICAgICAgICAgICAoXCIgYm94LXNoYWRvdzogMXB4IDAgMCBcIiArIHRoaXMuY29sb3JNYW5hZ2VyLmNvbG9ycy5jdXJzb3IuY3NzICsgXCIgaW5zZXQ7XCIpICtcbiAgICAgICAgICAgICAgICBcIn1cIiArXG4gICAgICAgICAgICAgICAgKHRoaXMuX3Rlcm1pbmFsU2VsZWN0b3IgKyBcIiAuXCIgKyBST1dfQ09OVEFJTkVSX0NMQVNTICsgXCIuXCIgKyBGT0NVU19DTEFTUyArIFwiIC5cIiArIERvbVJlbmRlcmVyUm93RmFjdG9yeV8xLkNVUlNPUl9DTEFTUyArIFwiLlwiICsgRG9tUmVuZGVyZXJSb3dGYWN0b3J5XzEuQ1VSU09SX1NUWUxFX1VOREVSTElORV9DTEFTUyArIFwiIHtcIikgK1xuICAgICAgICAgICAgICAgIChcIiBib3gtc2hhZG93OiAwIC0xcHggMCBcIiArIHRoaXMuY29sb3JNYW5hZ2VyLmNvbG9ycy5jdXJzb3IuY3NzICsgXCIgaW5zZXQ7XCIpICtcbiAgICAgICAgICAgICAgICBcIn1cIjtcbiAgICAgICAgc3R5bGVzICs9XG4gICAgICAgICAgICB0aGlzLl90ZXJtaW5hbFNlbGVjdG9yICsgXCIgLlwiICsgU0VMRUNUSU9OX0NMQVNTICsgXCIge1wiICtcbiAgICAgICAgICAgICAgICBcIiBwb3NpdGlvbjogYWJzb2x1dGU7XCIgK1xuICAgICAgICAgICAgICAgIFwiIHRvcDogMDtcIiArXG4gICAgICAgICAgICAgICAgXCIgbGVmdDogMDtcIiArXG4gICAgICAgICAgICAgICAgXCIgei1pbmRleDogMTtcIiArXG4gICAgICAgICAgICAgICAgXCIgcG9pbnRlci1ldmVudHM6IG5vbmU7XCIgK1xuICAgICAgICAgICAgICAgIFwifVwiICtcbiAgICAgICAgICAgICAgICAodGhpcy5fdGVybWluYWxTZWxlY3RvciArIFwiIC5cIiArIFNFTEVDVElPTl9DTEFTUyArIFwiIGRpdiB7XCIpICtcbiAgICAgICAgICAgICAgICBcIiBwb3NpdGlvbjogYWJzb2x1dGU7XCIgK1xuICAgICAgICAgICAgICAgIChcIiBiYWNrZ3JvdW5kLWNvbG9yOiBcIiArIHRoaXMuY29sb3JNYW5hZ2VyLmNvbG9ycy5zZWxlY3Rpb24uY3NzICsgXCI7XCIpICtcbiAgICAgICAgICAgICAgICBcIn1cIjtcbiAgICAgICAgdGhpcy5jb2xvck1hbmFnZXIuY29sb3JzLmFuc2kuZm9yRWFjaChmdW5jdGlvbiAoYywgaSkge1xuICAgICAgICAgICAgc3R5bGVzICs9XG4gICAgICAgICAgICAgICAgX3RoaXMuX3Rlcm1pbmFsU2VsZWN0b3IgKyBcIiAuXCIgKyBGR19DTEFTU19QUkVGSVggKyBpICsgXCIgeyBjb2xvcjogXCIgKyBjLmNzcyArIFwiOyB9XCIgK1xuICAgICAgICAgICAgICAgICAgICAoX3RoaXMuX3Rlcm1pbmFsU2VsZWN0b3IgKyBcIiAuXCIgKyBCR19DTEFTU19QUkVGSVggKyBpICsgXCIgeyBiYWNrZ3JvdW5kLWNvbG9yOiBcIiArIGMuY3NzICsgXCI7IH1cIik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl90aGVtZVN0eWxlRWxlbWVudC5pbm5lckhUTUwgPSBzdHlsZXM7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbG9yTWFuYWdlci5jb2xvcnM7XG4gICAgfTtcbiAgICBEb21SZW5kZXJlci5wcm90b3R5cGUub25XaW5kb3dSZXNpemUgPSBmdW5jdGlvbiAoZGV2aWNlUGl4ZWxSYXRpbykge1xuICAgICAgICB0aGlzLl91cGRhdGVEaW1lbnNpb25zKCk7XG4gICAgfTtcbiAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuX3JlZnJlc2hSb3dFbGVtZW50cyA9IGZ1bmN0aW9uIChjb2xzLCByb3dzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9yb3dFbGVtZW50cy5sZW5ndGg7IGkgPD0gcm93czsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aGlzLl9yb3dDb250YWluZXIuYXBwZW5kQ2hpbGQocm93KTtcbiAgICAgICAgICAgIHRoaXMuX3Jvd0VsZW1lbnRzLnB1c2gocm93KTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGhpcy5fcm93RWxlbWVudHMubGVuZ3RoID4gcm93cykge1xuICAgICAgICAgICAgdGhpcy5fcm93Q29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuX3Jvd0VsZW1lbnRzLnBvcCgpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLm9uUmVzaXplID0gZnVuY3Rpb24gKGNvbHMsIHJvd3MpIHtcbiAgICAgICAgdGhpcy5fcmVmcmVzaFJvd0VsZW1lbnRzKGNvbHMsIHJvd3MpO1xuICAgICAgICB0aGlzLl91cGRhdGVEaW1lbnNpb25zKCk7XG4gICAgfTtcbiAgICBEb21SZW5kZXJlci5wcm90b3R5cGUub25DaGFyU2l6ZUNoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbnMoKTtcbiAgICB9O1xuICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5vbkJsdXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3Jvd0NvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKEZPQ1VTX0NMQVNTKTtcbiAgICB9O1xuICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5vbkZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yb3dDb250YWluZXIuY2xhc3NMaXN0LmFkZChGT0NVU19DTEFTUyk7XG4gICAgfTtcbiAgICBEb21SZW5kZXJlci5wcm90b3R5cGUub25TZWxlY3Rpb25DaGFuZ2VkID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIGNvbHVtblNlbGVjdE1vZGUpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX3NlbGVjdGlvbkNvbnRhaW5lci5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbkNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLl9zZWxlY3Rpb25Db250YWluZXIuY2hpbGRyZW5bMF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RhcnQgfHwgIWVuZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2aWV3cG9ydFN0YXJ0Um93ID0gc3RhcnRbMV0gLSB0aGlzLl90ZXJtaW5hbC5idWZmZXIueWRpc3A7XG4gICAgICAgIHZhciB2aWV3cG9ydEVuZFJvdyA9IGVuZFsxXSAtIHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci55ZGlzcDtcbiAgICAgICAgdmFyIHZpZXdwb3J0Q2FwcGVkU3RhcnRSb3cgPSBNYXRoLm1heCh2aWV3cG9ydFN0YXJ0Um93LCAwKTtcbiAgICAgICAgdmFyIHZpZXdwb3J0Q2FwcGVkRW5kUm93ID0gTWF0aC5taW4odmlld3BvcnRFbmRSb3csIHRoaXMuX3Rlcm1pbmFsLnJvd3MgLSAxKTtcbiAgICAgICAgaWYgKHZpZXdwb3J0Q2FwcGVkU3RhcnRSb3cgPj0gdGhpcy5fdGVybWluYWwucm93cyB8fCB2aWV3cG9ydENhcHBlZEVuZFJvdyA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZG9jdW1lbnRGcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgaWYgKGNvbHVtblNlbGVjdE1vZGUpIHtcbiAgICAgICAgICAgIGRvY3VtZW50RnJhZ21lbnQuYXBwZW5kQ2hpbGQodGhpcy5fY3JlYXRlU2VsZWN0aW9uRWxlbWVudCh2aWV3cG9ydENhcHBlZFN0YXJ0Um93LCBzdGFydFswXSwgZW5kWzBdLCB2aWV3cG9ydENhcHBlZEVuZFJvdyAtIHZpZXdwb3J0Q2FwcGVkU3RhcnRSb3cgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRDb2wgPSB2aWV3cG9ydFN0YXJ0Um93ID09PSB2aWV3cG9ydENhcHBlZFN0YXJ0Um93ID8gc3RhcnRbMF0gOiAwO1xuICAgICAgICAgICAgdmFyIGVuZENvbCA9IHZpZXdwb3J0Q2FwcGVkU3RhcnRSb3cgPT09IHZpZXdwb3J0Q2FwcGVkRW5kUm93ID8gZW5kWzBdIDogdGhpcy5fdGVybWluYWwuY29scztcbiAgICAgICAgICAgIGRvY3VtZW50RnJhZ21lbnQuYXBwZW5kQ2hpbGQodGhpcy5fY3JlYXRlU2VsZWN0aW9uRWxlbWVudCh2aWV3cG9ydENhcHBlZFN0YXJ0Um93LCBzdGFydENvbCwgZW5kQ29sKSk7XG4gICAgICAgICAgICB2YXIgbWlkZGxlUm93c0NvdW50ID0gdmlld3BvcnRDYXBwZWRFbmRSb3cgLSB2aWV3cG9ydENhcHBlZFN0YXJ0Um93IC0gMTtcbiAgICAgICAgICAgIGRvY3VtZW50RnJhZ21lbnQuYXBwZW5kQ2hpbGQodGhpcy5fY3JlYXRlU2VsZWN0aW9uRWxlbWVudCh2aWV3cG9ydENhcHBlZFN0YXJ0Um93ICsgMSwgMCwgdGhpcy5fdGVybWluYWwuY29scywgbWlkZGxlUm93c0NvdW50KSk7XG4gICAgICAgICAgICBpZiAodmlld3BvcnRDYXBwZWRTdGFydFJvdyAhPT0gdmlld3BvcnRDYXBwZWRFbmRSb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW5kQ29sXzEgPSB2aWV3cG9ydEVuZFJvdyA9PT0gdmlld3BvcnRDYXBwZWRFbmRSb3cgPyBlbmRbMF0gOiB0aGlzLl90ZXJtaW5hbC5jb2xzO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50RnJhZ21lbnQuYXBwZW5kQ2hpbGQodGhpcy5fY3JlYXRlU2VsZWN0aW9uRWxlbWVudCh2aWV3cG9ydENhcHBlZEVuZFJvdywgMCwgZW5kQ29sXzEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZWxlY3Rpb25Db250YWluZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnRGcmFnbWVudCk7XG4gICAgfTtcbiAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuX2NyZWF0ZVNlbGVjdGlvbkVsZW1lbnQgPSBmdW5jdGlvbiAocm93LCBjb2xTdGFydCwgY29sRW5kLCByb3dDb3VudCkge1xuICAgICAgICBpZiAocm93Q291bnQgPT09IHZvaWQgMCkgeyByb3dDb3VudCA9IDE7IH1cbiAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSByb3dDb3VudCAqIHRoaXMuX3Rlcm1pbmFsLmNoYXJNZWFzdXJlLmhlaWdodCArIFwicHhcIjtcbiAgICAgICAgZWxlbWVudC5zdHlsZS50b3AgPSByb3cgKiB0aGlzLl90ZXJtaW5hbC5jaGFyTWVhc3VyZS5oZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUubGVmdCA9IGNvbFN0YXJ0ICogdGhpcy5fdGVybWluYWwuY2hhck1lYXN1cmUud2lkdGggKyBcInB4XCI7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSB0aGlzLl90ZXJtaW5hbC5jaGFyTWVhc3VyZS53aWR0aCAqIChjb2xFbmQgLSBjb2xTdGFydCkgKyBcInB4XCI7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG4gICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLm9uQ3Vyc29yTW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB9O1xuICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5vbk9wdGlvbnNDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl91cGRhdGVEaW1lbnNpb25zKCk7XG4gICAgICAgIHRoaXMuc2V0VGhlbWUodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5fdGVybWluYWwucmVmcmVzaCgwLCB0aGlzLl90ZXJtaW5hbC5yb3dzIC0gMSk7XG4gICAgfTtcbiAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3Jvd0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUuaW5uZXJIVE1MID0gJyc7IH0pO1xuICAgIH07XG4gICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLnJlZnJlc2hSb3dzID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyRGVib3VuY2VyLnJlZnJlc2goc3RhcnQsIGVuZCk7XG4gICAgfTtcbiAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuX3JlbmRlclJvd3MgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgdGVybWluYWwgPSB0aGlzLl90ZXJtaW5hbDtcbiAgICAgICAgdmFyIGN1cnNvckFic29sdXRlWSA9IHRlcm1pbmFsLmJ1ZmZlci55YmFzZSArIHRlcm1pbmFsLmJ1ZmZlci55O1xuICAgICAgICB2YXIgY3Vyc29yWCA9IHRoaXMuX3Rlcm1pbmFsLmJ1ZmZlci54O1xuICAgICAgICBmb3IgKHZhciB5ID0gc3RhcnQ7IHkgPD0gZW5kOyB5KyspIHtcbiAgICAgICAgICAgIHZhciByb3dFbGVtZW50ID0gdGhpcy5fcm93RWxlbWVudHNbeV07XG4gICAgICAgICAgICByb3dFbGVtZW50LmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgICAgdmFyIHJvdyA9IHkgKyB0ZXJtaW5hbC5idWZmZXIueWRpc3A7XG4gICAgICAgICAgICB2YXIgbGluZURhdGEgPSB0ZXJtaW5hbC5idWZmZXIubGluZXMuZ2V0KHJvdyk7XG4gICAgICAgICAgICB2YXIgY3Vyc29yU3R5bGUgPSB0ZXJtaW5hbC5vcHRpb25zLmN1cnNvclN0eWxlO1xuICAgICAgICAgICAgcm93RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9yb3dGYWN0b3J5LmNyZWF0ZVJvdyhsaW5lRGF0YSwgcm93ID09PSBjdXJzb3JBYnNvbHV0ZVksIGN1cnNvclN0eWxlLCBjdXJzb3JYLCB0ZXJtaW5hbC5jaGFyTWVhc3VyZS53aWR0aCwgdGVybWluYWwuY29scykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsLmVtaXQoJ3JlZnJlc2gnLCB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRG9tUmVuZGVyZXIucHJvdG90eXBlLCBcIl90ZXJtaW5hbFNlbGVjdG9yXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIuXCIgKyBURVJNSU5BTF9DTEFTU19QUkVGSVggKyB0aGlzLl90ZXJtaW5hbENsYXNzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBEb21SZW5kZXJlci5wcm90b3R5cGUucmVnaXN0ZXJDaGFyYWN0ZXJKb2luZXIgPSBmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gLTE7IH07XG4gICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLmRlcmVnaXN0ZXJDaGFyYWN0ZXJKb2luZXIgPSBmdW5jdGlvbiAoam9pbmVySWQpIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5fb25MaW5rSG92ZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl9zZXRDZWxsVW5kZXJsaW5lKGUueDEsIGUueDIsIGUueTEsIGUueTIsIGUuY29scywgdHJ1ZSk7XG4gICAgfTtcbiAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuX29uTGlua0xlYXZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fc2V0Q2VsbFVuZGVybGluZShlLngxLCBlLngyLCBlLnkxLCBlLnkyLCBlLmNvbHMsIGZhbHNlKTtcbiAgICB9O1xuICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5fc2V0Q2VsbFVuZGVybGluZSA9IGZ1bmN0aW9uICh4LCB4MiwgeSwgeTIsIGNvbHMsIGVuYWJsZWQpIHtcbiAgICAgICAgd2hpbGUgKHggIT09IHgyIHx8IHkgIT09IHkyKSB7XG4gICAgICAgICAgICB2YXIgc3BhbiA9IHRoaXMuX3Jvd0VsZW1lbnRzW3ldLmNoaWxkcmVuW3hdO1xuICAgICAgICAgICAgc3Bhbi5zdHlsZS50ZXh0RGVjb3JhdGlvbiA9IGVuYWJsZWQgPyAndW5kZXJsaW5lJyA6ICdub25lJztcbiAgICAgICAgICAgIHggPSAoeCArIDEpICUgY29scztcbiAgICAgICAgICAgIGlmICh4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgeSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRG9tUmVuZGVyZXI7XG59KEV2ZW50RW1pdHRlcl8xLkV2ZW50RW1pdHRlcikpO1xuZXhwb3J0cy5Eb21SZW5kZXJlciA9IERvbVJlbmRlcmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RG9tUmVuZGVyZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQnVmZmVyXzEgPSByZXF1aXJlKFwiLi4vLi4vQnVmZmVyXCIpO1xuZXhwb3J0cy5CT0xEX0NMQVNTID0gJ3h0ZXJtLWJvbGQnO1xuZXhwb3J0cy5JVEFMSUNfQ0xBU1MgPSAneHRlcm0taXRhbGljJztcbmV4cG9ydHMuQ1VSU09SX0NMQVNTID0gJ3h0ZXJtLWN1cnNvcic7XG5leHBvcnRzLkNVUlNPUl9TVFlMRV9CTE9DS19DTEFTUyA9ICd4dGVybS1jdXJzb3ItYmxvY2snO1xuZXhwb3J0cy5DVVJTT1JfU1RZTEVfQkFSX0NMQVNTID0gJ3h0ZXJtLWN1cnNvci1iYXInO1xuZXhwb3J0cy5DVVJTT1JfU1RZTEVfVU5ERVJMSU5FX0NMQVNTID0gJ3h0ZXJtLWN1cnNvci11bmRlcmxpbmUnO1xudmFyIERvbVJlbmRlcmVyUm93RmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRG9tUmVuZGVyZXJSb3dGYWN0b3J5KF9kb2N1bWVudCkge1xuICAgICAgICB0aGlzLl9kb2N1bWVudCA9IF9kb2N1bWVudDtcbiAgICB9XG4gICAgRG9tUmVuZGVyZXJSb3dGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVSb3cgPSBmdW5jdGlvbiAobGluZURhdGEsIGlzQ3Vyc29yUm93LCBjdXJzb3JTdHlsZSwgY3Vyc29yWCwgY2VsbFdpZHRoLCBjb2xzKSB7XG4gICAgICAgIHZhciBmcmFnbWVudCA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgdmFyIGNvbENvdW50ID0gMDtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBsaW5lRGF0YS5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgaWYgKGNvbENvdW50ID49IGNvbHMpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaGFyRGF0YSA9IGxpbmVEYXRhLmdldCh4KTtcbiAgICAgICAgICAgIHZhciBjaGFyID0gY2hhckRhdGFbQnVmZmVyXzEuQ0hBUl9EQVRBX0NIQVJfSU5ERVhdO1xuICAgICAgICAgICAgdmFyIGF0dHIgPSBjaGFyRGF0YVtCdWZmZXJfMS5DSEFSX0RBVEFfQVRUUl9JTkRFWF07XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBjaGFyRGF0YVtCdWZmZXJfMS5DSEFSX0RBVEFfV0lEVEhfSU5ERVhdO1xuICAgICAgICAgICAgaWYgKHdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2hhckVsZW1lbnQgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICBpZiAod2lkdGggPiAxKSB7XG4gICAgICAgICAgICAgICAgY2hhckVsZW1lbnQuc3R5bGUud2lkdGggPSBjZWxsV2lkdGggKiB3aWR0aCArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmbGFncyA9IGF0dHIgPj4gMTg7XG4gICAgICAgICAgICB2YXIgYmcgPSBhdHRyICYgMHgxZmY7XG4gICAgICAgICAgICB2YXIgZmcgPSAoYXR0ciA+PiA5KSAmIDB4MWZmO1xuICAgICAgICAgICAgaWYgKGlzQ3Vyc29yUm93ICYmIHggPT09IGN1cnNvclgpIHtcbiAgICAgICAgICAgICAgICBjaGFyRWxlbWVudC5jbGFzc0xpc3QuYWRkKGV4cG9ydHMuQ1VSU09SX0NMQVNTKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGN1cnNvclN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Jhcic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFyRWxlbWVudC5jbGFzc0xpc3QuYWRkKGV4cG9ydHMuQ1VSU09SX1NUWUxFX0JBUl9DTEFTUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndW5kZXJsaW5lJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJFbGVtZW50LmNsYXNzTGlzdC5hZGQoZXhwb3J0cy5DVVJTT1JfU1RZTEVfVU5ERVJMSU5FX0NMQVNTKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhckVsZW1lbnQuY2xhc3NMaXN0LmFkZChleHBvcnRzLkNVUlNPUl9TVFlMRV9CTE9DS19DTEFTUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmxhZ3MgJiA4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBiZztcbiAgICAgICAgICAgICAgICBiZyA9IGZnO1xuICAgICAgICAgICAgICAgIGZnID0gdGVtcDtcbiAgICAgICAgICAgICAgICBpZiAoZmcgPT09IDI1Nikge1xuICAgICAgICAgICAgICAgICAgICBmZyA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChiZyA9PT0gMjU3KSB7XG4gICAgICAgICAgICAgICAgICAgIGJnID0gMTU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZsYWdzICYgMSkge1xuICAgICAgICAgICAgICAgIGlmIChmZyA8IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgZmcgKz0gODtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hhckVsZW1lbnQuY2xhc3NMaXN0LmFkZChleHBvcnRzLkJPTERfQ0xBU1MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZsYWdzICYgNjQpIHtcbiAgICAgICAgICAgICAgICBjaGFyRWxlbWVudC5jbGFzc0xpc3QuYWRkKGV4cG9ydHMuSVRBTElDX0NMQVNTKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoYXJFbGVtZW50LnRleHRDb250ZW50ID0gY2hhcjtcbiAgICAgICAgICAgIGlmIChmZyAhPT0gMjU3KSB7XG4gICAgICAgICAgICAgICAgY2hhckVsZW1lbnQuY2xhc3NMaXN0LmFkZChcInh0ZXJtLWZnLVwiICsgZmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJnICE9PSAyNTYpIHtcbiAgICAgICAgICAgICAgICBjaGFyRWxlbWVudC5jbGFzc0xpc3QuYWRkKFwieHRlcm0tYmctXCIgKyBiZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChjaGFyRWxlbWVudCk7XG4gICAgICAgICAgICBjb2xDb3VudCArPSB3aWR0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgfTtcbiAgICByZXR1cm4gRG9tUmVuZGVyZXJSb3dGYWN0b3J5O1xufSgpKTtcbmV4cG9ydHMuRG9tUmVuZGVyZXJSb3dGYWN0b3J5ID0gRG9tUmVuZGVyZXJSb3dGYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RG9tUmVuZGVyZXJSb3dGYWN0b3J5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFR5cGVzXzEgPSByZXF1aXJlKFwiLi9UeXBlc1wiKTtcbnZhciBCcm93c2VyXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvQnJvd3NlclwiKTtcbmZ1bmN0aW9uIGdlbmVyYXRlU3RhdGljQ2hhckF0bGFzVGV4dHVyZShjb250ZXh0LCBjYW52YXNGYWN0b3J5LCBjb25maWcpIHtcbiAgICB2YXIgY2VsbFdpZHRoID0gY29uZmlnLnNjYWxlZENoYXJXaWR0aCArIFR5cGVzXzEuQ0hBUl9BVExBU19DRUxMX1NQQUNJTkc7XG4gICAgdmFyIGNlbGxIZWlnaHQgPSBjb25maWcuc2NhbGVkQ2hhckhlaWdodCArIFR5cGVzXzEuQ0hBUl9BVExBU19DRUxMX1NQQUNJTkc7XG4gICAgdmFyIGNhbnZhcyA9IGNhbnZhc0ZhY3RvcnkoMjU1ICogY2VsbFdpZHRoLCAoMiArIDE2ICsgMTYpICogY2VsbEhlaWdodCk7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcsIHsgYWxwaGE6IGNvbmZpZy5hbGxvd1RyYW5zcGFyZW5jeSB9KTtcbiAgICBjdHguZmlsbFN0eWxlID0gY29uZmlnLmNvbG9ycy5iYWNrZ3JvdW5kLmNzcztcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBjb25maWcuY29sb3JzLmZvcmVncm91bmQuY3NzO1xuICAgIGN0eC5mb250ID0gZ2V0Rm9udChjb25maWcuZm9udFdlaWdodCwgY29uZmlnKTtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5yZWN0KGkgKiBjZWxsV2lkdGgsIDAsIGNlbGxXaWR0aCwgY2VsbEhlaWdodCk7XG4gICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgIGN0eC5maWxsVGV4dChTdHJpbmcuZnJvbUNoYXJDb2RlKGkpLCBpICogY2VsbFdpZHRoLCAwKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguZm9udCA9IGdldEZvbnQoY29uZmlnLmZvbnRXZWlnaHRCb2xkLCBjb25maWcpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgucmVjdChpICogY2VsbFdpZHRoLCBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQpO1xuICAgICAgICBjdHguY2xpcCgpO1xuICAgICAgICBjdHguZmlsbFRleHQoU3RyaW5nLmZyb21DaGFyQ29kZShpKSwgaSAqIGNlbGxXaWR0aCwgY2VsbEhlaWdodCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgY3R4LmZvbnQgPSBnZXRGb250KGNvbmZpZy5mb250V2VpZ2h0LCBjb25maWcpO1xuICAgIGZvciAodmFyIGNvbG9ySW5kZXggPSAwOyBjb2xvckluZGV4IDwgMTY7IGNvbG9ySW5kZXgrKykge1xuICAgICAgICB2YXIgeSA9IChjb2xvckluZGV4ICsgMikgKiBjZWxsSGVpZ2h0O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnJlY3QoaSAqIGNlbGxXaWR0aCwgeSwgY2VsbFdpZHRoLCBjZWxsSGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY29uZmlnLmNvbG9ycy5hbnNpW2NvbG9ySW5kZXhdLmNzcztcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChTdHJpbmcuZnJvbUNoYXJDb2RlKGkpLCBpICogY2VsbFdpZHRoLCB5KTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3R4LmZvbnQgPSBnZXRGb250KGNvbmZpZy5mb250V2VpZ2h0Qm9sZCwgY29uZmlnKTtcbiAgICBmb3IgKHZhciBjb2xvckluZGV4ID0gMDsgY29sb3JJbmRleCA8IDE2OyBjb2xvckluZGV4KyspIHtcbiAgICAgICAgdmFyIHkgPSAoY29sb3JJbmRleCArIDIgKyAxNikgKiBjZWxsSGVpZ2h0O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnJlY3QoaSAqIGNlbGxXaWR0aCwgeSwgY2VsbFdpZHRoLCBjZWxsSGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY29uZmlnLmNvbG9ycy5hbnNpW2NvbG9ySW5kZXhdLmNzcztcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChTdHJpbmcuZnJvbUNoYXJDb2RlKGkpLCBpICogY2VsbFdpZHRoLCB5KTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICBpZiAoISgnY3JlYXRlSW1hZ2VCaXRtYXAnIGluIGNvbnRleHQpIHx8IEJyb3dzZXJfMS5pc0ZpcmVmb3ggfHwgQnJvd3Nlcl8xLmlzU2FmYXJpKSB7XG4gICAgICAgIGlmIChjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIoY2FudmFzLnRyYW5zZmVyVG9JbWFnZUJpdG1hcCgpKTsgfSk7XG4gICAgfVxuICAgIHZhciBjaGFyQXRsYXNJbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgY2xlYXJDb2xvcihjaGFyQXRsYXNJbWFnZURhdGEsIGNvbmZpZy5jb2xvcnMuYmFja2dyb3VuZCk7XG4gICAgcmV0dXJuIGNvbnRleHQuY3JlYXRlSW1hZ2VCaXRtYXAoY2hhckF0bGFzSW1hZ2VEYXRhKTtcbn1cbmV4cG9ydHMuZ2VuZXJhdGVTdGF0aWNDaGFyQXRsYXNUZXh0dXJlID0gZ2VuZXJhdGVTdGF0aWNDaGFyQXRsYXNUZXh0dXJlO1xuZnVuY3Rpb24gY2xlYXJDb2xvcihpbWFnZURhdGEsIGNvbG9yKSB7XG4gICAgdmFyIGlzRW1wdHkgPSB0cnVlO1xuICAgIHZhciByID0gY29sb3IucmdiYSA+Pj4gMjQ7XG4gICAgdmFyIGcgPSBjb2xvci5yZ2JhID4+PiAxNiAmIDB4RkY7XG4gICAgdmFyIGIgPSBjb2xvci5yZ2JhID4+PiA4ICYgMHhGRjtcbiAgICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBpbWFnZURhdGEuZGF0YS5sZW5ndGg7IG9mZnNldCArPSA0KSB7XG4gICAgICAgIGlmIChpbWFnZURhdGEuZGF0YVtvZmZzZXRdID09PSByICYmXG4gICAgICAgICAgICBpbWFnZURhdGEuZGF0YVtvZmZzZXQgKyAxXSA9PT0gZyAmJlxuICAgICAgICAgICAgaW1hZ2VEYXRhLmRhdGFbb2Zmc2V0ICsgMl0gPT09IGIpIHtcbiAgICAgICAgICAgIGltYWdlRGF0YS5kYXRhW29mZnNldCArIDNdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXNFbXB0eTtcbn1cbmV4cG9ydHMuY2xlYXJDb2xvciA9IGNsZWFyQ29sb3I7XG5mdW5jdGlvbiBnZXRGb250KGZvbnRXZWlnaHQsIGNvbmZpZykge1xuICAgIHJldHVybiBmb250V2VpZ2h0ICsgXCIgXCIgKyBjb25maWcuZm9udFNpemUgKiBjb25maWcuZGV2aWNlUGl4ZWxSYXRpbyArIFwicHggXCIgKyBjb25maWcuZm9udEZhbWlseTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNoYXJBdGxhc0dlbmVyYXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ0hBUl9BVExBU19DRUxMX1NQQUNJTkcgPSAxO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHlwZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNOb2RlID0gKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSA/IHRydWUgOiBmYWxzZTtcbnZhciB1c2VyQWdlbnQgPSAoaXNOb2RlKSA/ICdub2RlJyA6IG5hdmlnYXRvci51c2VyQWdlbnQ7XG52YXIgcGxhdGZvcm0gPSAoaXNOb2RlKSA/ICdub2RlJyA6IG5hdmlnYXRvci5wbGF0Zm9ybTtcbmV4cG9ydHMuaXNGaXJlZm94ID0gISF+dXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKTtcbmV4cG9ydHMuaXNTYWZhcmkgPSAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KHVzZXJBZ2VudCk7XG5leHBvcnRzLmlzTVNJRSA9ICEhfnVzZXJBZ2VudC5pbmRleE9mKCdNU0lFJykgfHwgISF+dXNlckFnZW50LmluZGV4T2YoJ1RyaWRlbnQnKTtcbmV4cG9ydHMuaXNNYWMgPSBjb250YWlucyhbJ01hY2ludG9zaCcsICdNYWNJbnRlbCcsICdNYWNQUEMnLCAnTWFjNjhLJ10sIHBsYXRmb3JtKTtcbmV4cG9ydHMuaXNJcGFkID0gcGxhdGZvcm0gPT09ICdpUGFkJztcbmV4cG9ydHMuaXNJcGhvbmUgPSBwbGF0Zm9ybSA9PT0gJ2lQaG9uZSc7XG5leHBvcnRzLmlzTVNXaW5kb3dzID0gY29udGFpbnMoWydXaW5kb3dzJywgJ1dpbjE2JywgJ1dpbjMyJywgJ1dpbkNFJ10sIHBsYXRmb3JtKTtcbmV4cG9ydHMuaXNMaW51eCA9IHBsYXRmb3JtLmluZGV4T2YoJ0xpbnV4JykgPj0gMDtcbmZ1bmN0aW9uIGNvbnRhaW5zKGFyciwgZWwpIHtcbiAgICByZXR1cm4gYXJyLmluZGV4T2YoZWwpID49IDA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ccm93c2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBFdmVudEVtaXR0ZXJfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vRXZlbnRFbWl0dGVyXCIpO1xudmFyIENoYXJNZWFzdXJlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2hhck1lYXN1cmUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2hhck1lYXN1cmUoZG9jdW1lbnQsIHBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2RvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgIF90aGlzLl9wYXJlbnRFbGVtZW50ID0gcGFyZW50RWxlbWVudDtcbiAgICAgICAgX3RoaXMuX21lYXN1cmVFbGVtZW50ID0gX3RoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgX3RoaXMuX21lYXN1cmVFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3h0ZXJtLWNoYXItbWVhc3VyZS1lbGVtZW50Jyk7XG4gICAgICAgIF90aGlzLl9tZWFzdXJlRWxlbWVudC50ZXh0Q29udGVudCA9ICdXJztcbiAgICAgICAgX3RoaXMuX21lYXN1cmVFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgICAgICBfdGhpcy5fcGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZChfdGhpcy5fbWVhc3VyZUVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGFyTWVhc3VyZS5wcm90b3R5cGUsIFwid2lkdGhcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYXJNZWFzdXJlLnByb3RvdHlwZSwgXCJoZWlnaHRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIENoYXJNZWFzdXJlLnByb3RvdHlwZS5tZWFzdXJlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fbWVhc3VyZUVsZW1lbnQuc3R5bGUuZm9udEZhbWlseSA9IG9wdGlvbnMuZm9udEZhbWlseTtcbiAgICAgICAgdGhpcy5fbWVhc3VyZUVsZW1lbnQuc3R5bGUuZm9udFNpemUgPSBvcHRpb25zLmZvbnRTaXplICsgXCJweFwiO1xuICAgICAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLl9tZWFzdXJlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKGdlb21ldHJ5LndpZHRoID09PSAwIHx8IGdlb21ldHJ5LmhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl93aWR0aCAhPT0gZ2VvbWV0cnkud2lkdGggfHwgdGhpcy5faGVpZ2h0ICE9PSBnZW9tZXRyeS5oZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gZ2VvbWV0cnkud2lkdGg7XG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSBNYXRoLmNlaWwoZ2VvbWV0cnkuaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY2hhcnNpemVjaGFuZ2VkJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDaGFyTWVhc3VyZTtcbn0oRXZlbnRFbWl0dGVyXzEuRXZlbnRFbWl0dGVyKSk7XG5leHBvcnRzLkNoYXJNZWFzdXJlID0gQ2hhck1lYXN1cmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DaGFyTWVhc3VyZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGFkZERpc3Bvc2FibGVEb21MaXN0ZW5lcihub2RlLCB0eXBlLCBoYW5kbGVyLCB1c2VDYXB0dXJlKSB7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIHVzZUNhcHR1cmUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCB1c2VDYXB0dXJlKTtcbiAgICAgICAgICAgIG5vZGUgPSBudWxsO1xuICAgICAgICAgICAgaGFuZGxlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0cy5hZGREaXNwb3NhYmxlRG9tTGlzdGVuZXIgPSBhZGREaXNwb3NhYmxlRG9tTGlzdGVuZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaWZlY3ljbGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIExpZmVjeWNsZV8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9MaWZlY3ljbGVcIik7XG52YXIgTGlmZWN5Y2xlXzIgPSByZXF1aXJlKFwiLi9MaWZlY3ljbGVcIik7XG52YXIgSE9WRVJfRFVSQVRJT04gPSA1MDA7XG52YXIgTW91c2Vab25lTWFuYWdlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1vdXNlWm9uZU1hbmFnZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTW91c2Vab25lTWFuYWdlcihfdGVybWluYWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3Rlcm1pbmFsID0gX3Rlcm1pbmFsO1xuICAgICAgICBfdGhpcy5fem9uZXMgPSBbXTtcbiAgICAgICAgX3RoaXMuX2FyZVpvbmVzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIF90aGlzLl90b29sdGlwVGltZW91dCA9IG51bGw7XG4gICAgICAgIF90aGlzLl9jdXJyZW50Wm9uZSA9IG51bGw7XG4gICAgICAgIF90aGlzLl9sYXN0SG92ZXJDb29yZHMgPSBbbnVsbCwgbnVsbF07XG4gICAgICAgIF90aGlzLnJlZ2lzdGVyKExpZmVjeWNsZV8yLmFkZERpc3Bvc2FibGVEb21MaXN0ZW5lcihfdGhpcy5fdGVybWluYWwuZWxlbWVudCwgJ21vdXNlZG93bicsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBfdGhpcy5fb25Nb3VzZURvd24oZSk7IH0pKTtcbiAgICAgICAgX3RoaXMuX21vdXNlTW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLl9vbk1vdXNlTW92ZShlKTsgfTtcbiAgICAgICAgX3RoaXMuX2NsaWNrTGlzdGVuZXIgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3RoaXMuX29uQ2xpY2soZSk7IH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTW91c2Vab25lTWFuYWdlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX2RlYWN0aXZhdGUoKTtcbiAgICB9O1xuICAgIE1vdXNlWm9uZU1hbmFnZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh6b25lKSB7XG4gICAgICAgIHRoaXMuX3pvbmVzLnB1c2goem9uZSk7XG4gICAgICAgIGlmICh0aGlzLl96b25lcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2YXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vdXNlWm9uZU1hbmFnZXIucHJvdG90eXBlLmNsZWFyQWxsID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3pvbmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZW5kKSB7XG4gICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgICBlbmQgPSB0aGlzLl90ZXJtaW5hbC5yb3dzIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3pvbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgem9uZSA9IHRoaXMuX3pvbmVzW2ldO1xuICAgICAgICAgICAgaWYgKCh6b25lLnkxID4gc3RhcnQgJiYgem9uZS55MSA8PSBlbmQgKyAxKSB8fFxuICAgICAgICAgICAgICAgICh6b25lLnkyID4gc3RhcnQgJiYgem9uZS55MiA8PSBlbmQgKyAxKSB8fFxuICAgICAgICAgICAgICAgICh6b25lLnkxIDwgc3RhcnQgJiYgem9uZS55MiA+IGVuZCArIDEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRab25lICYmIHRoaXMuX2N1cnJlbnRab25lID09PSB6b25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRab25lLmxlYXZlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFpvbmUgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl96b25lcy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fem9uZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWFjdGl2YXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vdXNlWm9uZU1hbmFnZXIucHJvdG90eXBlLl9hY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9hcmVab25lc0FjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5fYXJlWm9uZXNBY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fdGVybWluYWwuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9tb3VzZU1vdmVMaXN0ZW5lcik7XG4gICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fY2xpY2tMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vdXNlWm9uZU1hbmFnZXIucHJvdG90eXBlLl9kZWFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fYXJlWm9uZXNBY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2FyZVpvbmVzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl90ZXJtaW5hbC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX21vdXNlTW92ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmFsLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9jbGlja0xpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTW91c2Vab25lTWFuYWdlci5wcm90b3R5cGUuX29uTW91c2VNb3ZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xhc3RIb3ZlckNvb3Jkc1swXSAhPT0gZS5wYWdlWCB8fCB0aGlzLl9sYXN0SG92ZXJDb29yZHNbMV0gIT09IGUucGFnZVkpIHtcbiAgICAgICAgICAgIHRoaXMuX29uSG92ZXIoZSk7XG4gICAgICAgICAgICB0aGlzLl9sYXN0SG92ZXJDb29yZHMgPSBbZS5wYWdlWCwgZS5wYWdlWV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vdXNlWm9uZU1hbmFnZXIucHJvdG90eXBlLl9vbkhvdmVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHpvbmUgPSB0aGlzLl9maW5kWm9uZUV2ZW50QXQoZSk7XG4gICAgICAgIGlmICh6b25lID09PSB0aGlzLl9jdXJyZW50Wm9uZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50Wm9uZSkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFpvbmUubGVhdmVDYWxsYmFjaygpO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFpvbmUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Rvb2x0aXBUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3Rvb2x0aXBUaW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXpvbmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdXJyZW50Wm9uZSA9IHpvbmU7XG4gICAgICAgIGlmICh6b25lLmhvdmVyQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHpvbmUuaG92ZXJDYWxsYmFjayhlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90b29sdGlwVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX29uVG9vbHRpcChlKTsgfSwgSE9WRVJfRFVSQVRJT04pO1xuICAgIH07XG4gICAgTW91c2Vab25lTWFuYWdlci5wcm90b3R5cGUuX29uVG9vbHRpcCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuX3Rvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgdmFyIHpvbmUgPSB0aGlzLl9maW5kWm9uZUV2ZW50QXQoZSk7XG4gICAgICAgIGlmICh6b25lICYmIHpvbmUudG9vbHRpcENhbGxiYWNrKSB7XG4gICAgICAgICAgICB6b25lLnRvb2x0aXBDYWxsYmFjayhlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTW91c2Vab25lTWFuYWdlci5wcm90b3R5cGUuX29uTW91c2VEb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9hcmVab25lc0FjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB6b25lID0gdGhpcy5fZmluZFpvbmVFdmVudEF0KGUpO1xuICAgICAgICBpZiAoem9uZSkge1xuICAgICAgICAgICAgaWYgKHpvbmUud2lsbExpbmtBY3RpdmF0ZShlKSkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNb3VzZVpvbmVNYW5hZ2VyLnByb3RvdHlwZS5fb25DbGljayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB6b25lID0gdGhpcy5fZmluZFpvbmVFdmVudEF0KGUpO1xuICAgICAgICBpZiAoem9uZSkge1xuICAgICAgICAgICAgem9uZS5jbGlja0NhbGxiYWNrKGUpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTW91c2Vab25lTWFuYWdlci5wcm90b3R5cGUuX2ZpbmRab25lRXZlbnRBdCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBjb29yZHMgPSB0aGlzLl90ZXJtaW5hbC5tb3VzZUhlbHBlci5nZXRDb29yZHMoZSwgdGhpcy5fdGVybWluYWwuc2NyZWVuRWxlbWVudCwgdGhpcy5fdGVybWluYWwuY2hhck1lYXN1cmUsIHRoaXMuX3Rlcm1pbmFsLm9wdGlvbnMubGluZUhlaWdodCwgdGhpcy5fdGVybWluYWwuY29scywgdGhpcy5fdGVybWluYWwucm93cyk7XG4gICAgICAgIGlmICghY29vcmRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeCA9IGNvb3Jkc1swXTtcbiAgICAgICAgdmFyIHkgPSBjb29yZHNbMV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fem9uZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB6b25lID0gdGhpcy5fem9uZXNbaV07XG4gICAgICAgICAgICBpZiAoem9uZS55MSA9PT0gem9uZS55Mikge1xuICAgICAgICAgICAgICAgIGlmICh5ID09PSB6b25lLnkxICYmIHggPj0gem9uZS54MSAmJiB4IDwgem9uZS54Mikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gem9uZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoKHkgPT09IHpvbmUueTEgJiYgeCA+PSB6b25lLngxKSB8fFxuICAgICAgICAgICAgICAgICAgICAoeSA9PT0gem9uZS55MiAmJiB4IDwgem9uZS54MikgfHxcbiAgICAgICAgICAgICAgICAgICAgKHkgPiB6b25lLnkxICYmIHkgPCB6b25lLnkyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gem9uZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gTW91c2Vab25lTWFuYWdlcjtcbn0oTGlmZWN5Y2xlXzEuRGlzcG9zYWJsZSkpO1xuZXhwb3J0cy5Nb3VzZVpvbmVNYW5hZ2VyID0gTW91c2Vab25lTWFuYWdlcjtcbnZhciBNb3VzZVpvbmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1vdXNlWm9uZSh4MSwgeTEsIHgyLCB5MiwgY2xpY2tDYWxsYmFjaywgaG92ZXJDYWxsYmFjaywgdG9vbHRpcENhbGxiYWNrLCBsZWF2ZUNhbGxiYWNrLCB3aWxsTGlua0FjdGl2YXRlKSB7XG4gICAgICAgIHRoaXMueDEgPSB4MTtcbiAgICAgICAgdGhpcy55MSA9IHkxO1xuICAgICAgICB0aGlzLngyID0geDI7XG4gICAgICAgIHRoaXMueTIgPSB5MjtcbiAgICAgICAgdGhpcy5jbGlja0NhbGxiYWNrID0gY2xpY2tDYWxsYmFjaztcbiAgICAgICAgdGhpcy5ob3ZlckNhbGxiYWNrID0gaG92ZXJDYWxsYmFjaztcbiAgICAgICAgdGhpcy50b29sdGlwQ2FsbGJhY2sgPSB0b29sdGlwQ2FsbGJhY2s7XG4gICAgICAgIHRoaXMubGVhdmVDYWxsYmFjayA9IGxlYXZlQ2FsbGJhY2s7XG4gICAgICAgIHRoaXMud2lsbExpbmtBY3RpdmF0ZSA9IHdpbGxMaW5rQWN0aXZhdGU7XG4gICAgfVxuICAgIHJldHVybiBNb3VzZVpvbmU7XG59KCkpO1xuZXhwb3J0cy5Nb3VzZVpvbmUgPSBNb3VzZVpvbmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Nb3VzZVpvbmVNYW5hZ2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFJlbmRlckRlYm91bmNlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVuZGVyRGVib3VuY2VyKF90ZXJtaW5hbCwgX2NhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsID0gX3Rlcm1pbmFsO1xuICAgICAgICB0aGlzLl9jYWxsYmFjayA9IF9jYWxsYmFjaztcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uRnJhbWUgPSBudWxsO1xuICAgIH1cbiAgICBSZW5kZXJEZWJvdW5jZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9hbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX2FuaW1hdGlvbkZyYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbkZyYW1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVuZGVyRGVib3VuY2VyLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKHJvd1N0YXJ0LCByb3dFbmQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcm93U3RhcnQgPSByb3dTdGFydCAhPT0gbnVsbCAmJiByb3dTdGFydCAhPT0gdW5kZWZpbmVkID8gcm93U3RhcnQgOiAwO1xuICAgICAgICByb3dFbmQgPSByb3dFbmQgIT09IG51bGwgJiYgcm93RW5kICE9PSB1bmRlZmluZWQgPyByb3dFbmQgOiB0aGlzLl90ZXJtaW5hbC5yb3dzIC0gMTtcbiAgICAgICAgdmFyIGlzUm93U3RhcnRTZXQgPSB0aGlzLl9yb3dTdGFydCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX3Jvd1N0YXJ0ICE9PSBudWxsO1xuICAgICAgICB2YXIgaXNSb3dFbmRTZXQgPSB0aGlzLl9yb3dFbmQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLl9yb3dFbmQgIT09IG51bGw7XG4gICAgICAgIHRoaXMuX3Jvd1N0YXJ0ID0gaXNSb3dTdGFydFNldCA/IE1hdGgubWluKHRoaXMuX3Jvd1N0YXJ0LCByb3dTdGFydCkgOiByb3dTdGFydDtcbiAgICAgICAgdGhpcy5fcm93RW5kID0gaXNSb3dFbmRTZXQgPyBNYXRoLm1heCh0aGlzLl9yb3dFbmQsIHJvd0VuZCkgOiByb3dFbmQ7XG4gICAgICAgIGlmICh0aGlzLl9hbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5faW5uZXJSZWZyZXNoKCk7IH0pO1xuICAgIH07XG4gICAgUmVuZGVyRGVib3VuY2VyLnByb3RvdHlwZS5faW5uZXJSZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yb3dTdGFydCA9IE1hdGgubWF4KHRoaXMuX3Jvd1N0YXJ0LCAwKTtcbiAgICAgICAgdGhpcy5fcm93RW5kID0gTWF0aC5taW4odGhpcy5fcm93RW5kLCB0aGlzLl90ZXJtaW5hbC5yb3dzIC0gMSk7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrKHRoaXMuX3Jvd1N0YXJ0LCB0aGlzLl9yb3dFbmQpO1xuICAgICAgICB0aGlzLl9yb3dTdGFydCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3Jvd0VuZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbkZyYW1lID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBSZW5kZXJEZWJvdW5jZXI7XG59KCkpO1xuZXhwb3J0cy5SZW5kZXJEZWJvdW5jZXIgPSBSZW5kZXJEZWJvdW5jZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZW5kZXJEZWJvdW5jZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIExpZmVjeWNsZV8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9MaWZlY3ljbGVcIik7XG52YXIgU2NyZWVuRHByTW9uaXRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNjcmVlbkRwck1vbml0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2NyZWVuRHByTW9uaXRvcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBTY3JlZW5EcHJNb25pdG9yLnByb3RvdHlwZS5zZXRMaXN0ZW5lciA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJMaXN0ZW5lcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgIHRoaXMuX291dGVyTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fbGlzdGVuZXIod2luZG93LmRldmljZVBpeGVsUmF0aW8sIF90aGlzLl9jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBfdGhpcy5fdXBkYXRlRHByKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3VwZGF0ZURwcigpO1xuICAgIH07XG4gICAgU2NyZWVuRHByTW9uaXRvci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuY2xlYXJMaXN0ZW5lcigpO1xuICAgIH07XG4gICAgU2NyZWVuRHByTW9uaXRvci5wcm90b3R5cGUuX3VwZGF0ZURwciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Jlc29sdXRpb25NZWRpYU1hdGNoTGlzdCkge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x1dGlvbk1lZGlhTWF0Y2hMaXN0LnJlbW92ZUxpc3RlbmVyKHRoaXMuX291dGVyTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N1cnJlbnREZXZpY2VQaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgIHRoaXMuX3Jlc29sdXRpb25NZWRpYU1hdGNoTGlzdCA9IHdpbmRvdy5tYXRjaE1lZGlhKFwic2NyZWVuIGFuZCAocmVzb2x1dGlvbjogXCIgKyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyArIFwiZHBweClcIik7XG4gICAgICAgIHRoaXMuX3Jlc29sdXRpb25NZWRpYU1hdGNoTGlzdC5hZGRMaXN0ZW5lcih0aGlzLl9vdXRlckxpc3RlbmVyKTtcbiAgICB9O1xuICAgIFNjcmVlbkRwck1vbml0b3IucHJvdG90eXBlLmNsZWFyTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXNvbHV0aW9uTWVkaWFNYXRjaExpc3QucmVtb3ZlTGlzdGVuZXIodGhpcy5fb3V0ZXJMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fb3V0ZXJMaXN0ZW5lciA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gU2NyZWVuRHByTW9uaXRvcjtcbn0oTGlmZWN5Y2xlXzEuRGlzcG9zYWJsZSkpO1xuZXhwb3J0cy5TY3JlZW5EcHJNb25pdG9yID0gU2NyZWVuRHByTW9uaXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNjcmVlbkRwck1vbml0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNsb25lID0gZnVuY3Rpb24gKHZhbCwgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkgeyBkZXB0aCA9IDU7IH1cbiAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGNsb25lZE9iamVjdCA9IEFycmF5LmlzQXJyYXkodmFsKSA/IFtdIDoge307XG4gICAgZm9yICh2YXIga2V5IGluIHZhbCkge1xuICAgICAgICBjbG9uZWRPYmplY3Rba2V5XSA9IGRlcHRoIDw9IDEgPyB2YWxba2V5XSA6IGV4cG9ydHMuY2xvbmUodmFsW2tleV0sIGRlcHRoIC0gMSk7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZWRPYmplY3Q7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2xvbmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTW91c2VIZWxwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1vdXNlSGVscGVyKF9yZW5kZXJlcikge1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICB9XG4gICAgTW91c2VIZWxwZXIuZ2V0Q29vcmRzUmVsYXRpdmVUb0VsZW1lbnQgPSBmdW5jdGlvbiAoZXZlbnQsIGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnBhZ2VYID09PSBudWxsIHx8IGV2ZW50LnBhZ2VYID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcmlnaW5hbEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB2YXIgeCA9IGV2ZW50LnBhZ2VYO1xuICAgICAgICB2YXIgeSA9IGV2ZW50LnBhZ2VZO1xuICAgICAgICB3aGlsZSAoZWxlbWVudCkge1xuICAgICAgICAgICAgeCAtPSBlbGVtZW50Lm9mZnNldExlZnQ7XG4gICAgICAgICAgICB5IC09IGVsZW1lbnQub2Zmc2V0VG9wO1xuICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnQgPSBvcmlnaW5hbEVsZW1lbnQ7XG4gICAgICAgIHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQgIT09IGVsZW1lbnQub3duZXJEb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICB4ICs9IGVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIHkgKz0gZWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfTtcbiAgICBNb3VzZUhlbHBlci5wcm90b3R5cGUuZ2V0Q29vcmRzID0gZnVuY3Rpb24gKGV2ZW50LCBlbGVtZW50LCBjaGFyTWVhc3VyZSwgbGluZUhlaWdodCwgY29sQ291bnQsIHJvd0NvdW50LCBpc1NlbGVjdGlvbikge1xuICAgICAgICBpZiAoIWNoYXJNZWFzdXJlLndpZHRoIHx8ICFjaGFyTWVhc3VyZS5oZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb29yZHMgPSBNb3VzZUhlbHBlci5nZXRDb29yZHNSZWxhdGl2ZVRvRWxlbWVudChldmVudCwgZWxlbWVudCk7XG4gICAgICAgIGlmICghY29vcmRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb29yZHNbMF0gPSBNYXRoLmNlaWwoKGNvb3Jkc1swXSArIChpc1NlbGVjdGlvbiA/IHRoaXMuX3JlbmRlcmVyLmRpbWVuc2lvbnMuYWN0dWFsQ2VsbFdpZHRoIC8gMiA6IDApKSAvIHRoaXMuX3JlbmRlcmVyLmRpbWVuc2lvbnMuYWN0dWFsQ2VsbFdpZHRoKTtcbiAgICAgICAgY29vcmRzWzFdID0gTWF0aC5jZWlsKGNvb3Jkc1sxXSAvIHRoaXMuX3JlbmRlcmVyLmRpbWVuc2lvbnMuYWN0dWFsQ2VsbEhlaWdodCk7XG4gICAgICAgIGNvb3Jkc1swXSA9IE1hdGgubWluKE1hdGgubWF4KGNvb3Jkc1swXSwgMSksIGNvbENvdW50ICsgKGlzU2VsZWN0aW9uID8gMSA6IDApKTtcbiAgICAgICAgY29vcmRzWzFdID0gTWF0aC5taW4oTWF0aC5tYXgoY29vcmRzWzFdLCAxKSwgcm93Q291bnQpO1xuICAgICAgICByZXR1cm4gY29vcmRzO1xuICAgIH07XG4gICAgTW91c2VIZWxwZXIucHJvdG90eXBlLmdldFJhd0J5dGVDb29yZHMgPSBmdW5jdGlvbiAoZXZlbnQsIGVsZW1lbnQsIGNoYXJNZWFzdXJlLCBsaW5lSGVpZ2h0LCBjb2xDb3VudCwgcm93Q291bnQpIHtcbiAgICAgICAgdmFyIGNvb3JkcyA9IHRoaXMuZ2V0Q29vcmRzKGV2ZW50LCBlbGVtZW50LCBjaGFyTWVhc3VyZSwgbGluZUhlaWdodCwgY29sQ291bnQsIHJvd0NvdW50KTtcbiAgICAgICAgdmFyIHggPSBjb29yZHNbMF07XG4gICAgICAgIHZhciB5ID0gY29vcmRzWzFdO1xuICAgICAgICB4ICs9IDMyO1xuICAgICAgICB5ICs9IDMyO1xuICAgICAgICByZXR1cm4geyB4OiB4LCB5OiB5IH07XG4gICAgfTtcbiAgICByZXR1cm4gTW91c2VIZWxwZXI7XG59KCkpO1xuZXhwb3J0cy5Nb3VzZUhlbHBlciA9IE1vdXNlSGVscGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TW91c2VIZWxwZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYWxwaGFiZXQgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXotXycuc3BsaXQoJycpXG4gICwgbGVuZ3RoID0gNjRcbiAgLCBtYXAgPSB7fVxuICAsIHNlZWQgPSAwXG4gICwgaSA9IDBcbiAgLCBwcmV2O1xuXG4vKipcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHNwZWNpZmllZCBudW1iZXIuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBudW1iZXIuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBlbmNvZGUobnVtKSB7XG4gIHZhciBlbmNvZGVkID0gJyc7XG5cbiAgZG8ge1xuICAgIGVuY29kZWQgPSBhbHBoYWJldFtudW0gJSBsZW5ndGhdICsgZW5jb2RlZDtcbiAgICBudW0gPSBNYXRoLmZsb29yKG51bSAvIGxlbmd0aCk7XG4gIH0gd2hpbGUgKG51bSA+IDApO1xuXG4gIHJldHVybiBlbmNvZGVkO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgaW50ZWdlciB2YWx1ZSBzcGVjaWZpZWQgYnkgdGhlIGdpdmVuIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBpbnRlZ2VyIHZhbHVlIHJlcHJlc2VudGVkIGJ5IHRoZSBzdHJpbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBkZWNvZGUoc3RyKSB7XG4gIHZhciBkZWNvZGVkID0gMDtcblxuICBmb3IgKGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVjb2RlZCA9IGRlY29kZWQgKiBsZW5ndGggKyBtYXBbc3RyLmNoYXJBdChpKV07XG4gIH1cblxuICByZXR1cm4gZGVjb2RlZDtcbn1cblxuLyoqXG4gKiBZZWFzdDogQSB0aW55IGdyb3dpbmcgaWQgZ2VuZXJhdG9yLlxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9IEEgdW5pcXVlIGlkLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24geWVhc3QoKSB7XG4gIHZhciBub3cgPSBlbmNvZGUoK25ldyBEYXRlKCkpO1xuXG4gIGlmIChub3cgIT09IHByZXYpIHJldHVybiBzZWVkID0gMCwgcHJldiA9IG5vdztcbiAgcmV0dXJuIG5vdyArJy4nKyBlbmNvZGUoc2VlZCsrKTtcbn1cblxuLy9cbi8vIE1hcCBlYWNoIGNoYXJhY3RlciB0byBpdHMgaW5kZXguXG4vL1xuZm9yICg7IGkgPCBsZW5ndGg7IGkrKykgbWFwW2FscGhhYmV0W2ldXSA9IGk7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIGB5ZWFzdGAsIGBlbmNvZGVgIGFuZCBgZGVjb2RlYCBmdW5jdGlvbnMuXG4vL1xueWVhc3QuZW5jb2RlID0gZW5jb2RlO1xueWVhc3QuZGVjb2RlID0gZGVjb2RlO1xubW9kdWxlLmV4cG9ydHMgPSB5ZWFzdDtcbiIsIi8qIChpZ25vcmVkKSAqLyJdLCJzb3VyY2VSb290IjoiIn0=